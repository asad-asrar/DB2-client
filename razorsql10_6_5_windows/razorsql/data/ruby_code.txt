fn: at_exit
fs: at_exit
fd: Register the block for clean-up to execute at the interpreter termination.
pt: Built-in Methods
fn: autoload
fs: autoload(module, file)
fd: Specifies file to be loaded using the method require, when module accessed for the first time.
pt: Built-in Methods
fn: binding
fs: binding
fd: Returns the data structure of the variable/method binding.
pt: Built-in Methods
fn: caller
fs: caller([level])
fd: Returns the context information of current call in the form used for the variable $@.
pt: Built-in Methods
fn: catch
fs: catch (tag) {...}
fd: Executes the block, and if an non-local exit named tag submitted by the throw, it returns with the value given by the throw.
pt: Built-in Methods
fn: chop
fs: chop
fd: Removes off the last character of the value of the variable $_. Makes a copy to modify.
pt: Built-in Methods
fn: chop!
fs: chop!
fd: Removes off the last character of the value of the variable $_. Modifies the value itself.
pt: Built-in Methods
fn: chomp
fs: chomp([rs])
fd: Removes off the line ending from the value of the variable $_.
pt: Built-in Methods
fn: chomp!
fs: chomp!([rs])
fd: Removes off the line ending from the value of the variable $_.
pt: Built-in Methods
fn: eval
fs: eval(expr[,binding[,filetag[,lineno]]])
fd: Evaluate expr as a Ruby program.
pt: Built-in Methods
fn: exec
fs: exec(command...)
fd: Executes command as a subprocess, and never returns.
pt: Built-in Methods
fn: exit
fs: exit([status])
fd: Exits immediately with status.
pt: Built-in Methods
fn: exit
fs: exit!([status])
fd: Exits with status. Ignores exception handling
pt: Built-in Methods
fn: fail
fs: fail([error_type,][message][,traceback])
fd: Raises an exception
pt: Built-in Methods
fn: fork
fs: fork
fd: Does a fork(2) system call.
pt: Built-in Methods
fn: format
fs: format(format...)
fd: Returns a string formatted according to a format like usual printf conventions of the C language.
pt: Built-in Methods
fn: gets
fs: gets([rs])
fd: Reads a string from the virtual concatenation of each file listed on the command line or standard input.
pt: Built-in Methods
fn: global_variables
fs: global_variables
fd: Returns the list of global variable names defined in the program
pt: Built-in Methods
fn: gsub
fs: gsub(pattern[,replace])
fd: Searches a string held in the variable $_ for a pattern, and if found, replaces all the occurrence of the pattern with the replace and returns the replaced string.
pt: Built-in Methods
fn: gsub!
fs: gsub!(pattern[,replace])
fd: Searches a string held in the variable $_ for a pattern, and if found, replaces all the occurrence of the pattern with the replace and returns the replaced string.
pt: Built-in Methods
fn: iterator?
fs: iterator?
fd: Returns true, if called from within the methods called with the block (the iterators), otherwise false.
pt: Built-in Methods
fn: lamda
fs: lamda
fd: Returns newly created procedure object from the block.
pt: Built-in Methods
fn: load
fs: load(file[,priv])
fd: Loads and evaluates the Ruby program in the file.
pt: Built-in Methods
fn: local_variables
fs: local_variables
fd: Returns the list of local variable names defined in the current scope
pt: Built-in Methods
fn: loop
fs: loop
fd: Loops forever (until terminated explicitly)
pt: Built-in Methods
fn: open
fs: open(file[,mode])
fd: Opens the file, and returns a File object associated with the file.
pt: Built-in Methods
fn: p
fs: p(obj)
fd: Prints a human-readable representation of the obj to the stdout.
pt: Built-in Methods
fn: print 
fs: print(arg1...)
fd: Prints arguments
pt: Built-in Methods
fn: printf
fs: printf([port,]format, arg...)
fd: Prints arguments formatted according to the format.
pt: Built-in Methods
fn: proc
fs: proc
fd: Returns newly created procedure object from the block.
pt: Built-in Methods
fn: putc
fs: putc(c)
fd: Writes a character to the default output.
pt: Built-in Methods
fn: puts
fs: puts(obj...)
fd: Writes an obj to the default output.
pt: Built-in Methods
fn: raise
fs: raise([error_type,][message][,traceback])
fd: Raises an exception
pt: Built-in Methods
fn: rand
fs: rand(max)
fd: Returns a random integer number greater than or equal to 0 and less than the value of max.
pt: Built-in Methods
fn: readline
fs: readline([rs])
fd: Reads a string from the virtual concatenation of each file listed on the command line or standard input.
pt: Built-in Methods
fn: readlines
fs: readlines([rs])
fd: Reads entire lines from the virtual concatenation of each file listed on the command line or standard input
pt: Built-in Methods
fn: require
fs: require(feature)
fd: Demands a library file specified by feature.
pt: Built-in Methods
fn: select
fs: select(reads[,writes[,excepts[,timeout]]])
fd: Calls select(2) system call. Reads, writes, excepts are specified arrays containing instances of the IO class (or its subclass), or nil.
pt: Built-in Methods
fn: sleep
fs: sleep([sec])
fd: Causes the script to sleep for sec seconds, or forever if no argument is given.
pt: Built-in Methods
fn: split
fs: split([sep[,limit]])
fd: Return an array containing the fields of the string, using the string sep as a separator.
pt: Built-in Methods
fn: sprintf
fs: sprintf(format...)
fd: Returns a string formatted according to a format like usual printf conventions of the C language.
pt: Built-in Methods
fn: srand
fs: srand([seed])
fd: Sets the random number seed for the rand. 
pt: Built-in Methods
fn: sub
fs: sub(pattern[,replace])
fd: Searches a string held in the variable $_ for a pattern, and if found, replaces the first occurrence of the pattern with the replace and returns the replaced string.
pt: Built-in Methods
fn: sub!
fs: sub!(pattern[,replace])
fd: Searches a string held in the variable $_ for a pattern, and if found, replaces the first occurrence of the pattern with the replace and returns the replaced string.
pt: Built-in Methods
fn: syscall
fs: syscall(num, arg...)
fd: Calls the system call specified as the first arguments, passing remaining as arguments to the system call. The arguments must be either a string or an integer.
pt: Built-in Methods
fn: system
fs: system(command...)
fd: Perform command in the sub-process, wait for the sub-process to terminate, then return true if it successfully exits, otherwise false. 
pt: Built-in Methods
fn: test
fs: test(cmd,file[,file])
fd: Does a file test.
pt: Built-in Methods
fn: throw
fs: throw(tag[,value])
fd: Casts an non-local exit to the enclosing catch waiting for tag, or terminates the program if no such catch waiting. 
pt: Built-in Methods
fn: trace_var
fs: trace_var(variable,command) or trace_var(variable){...}
fd: Sets the hook to the variable, which is called when the value of the variable changed.
pt: Built-in Methods
fn: trap
fs: trap(signal, command) or trap(signal){...}
fd: Specifies the signal handler for the signal. 
pt: Built-in Methods
fn: untrace_var
fs: untrace_var(variable[,command])
fd: Deletes the hook associated with the variable
pt: Built-in Methods
fn: abbrev
fs: abbrev(words, pattern = nil)
fd: Given a set of strings, calculate the set of unambiguous abbreviations for those strings, and return a hash where the keys are all the possible abbreviations and the values are the full strings. Thus, given input of &quot;car&quot; and &quot;cone&quot;, the keys pointing to &quot;car&quot; would be &quot;ca&quot; and &quot;car&quot;, while those pointing to &quot;cone&quot; would be &quot;co&quot;, &quot;con&quot;, and &quot;cone&quot;.
pt: Abbrev
mt: instance
fn: match
fs: match(addr)
fd: 
pt: ACL::ACLEntry
mt: instance
fn: new
fs: new(str)
fd: 
pt: ACL::ACLEntry
mt: class
fn: add
fs: add(str)
fd: 
pt: ACL::ACLList
mt: instance
fn: match
fs: match(addr)
fd: 
pt: ACL::ACLList
mt: instance
fn: new
fs: new()
fd: 
pt: ACL::ACLList
mt: class
fn: allow_addr?
fs: allow_addr?(addr)
fd: 
pt: ACL
mt: instance
fn: allow_socket?
fs: allow_socket?(soc)
fd: 
pt: ACL
mt: instance
fn: install_list
fs: install_list(list)
fd: 
pt: ACL
mt: instance
fn: new
fs: new(list=nil, order = DENY_ALLOW)
fd: 
pt: ACL
mt: class
fn: extend_object
fs: extend_object(obj)
fd: Initializes instance variable.
pt: Arguable
mt: class
fn: getopts
fs: getopts(*args)
fd: Substitution of getopts is possible as follows. Also see OptionParser#getopts.
pt: Arguable
mt: instance
fn: new
fs: new(*args)
fd: 
pt: Arguable
mt: class
fn: options=
fs: options=(opt)
fd: Sets OptionParser object, when opt is false or nil, methods OptionParser::Arguable#options and OptionParser::Arguable#options= are undefined. Thus, there is no ways to access the OptionParser object via the receiver object.
pt: Arguable
mt: instance
fn: options
fs: options()
fd: Actual OptionParser object, automatically created if nonexistent.
pt: Arguable
mt: instance
fn: order!
fs: order!(&blk)
fd: Parses self destructively in order and returns self containing the rest arguments left unparsed.
pt: Arguable
mt: instance
fn: parse!
fs: parse!()
fd: Parses self destructively and returns self containing the rest arguments left unparsed.
pt: Arguable
mt: instance
fn: permute!
fs: permute!()
fd: Parses self destructively in permutation mode and returns self containing the rest arguments left unparsed.
pt: Arguable
mt: instance
fn: abbrev
fs: abbrev(pattern = nil)
fd: Calculates the set of unambiguous abbreviations for the strings in self. If passed a pattern or a string, only the strings matching the pattern or starting with the string are considered.
pt: Array
mt: instance
fn: assoc
fs: assoc(obj)
fd: Searches through an array whose elements are also arrays comparing obj with the first element of each contained array using obj.==. Returns the first contained array that matches (that is, the first associated array), or nil if no match is found. See also Array#rassoc.
pt: Array
mt: instance
fn: at
fs: at(index)
fd: Returns the element at index. A negative index counts from the end of self. Returns nil if the index is out of range. See also Array#[]. (Array#at is slightly faster than Array#[], as it does not accept ranges and so on.)
pt: Array
mt: instance
fn: clear
fs: clear
fd: Removes all elements from self.
pt: Array
mt: instance
fn: collect!
fs: collect!
fd: Invokes the block once for each element of self, replacing the element with the value returned by block. See also Enumerable#collect.
pt: Array
mt: instance
fn: collect
fs: collect
fd: Invokes block once for each element of self. Creates a new array containing the values returned by the block. See also Enumerable#collect.
pt: Array
mt: instance
fn: compact!
fs: compact!
fd: Removes nil elements from array. Returns nil if no changes were made.
pt: Array
mt: instance
fn: compact
fs: compact
fd: Returns a copy of self with all nil elements removed.
pt: Array
mt: instance
fn: concat
fs: concat(other_array)
fd: Appends the elements in other_array to self.
pt: Array
mt: instance
fn: dclone
fs: dclone()
fd: 
pt: Array
mt: instance
fn: delete
fs: delete(obj)
fd: Deletes items from self that are equal to obj. If the item is not found, returns nil. If the optional code block is given, returns the result of block if the item is not found.
pt: Array
mt: instance
fn: delete_at
fs: delete_at(index)
fd: Deletes the element at the specified index, returning that element, or nil if the index is out of range. See also Array#slice!.
pt: Array
mt: instance
fn: delete_if
fs: delete_if
fd: Deletes every element of self for which block evaluates to true.
pt: Array
mt: instance
fn: each
fs: each
fd: Calls block once for each element in self, passing that element as a parameter.
pt: Array
mt: instance
fn: each_index
fs: each_index
fd: Same as Array#each, but passes the index of the element instead of the element itself.
pt: Array
mt: instance
fn: empty?
fs: empty?
fd: Returns true if self array contains no elements.
pt: Array
mt: instance
fn: eql?
fs: eql?(other)
fd: Returns true if array and other are the same object, or are both arrays with the same content.
pt: Array
mt: instance
fn: fetch
fs: fetch(index)
fd: Tries to return the element at position index. If the index lies outside the array, the first form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking the block, passing in the index. Negative values of index count from the end of the array.
pt: Array
mt: instance
fn: fill
fs: fill(obj)
fd: The first three forms set the selected elements of self (which may be the entire array) to obj. A start of nil is equivalent to zero. A length of nil is equivalent to self.length. The last three forms fill the array with the value of the block. The block is passed the absolute index of each element to be filled.
pt: Array
mt: instance
fn: first
fs: first(n)
fd: Returns the first element, or the first n elements, of the array. If the array is empty, the first form returns nil, and the second form returns an empty array.
pt: Array
mt: instance
fn: flatten!
fs: flatten!
fd: Flattens self in place. Returns nil if no modifications were made (i.e., array contains no subarrays.)
pt: Array
mt: instance
fn: flatten
fs: flatten
fd: Returns a new array that is a one-dimensional flattening of this array (recursively). That is, for every element that is an array, extract its elements into the new array.
pt: Array
mt: instance
fn: frozen?
fs: frozen?
fd: Return true if this array is frozen (or temporarily frozen while being sorted).
pt: Array
mt: instance
fn: hash
fs: hash
fd: Compute a hash-code for this array. Two arrays with the same content will have the same hash code (and will compare using eql?).
pt: Array
mt: instance
fn: include?
fs: include?(obj)
fd: Returns true if the given object is present in self (that is, if any object == anObject), false otherwise.
pt: Array
mt: instance
fn: index
fs: index(obj)
fd: Returns the index of the first object in self such that is == to obj. Returns nil if no match is found.
pt: Array
mt: instance
fn: indexes
fs: indexes( i1, i2, ... iN )
fd: Deprecated; use Array#values_at.
pt: Array
mt: instance
fn: indices
fs: indices( i1, i2, ... iN )
fd: Deprecated; use Array#values_at.
pt: Array
mt: instance
fn: initialize_copy
fs: initialize_copy  array.replace(other_array)
fd: Replaces the contents of self with the contents of other_array, truncating or expanding if necessary.
pt: Array
mt: instance
fn: insert
fs: insert(index, obj...)
fd: Inserts the given values before the element with the given index (which may be negative).
pt: Array
mt: instance
fn: inspect
fs: inspect
fd: Create a printable version of array.
pt: Array
mt: instance
fn: join
fs: join(sep=$,)
fd: Returns a string created by converting each element of the array to a string, separated by sep.
pt: Array
mt: instance
fn: last
fs: last(n)
fd: Returns the last element(s) of self. If the array is empty, the first form returns nil.
pt: Array
mt: instance
fn: length
fs: length
fd: Returns the number of elements in self. May be zero.
pt: Array
mt: instance
fn: map!
fs: map!
fd: Invokes the block once for each element of self, replacing the element with the value returned by block. See also Enumerable#collect.
pt: Array
mt: instance
fn: map
fs: map
fd: Invokes block once for each element of self. Creates a new array containing the values returned by the block. See also Enumerable#collect.
pt: Array
mt: instance
fn: new
fs: new(size=0, obj=nil)
fd: Returns a new array. In the first form, the new array is empty. In the second it is created with size copies of obj (that is, size references to the same obj). The third form creates a copy of the array passed as a parameter (the array is generated by calling to_ary on the parameter). In the last form, an array of the given size is created. Each element in this array is calculated by passing the element's index to the given block and storing the return value.
pt: Array
mt: class
fn: nitems
fs: nitems
fd: Returns the number of non-nil elements in self. May be zero.
pt: Array
mt: instance
fn: pack
fs: pack( aTemplateString )
fd: Packs the contents of arr into a binary sequence according to the directives in aTemplateString (see the table below) Directives ``A,'' ``a,'' and ``Z'' may be followed by a count, which gives the width of the resulting field. The remaining directives also may take a count, indicating the number of array elements to convert. If the count is an asterisk (``*''), all remaining array elements will be converted. Any of the directives ``sSiIlL'' may be followed by an underscore (``_'') to use the underlying platform's native size for the specified type; otherwise, they use a platform-independent size. Spaces are ignored in the template string. See also String#unpack.
pt: Array
mt: instance
fn: pop
fs: pop
fd: Removes the last element from self and returns it, or nil if the array is empty.
pt: Array
mt: instance
fn: pretty_print
fs: pretty_print(q)
fd: 
pt: Array
mt: instance
fn: pretty_print_cycle
fs: pretty_print_cycle(q)
fd: 
pt: Array
mt: instance
fn: push
fs: push(obj, ... )
fd: Append---Pushes the given object(s) on to the end of this array. This expression returns the array itself, so several appends may be chained together.
pt: Array
mt: instance
fn: quote
fs: quote()
fd: 
pt: Array
mt: instance
fn: rassoc
fs: rassoc(key)
fd: Searches through the array whose elements are also arrays. Compares key with the second element of each contained array using ==. Returns the first contained array that matches. See also Array#assoc.
pt: Array
mt: instance
fn: reject!
fs: reject!
fd: Equivalent to Array#delete_if, deleting elements from self for which the block evaluates to true, but returns nil if no changes were made. Also see Enumerable#reject.
pt: Array
mt: instance
fn: reject
fs: reject
fd: Returns a new array containing the items in self for which the block is not true.
pt: Array
mt: instance
fn: replace
fs: replace(other_array)
fd: Replaces the contents of self with the contents of other_array, truncating or expanding if necessary.
pt: Array
mt: instance
fn: reverse!
fs: reverse!
fd: Reverses self in place.
pt: Array
mt: instance
fn: reverse
fs: reverse
fd: Returns a new array containing self's elements in reverse order.
pt: Array
mt: instance
fn: reverse_each
fs: reverse_each
fd: Same as Array#each, but traverses self in reverse order.
pt: Array
mt: instance
fn: rindex
fs: rindex(obj)
fd: Returns the index of the last object in array == to obj. Returns nil if no match is found.
pt: Array
mt: instance
fn: select
fs: select
fd: Invokes the block passing in successive elements from array, returning an array containing those elements for which the block returns a true value (equivalent to Enumerable#select).
pt: Array
mt: instance
fn: shift
fs: shift
fd: Returns the first element of self and removes it (shifting all other elements down by one). Returns nil if the array is empty.
pt: Array
mt: instance
fn: size
fs: size()
fd: "Alias for #length"
pt: Array
mt: instance
fn: slice!
fs: slice!(index)
fd: "Deletes the element(s) given by an index (optionally with a length) or by a range. Returns the deleted object, subarray, or nil if the index is out of range. Equivalent to:"
pt: Array
mt: instance
fn: slice
fs: slice(index)
fd: Element Reference---Returns the element at index, or returns a subarray starting at start and continuing for length elements, or returns a subarray specified by range. Negative indices count backward from the end of the array (-1 is the last element). Returns nil if the index (or starting index) are out of range.
pt: Array
mt: instance
fn: sort!
fs: sort!
fd: Sorts self. Comparisons for the sort will be done using the &lt;=&gt; operator or using an optional code block. The block implements a comparison between a and b, returning -1, 0, or +1. See also Enumerable#sort_by.
pt: Array
mt: instance
fn: sort
fs: sort
fd: Returns a new array created by sorting self. Comparisons for the sort will be done using the &lt;=&gt; operator or using an optional code block. The block implements a comparison between a and b, returning -1, 0, or +1. See also Enumerable#sort_by.
pt: Array
mt: instance
fn: to_a
fs: to_a
fd: Returns self. If called on a subclass of Array, converts the receiver to an Array object.
pt: Array
mt: instance
fn: to_ary
fs: to_ary
fd: Returns self.
pt: Array
mt: instance
fn: to_s
fs: to_s
fd: Returns self.join.
pt: Array
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Array
mt: instance
fn: transpose
fs: transpose
fd: Assumes that self is an array of arrays and transposes the rows and columns.
pt: Array
mt: instance
fn: uniq!
fs: uniq!
fd: Removes duplicate elements from self. Returns nil if no changes are made (that is, no duplicates are found).
pt: Array
mt: instance
fn: uniq
fs: uniq
fd: Returns a new array by removing duplicate values in self.
pt: Array
mt: instance
fn: unshift
fs: unshift(obj, ...)
fd: Prepends objects to the front of array. other elements up one.
pt: Array
mt: instance
fn: values_at
fs: values_at(selector,... )
fd: Returns an array containing the elements in self corresponding to the given selector(s). The selectors may be either integer indices or ranges. See also Array#select.
pt: Array
mt: instance
fn: yaml_initialize
fs: yaml_initialize( tag, val )
fd: 
pt: Array
mt: instance
fn: zip
fs: zip(arg, ...)
fd: Converts any arguments to arrays, then merges elements of self with corresponding elements from each argument. This generates a sequence of self.size n-element arrays, where n is one more that the count of arguments. If the size of any argument is less than enumObj.size, nil values are supplied. If a block given, it is invoked for each output array, otherwise an array of arrays is returned.
pt: Array
mt: instance
fn: b64encode
fs: b64encode(bin, len = 60)
fd: Prints the Base64 encoded version of bin (a String) in lines of len (default 60) characters.
pt: Base64
mt: instance
fn: decode64
fs: decode64(str)
fd: Returns the Base64-decoded version of str.
pt: Base64
mt: instance
fn: decode_b
fs: decode_b(str)
fd: Decodes text formatted using a subset of RFC2047 (the one used for mime-encoding mail headers).
pt: Base64
mt: instance
fn: encode64
fs: encode64(bin)
fd: Returns the Base64-encoded version of str.
pt: Base64
mt: instance
fn: getsockopt
fs: getsockopt" getsockopt(level, optname)
fd: Gets a socket option. These are protocol and system specific, see your local sytem documentation for details. The option is returned as a String with the data being the binary value of the socket option.
pt: BasicSocket
mt: instance
fn: recv_nonblock
fs: recv_nonblock(maxlen)
fd: Receives up to maxlen bytes from socket using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. flags is zero or more of the MSG_ options. The result, mesg, is the data received.
pt: BasicSocket
mt: instance
fn: setsockopt
fs: setsockopt" setsockopt(level, optname, optval)
fd: Sets a socket option. These are protocol and system specific, see your local sytem documentation for details.
pt: BasicSocket
mt: instance
fn: benchmark
fs: benchmark(caption = "", label_width = nil, fmtstr = nil, *labels)
fd: Invokes the block with a Benchmark::Report object, which may be used to collect and report on the results of individual benchmark tests. Reserves label_width leading spaces for labels on each line. Prints caption at the top of the report, and uses fmt to format each line. If the block returns an array of Benchmark::Tms objects, these will be used to format additional lines of output. If label parameters are given, these are used to label these extra lines.
pt: Benchmark
mt: instance
fn: bm
fs: bm(label_width = 0, *labels)
fd: "A simple interface to the #benchmark method, #bm is generates sequential reports with labels. The parameters have the same meaning as for #benchmark."
pt: Benchmark
mt: instance
fn: bmbm
fs: bmbm(width = 0)
fd: "Sometimes benchmark results are skewed because code executed earlier encounters different garbage collection overheads than that run later. #bmbm attempts to minimize this effect by running the tests twice, the first time as a rehearsal in order to get the runtime environment stable, the second time for real. GC.start is executed before the start of each of the real timings; the cost of this is not included in the timings. In reality, though, there's only so much that #bmbm can do, and the results are not guaranteed to be isolated from garbage collection and other effects."
pt: Benchmark
mt: instance
fn: measure
fs: measure(label = "")
fd: Returns the time used to execute the given block as a Benchmark::Tms object.
pt: Benchmark
mt: instance
fn: realtime
fs: realtime()
fd: Returns the elapsed real time used to execute the given block.
pt: Benchmark
mt: instance
fn: add!
fs: add!()
fd: "An in-place version of #add."
pt: Benchmark::Tms
mt: instance
fn: add
fs: add()
fd: Returns a new Tms object whose times are the sum of the times for this Tms object, plus the time required to execute the code block (blk).
pt: Benchmark::Tms
mt: instance
fn: format
fs: format(arg0 = nil, *args)
fd: "Returns the contents of this Tms object as a formatted string, according to a format string like that passed to Kernel.format. In addition, #format accepts the following extensions:"
pt: Benchmark::Tms
mt: instance
fn: new
fs: new(u = 0.0, s = 0.0, cu = 0.0, cs = 0.0, real = 0.0, l = nil)
fd: Returns an initialized Tms object which has u as the user CPU time, s as the system CPU time, cu as the children's user CPU time, cs as the children's system CPU time, real as the elapsed real time and l as the label.
pt: Benchmark::Tms
mt: class
fn: to_a
fs: to_a()
fd: Returns a new 6-element array, consisting of the label, user CPU time, system CPU time, children's user CPU time, children's system CPU time and elapsed real time.
pt: Benchmark::Tms
mt: instance
fn: to_s
fs: to_s()
fd: "Same as #format."
pt: Benchmark::Tms
mt: instance
fn: abs
fs: abs
fd: Returns the absolute value of big.
pt: Bignum
mt: instance
fn: coerce
fs: coerce(p1)
fd: "MISSING: documentation"
pt: Bignum
mt: instance
fn: div
fs: div(other)
fd: Divides big by other, returning the result.
pt: Bignum
mt: instance
fn: divmod
fs: divmod(numeric)
fd: See Numeric#divmod.
pt: Bignum
mt: instance
fn: eql?
fs: eql?(obj)
fd: Returns true only if obj is a Bignum with the same value as big. Contrast this with Bignum#==, which performs type conversions.
pt: Bignum
mt: instance
fn: hash
fs: hash
fd: Compute a hash based on the value of big.
pt: Bignum
mt: instance
fn: modulo
fs: modulo(other)
fd: Returns big modulo other. See Numeric.divmod for more information.
pt: Bignum
mt: instance
fn: new
fs: new
fd: 
pt: Bignum
mt: class
fn: power!
fs: power!(p1)
fd: "Alias for #**"
pt: Bignum
mt: instance
fn: quo
fs: quo(other)
fd: If Rational is defined, returns a Rational number instead of a Bignum.
pt: Bignum
mt: instance
fn: rdiv
fs: rdiv(p1)
fd: "Alias for #quo"
pt: Bignum
mt: instance
fn: remainder
fs: remainder(numeric)
fd: Returns the remainder after dividing big by numeric.
pt: Bignum
mt: instance
fn: rpower
fs: rpower(other)
fd: Returns a Rational number if the result is in fact rational (i.e. other &lt; 0).
pt: Bignum
mt: instance
fn: size
fs: size
fd: Returns the number of bytes in the machine representation of big.
pt: Bignum
mt: instance
fn: to_f
fs: to_f
fd: Converts big to a Float. If big doesn't fit in a Float, the result is infinity.
pt: Bignum
mt: instance
fn: to_s
fs: to_s(base=10)
fd: Returns a string containing the representation of big radix base (2 through 36).
pt: Bignum
mt: instance
fn: clone
fs: clone()
fd: "MISSING: documentation"
pt: Binding
mt: instance
fn: dup
fs: dup()
fd: "MISSING: documentation"
pt: Binding
mt: instance
fn: new
fs: new
fd: 
pt: Binding
mt: class
fn: new
fs: new(name = "", *value)
fd: Create a new CGI::Cookie object.
pt: CGI::Cookie
mt: class
fn: parse
fs: parse(raw_cookie)
fd: Parse a raw cookie string into a hash of cookie-name=&gt;Cookie pairs.
pt: CGI::Cookie
mt: class
fn: secure=
fs: secure=(val)
fd: Set whether the Cookie is a secure cookie or not.
pt: CGI::Cookie
mt: instance
fn: to_s
fs: to_s()
fd: Convert the Cookie to its string representation.
pt: CGI::Cookie
mt: instance
fn: cookie
fs: cookie(options)
fd: make raw cookie string
pt: CGI
mt: class
fn: error
fs: error()
fd: print error message to $&gt; and exit
pt: CGI
mt: class
fn: escape
fs: escape(str)
fd: escape url encode
pt: CGI
mt: class
fn: escapeElement
fs: escapeElement(string, *elements)
fd: Escape only the tags of certain HTML elements in string.
pt: CGI
mt: class
fn: escapeHTML
fs: escapeHTML(string)
fd: Escape special characters in HTML, namely &amp;\&quot;&lt;&gt;
pt: CGI
mt: class
fn: header
fs: header(*options)
fd: make HTTP header string
pt: CGI
mt: class
fn: header
fs: header(options = "text/html")
fd: Create an HTTP header block as a string.
pt: CGI
mt: instance
fn: a
fs: a(href = "")
fd: Generate an Anchor element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: base
fs: base(href = "")
fd: Generate a Document Base URI element as a String.
pt: CGI::HtmlExtension
mt: instance
fn: blockquote
fs: blockquote(cite = nil)
fd: Generate a BlockQuote element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: caption
fs: caption(align = nil)
fd: Generate a Table Caption element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: checkbox
fs: checkbox(name = "", value = nil, checked = nil)
fd: Generate a Checkbox Input element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: checkbox_group
fs: checkbox_group(name = "", *values)
fd: Generate a sequence of checkbox elements, as a String.
pt: CGI::HtmlExtension
mt: instance
fn: file_field
fs: file_field(name = "", size = 20, maxlength = nil)
fd: Generate an File Upload Input element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: form
fs: form(method = "post", action = script_name, enctype = "application/x-www-form-urlencoded")
fd: Generate a Form element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: hidden
fs: hidden(name = "", value = nil)
fd: Generate a Hidden Input element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: html
fs: html(attributes = {})
fd: Generate a top-level HTML element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: image_button
fs: image_button(src = "", name = nil, alt = nil)
fd: Generate an Image Button Input element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: img
fs: img(src = "", alt = "", width = nil, height = nil)
fd: Generate an Image element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: multipart_form
fs: multipart_form(action = nil, enctype = "multipart/form-data")
fd: Generate a Form element with multipart encoding as a String.
pt: CGI::HtmlExtension
mt: instance
fn: password_field
fs: password_field(name = "", value = nil, size = 40, maxlength = nil)
fd: Generate a Password Input element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: popup_menu
fs: popup_menu(name = "", *values)
fd: Generate a Select element as a string.
pt: CGI::HtmlExtension
mt: instance
fn: radio_button
fs: radio_button(name = "", value = nil, checked = nil)
fd: Generates a radio-button Input element.
pt: CGI::HtmlExtension
mt: instance
fn: radio_group
fs: radio_group(name = "", *values)
fd: Generate a sequence of radio button Input elements, as a String.
pt: CGI::HtmlExtension
mt: instance
fn: reset
fs: reset(value = nil, name = nil)
fd: Generate a reset button Input element, as a String.
pt: CGI::HtmlExtension
mt: instance
fn: scrolling_list
fs: scrolling_list(name = "", *values)
fd: "Alias for #popup_menu"
pt: CGI::HtmlExtension
mt: instance
fn: submit
fs: submit(value = nil, name = nil)
fd: Generate a submit button Input element, as a String.
pt: CGI::HtmlExtension
mt: instance
fn: text_field
fs: text_field(name = "", value = nil, size = 40, maxlength = nil)
fd: Generate a text field Input element, as a String.
pt: CGI::HtmlExtension
mt: instance
fn: textarea
fs: textarea(name = "", cols = 70, rows = 10)
fd: Generate a TextArea element, as a String.
pt: CGI::HtmlExtension
mt: instance
fn: message
fs: message"(message, title = \"\", header = [\"Content-Type: text/html\"])
fd: print message to $&gt;
pt: CGI
mt: class
fn: new
fs: new(type = "query")
fd: Creates a new CGI instance.
pt: CGI
mt: class
fn: out
fs: out(options = "text/html")
fd: Print an HTTP header and body to $DEFAULT_OUTPUT ($&gt;)
pt: CGI
mt: instance
fn: parse
fs: parse(query)
fd: Parse an HTTP query string into a hash of key=&gt;value pairs.
pt: CGI
mt: class
fn: pretty
fs: pretty(string, shift = " ")
fd: Prettify (indent) an HTML string.
pt: CGI
mt: class
fn: print
fs: print(*options)
fd: print HTTP header and string to $&gt;
pt: CGI
mt: class
fn: print
fs: print(*options)
fd: Print an argument or list of arguments to the default output stream
pt: CGI
mt: instance
fn: has_key?
fs: has_key?(*args)
fd: Returns true if a given parameter key exists in the query.
pt: CGI::QueryExtension
mt: instance
fn: include?
fs: include?(*args)
fd: "Alias for #has_key?"
pt: CGI::QueryExtension
mt: instance
fn: key?
fs: key?(*args)
fd: "Alias for #has_key?"
pt: CGI::QueryExtension
mt: instance
fn: keys
fs: keys(*args)
fd: Return all parameter keys as an array.
pt: CGI::QueryExtension
mt: instance
fn: multipart?
fs: multipart?()
fd: 
pt: CGI::QueryExtension
mt: instance
fn: params=
fs: params=(hash)
fd: Set all the parameters.
pt: CGI::QueryExtension
mt: instance
fn: raw_cookie
fs: raw_cookie()
fd: Get the raw cookies as a string.
pt: CGI::QueryExtension
mt: instance
fn: raw_cookie2
fs: raw_cookie2()
fd: Get the raw RFC2965 cookies as a string.
pt: CGI::QueryExtension
mt: instance
fn: read_from_cmdline
fs: read_from_cmdline()
fd: offline mode. read name=value pairs on standard input.
pt: CGI
mt: instance
fn: rfc1123_date
fs: rfc1123_date(time)
fd: make rfc1123 date string
pt: CGI
mt: class
fn: close
fs: close()
fd: Store session data on the server and close the session storage. For some session storage types, this is a no-op.
pt: CGI::Session
mt: instance
fn: delete
fs: delete()
fd: Delete the session from storage. Also closes the storage.
pt: CGI::Session
mt: instance
fn: close
fs: close()
fd: Update and close the session's FileStore file.
pt: CGI::Session::FileStore
mt: instance
fn: delete
fs: delete()
fd: Close and delete the session's FileStore file.
pt: CGI::Session::FileStore
mt: instance
fn: new
fs: new(session, option={})
fd: Create a new FileStore instance.
pt: CGI::Session::FileStore
mt: class
fn: restore
fs: restore()
fd: Restore session state from the session's FileStore file.
pt: CGI::Session::FileStore
mt: instance
fn: update
fs: update()
fd: Save session state to the session's FileStore file.
pt: CGI::Session::FileStore
mt: instance
fn: close
fs: close()
fd: Close session storage.
pt: CGI::Session::MemoryStore
mt: instance
fn: delete
fs: delete()
fd: Delete the session state.
pt: CGI::Session::MemoryStore
mt: instance
fn: new
fs: new(session, option=nil)
fd: Create a new MemoryStore instance.
pt: CGI::Session::MemoryStore
mt: class
fn: restore
fs: restore()
fd: Restore session state.
pt: CGI::Session::MemoryStore
mt: instance
fn: update
fs: update()
fd: Update session state.
pt: CGI::Session::MemoryStore
mt: instance
fn: new
fs: new(request, option={})
fd: Create a new CGI::Session object for request.
pt: CGI::Session
mt: class
fn: update
fs: update()
fd: Store session data on the server. For some session storage types, this is a no-op.
pt: CGI::Session
mt: instance
fn: tag
fs: tag"(element, attributes = {})
fd: make HTML tag string
pt: CGI
mt: class
fn: unescape
fs: unescape(str)
fd: unescape url encoded
pt: CGI
mt: class
fn: unescapeElement
fs: unescapeElement(string, *elements)
fd: Undo escaping such as that done by CGI::escapeElement()
pt: CGI
mt: class
fn: unescapeHTML
fs: unescapeHTML(string)
fd: Unescape a string that has been HTML-escaped
pt: CGI
mt: class
fn: allocate
fs: allocate()
fd: Allocates space for a new object of class's class. The returned object must be an instance of class.
pt: Class
mt: instance
fn: inherited
fs: inherited  inherited(subclass)
fd: Callback invoked whenever a subclass of the current class is created.
pt: Class
mt: instance
fn: new
fs: new(super_class=Object)
fd: Creates a new anonymous (unnamed) class with the given superclass (or Object if no parameter is given). You can give a class a name by assigning the class object to a constant.
pt: Class
mt: class
fn: new
fs: new(args, ...)
fd: Calls allocate to create a new object of class's class, then invokes that object's initialize method, passing it args. This is the method that ends up getting called whenever an object is constructed using .new.
pt: Class
mt: instance
fn: superclass
fs: superclass
fd: Returns the superclass of class, or nil.
pt: Class
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Class
mt: instance
fn: between?
fs: between?(min, max)
fd: Returns false if obj &lt;=&gt; min is less than zero or if anObject &lt;=&gt; max is greater than zero, true otherwise.
pt: Comparable
mt: instance
fn: match
fs: match(key)
fd: Completion for hash key.
pt: CompletingHash
mt: instance
fn: abs
fs: abs()
fd: "Absolute value (aka modulus): distance from the zero point on the complex plane."
pt: Complex
mt: instance
fn: abs2
fs: abs2()
fd: Square of the absolute value.
pt: Complex
mt: instance
fn: angle
fs: angle()
fd: "Alias for #arg"
pt: Complex
mt: instance
fn: arg
fs: arg()
fd: Argument (angle from (1,0) on the complex plane).
pt: Complex
mt: instance
fn: coerce
fs: coerce(other)
fd: Attempts to coerce other to a Complex number.
pt: Complex
mt: instance
fn: conj
fs: conj()
fd: "Alias for #conjugate"
pt: Complex
mt: instance
fn: conjugate
fs: conjugate()
fd: Complex conjugate (z + z.conjugate = 2 * z.real).
pt: Complex
mt: instance
fn: denominator
fs: denominator()
fd: FIXME
pt: Complex
mt: instance
fn: hash
fs: hash()
fd: Returns a hash code for the complex number.
pt: Complex
mt: instance
fn: inspect
fs: inspect()
fd: Returns &quot;Complex(real, image)&quot;.
pt: Complex
mt: instance
fn: new!
fs: new!(a, b=0)
fd: Creates a Complex number a+bi.
pt: Complex
mt: class
fn: new
fs: new(a, b)
fd: 
pt: Complex
mt: class
fn: numerator
fs: numerator()
fd: FIXME
pt: Complex
mt: instance
fn: polar
fs: polar(r, theta)
fd: Creates a Complex number in terms of r (radius) and theta (angle).
pt: Complex
mt: class
fn: polar
fs: polar()
fd: Returns the absolute value and the argument.
pt: Complex
mt: instance
fn: to_s
fs: to_s()
fd: Standard string representation of the complex number.
pt: Complex
mt: instance
fn: broadcast
fs: broadcast()
fd: Wakes up all threads waiting for this lock.
pt: ConditionVariable
mt: instance
fn: new
fs: new()
fd: Creates a new ConditionVariable
pt: ConditionVariable
mt: class
fn: signal
fs: signal()
fd: Wakes up the first thread in line waiting for this lock.
pt: ConditionVariable
mt: instance
fn: wait
fs: wait(mutex)
fd: Releases the lock held in mutex and waits; reacquires the lock on wakeup.
pt: ConditionVariable
mt: instance
fn: call
fs: call(args, ...)
fd: Invokes the continuation. The program continues from the end of the callcc block. If no arguments are given, the original callcc returns nil. If one argument is given, callcc returns it. Otherwise, an array containing args is returned.
pt: Continuation
mt: instance
fn: new
fs: new
fd: 
pt: Continuation
mt: class
fn: close_on_terminate
fs: close_on_terminate()
fd: Tell this writer to close the IO when terminated (Triggered by invoking CSV::BasicWriter#close).
pt: CSV::BasicWriter
mt: instance
fn: new
fs: new(str_or_writable, fs = ',', rs = nil)
fd: 
pt: CSV::BasicWriter
mt: class
fn: data
fs: data()
fd: 
pt: CSV::Cell
mt: instance
fn: new
fs: new(data = "", is_null = false)
fd: 
pt: CSV::Cell
mt: class
fn: foreach
fs: foreach(path, rs = nil, &block)
fd: 
pt: CSV
mt: class
fn: generate
fs: generate(path, fs = nil, rs = nil, &block)
fd: 
pt: CSV
mt: class
fn: generate_line
fs: generate_line(row, fs = nil, rs = nil)
fd: Create a line from cells. each cell is stringified by to_s.
pt: CSV
mt: class
fn: generate_row
fs: generate_row(src, cells, out_dev, fs = nil, rs = nil)
fd: Convert a line from cells data to string. Consider using CSV.generate_line instead. To generate multi-row CSV string, see EXAMPLE below.
pt: CSV
mt: class
fn: close
fs: close()
fd: 
pt: CSV::IOBuf
mt: instance
fn: new
fs: new(s)
fd: 
pt: CSV::IOBuf
mt: class
fn: close_on_terminate
fs: close_on_terminate()
fd: Tell this reader to close the IO when terminated (Triggered by invoking CSV::IOReader#close).
pt: CSV::IOReader
mt: instance
fn: new
fs: new(io, fs = ',', rs = nil)
fd: 
pt: CSV::IOReader
mt: class
fn: open
fs: open(path, mode, fs = nil, rs = nil, &block)
fd: Open a CSV formatted file for reading or writing.
pt: CSV
mt: class
fn: parse
fs: parse(str_or_readable, fs = nil, rs = nil, &block)
fd: Parse lines from given string or stream. Return rows as an Array of Arrays.
pt: CSV
mt: class
fn: parse_line
fs: parse_line(src, fs = nil, rs = nil)
fd: Parse a line from given string. Bear in mind it parses ONE LINE. Rest of the string is ignored for example &quot;a,b\r\nc,d&quot; =&gt; ['a', 'b'] and the second line 'c,d' is ignored.
pt: CSV
mt: class
fn: parse_row
fs: parse_row(src, idx, out_dev, fs = nil, rs = nil)
fd: Parse a line from string. Consider using CSV.parse_line instead. To parse lines in CSV string, see EXAMPLE below.
pt: CSV
mt: class
fn: read
fs: read(path, length = nil, offset = nil)
fd: 
pt: CSV
mt: class
fn: close
fs: close()
fd: 
pt: CSV::Reader
mt: instance
fn: create
fs: create(str_or_readable, fs = ',', rs = nil)
fd: Returns reader instance.
pt: CSV::Reader
mt: class
fn: each
fs: each()
fd: 
pt: CSV::Reader
mt: instance
fn: new
fs: new(dev)
fd: 
pt: CSV::Reader
mt: class
fn: parse
fs: parse(str_or_readable, fs = ',', rs = nil, &block)
fd: Parse CSV data and get lines. Given block is called for each parsed row. Block value is always nil. Rows are not cached for performance reason.
pt: CSV::Reader
mt: class
fn: shift
fs: shift()
fd: 
pt: CSV::Reader
mt: instance
fn: readlines
fs: readlines(path, rs = nil)
fd: 
pt: CSV
mt: class
fn: drop
fs: drop(n)
fd: drop a string from the stream. returns dropped size. at EOF, dropped size might not equals to arg n. Once you drop the head of the stream, access to the dropped part via [] or get returns nil.
pt: CSV::StreamBuf
mt: instance
fn: get
fs: get(idx, n = nil)
fd: "Alias for #[]"
pt: CSV::StreamBuf
mt: instance
fn: is_eos?
fs: is_eos?()
fd: 
pt: CSV::StreamBuf
mt: instance
fn: new
fs: new()
fd: "WARN: Do not instantiate this class directly. Define your own class which derives this class and define 'read' instance method."
pt: CSV::StreamBuf
mt: class
fn: new
fs: new(string, fs = ',', rs = nil)
fd: 
pt: CSV::StringReader
mt: class
fn: add_row
fs: add_row(row)
fd: "Alias for #&lt;&lt;"
pt: CSV::Writer
mt: instance
fn: close
fs: close()
fd: 
pt: CSV::Writer
mt: instance
fn: create
fs: create(str_or_writable, fs = ',', rs = nil)
fd: str_or_writable must handle '&lt;&lt;(string)'.
pt: CSV::Writer
mt: class
fn: generate
fs: generate(str_or_writable, fs = ',', rs = nil, &block)
fd: Given block is called with the writer instance. str_or_writable must handle '&lt;&lt;(string)'.
pt: CSV::Writer
mt: class
fn: new
fs: new(dev)
fd: 
pt: CSV::Writer
mt: class
fn: ajd
fs: ajd()
fd: Get the date as an Astronomical Julian Day Number.
pt: Date
mt: instance
fn: ajd_to_amjd
fs: ajd_to_amjd(ajd)
fd: Convert an Astronomical Julian Day Number to an Astronomical Modified Julian Day Number.
pt: Date
mt: class
fn: ajd_to_jd
fs: ajd_to_jd(ajd, of=0)
fd: Convert an Astronomical Julian Day Number to a (civil) Julian Day Number.
pt: Date
mt: class
fn: amjd
fs: amjd()
fd: Get the date as an Astronomical Modified Julian Day Number.
pt: Date
mt: instance
fn: amjd_to_ajd
fs: amjd_to_ajd(amjd)
fd: Convert an Astronomical Modified Julian Day Number to an Astronomical Julian Day Number.
pt: Date
mt: class
fn: asctime
fs: asctime()
fd: alias_method :format, :strftime
pt: Date
mt: instance
fn: civil
fs: civil(y=-4712, m=1, d=1, sg=ITALY)
fd: Create a new Date object for the Civil Date specified by year y, month m, and day-of-month d.
pt: Date
mt: class
fn: civil_to_jd
fs: civil_to_jd(y, m, d, sg=GREGORIAN)
fd: Convert a Civil Date to a Julian Day Number. y, m, and d are the year, month, and day of the month. sg specifies the Day of Calendar Reform.
pt: Date
mt: class
fn: commercial
fs: commercial(y=1582, w=41, d=5, sg=ITALY)
fd: Create a new Date object for the Commercial Date specified by year y, week-of-year w, and day-of-week d.
pt: Date
mt: class
fn: commercial_to_jd
fs: commercial_to_jd(y, w, d, ns=GREGORIAN)
fd: Convert a Commercial Date to a Julian Day Number.
pt: Date
mt: class
fn: ctime
fs: ctime()
fd: "Alias for #asctime"
pt: Date
mt: instance
fn: cwday
fs: cwday()
fd: Get the commercial day of the week of this date. Monday is commercial day-of-week 1; Sunday is commercial day-of-week 7.
pt: Date
mt: instance
fn: cweek
fs: cweek()
fd: Get the commercial week of the year of this date.
pt: Date
mt: instance
fn: cwyear
fs: cwyear()
fd: Get the commercial year of this date. See <b>Commercial</b> <b>Date</b> in the introduction for how this differs from the normal year.
pt: Date
mt: instance
fn: day
fs: day()
fd: "Alias for #mday"
pt: Date
mt: instance
fn: day_fraction
fs: day_fraction()
fd: Get any fractional day part of the date.
pt: Date
mt: instance
fn: day_fraction_to_time
fs: day_fraction_to_time(fr)
fd: Convert a fractional day fr to [hours, minutes, seconds, fraction_of_a_second]
pt: Date
mt: class
fn: downto
fs: downto(min)
fd: Step backward one day at a time until we reach min (inclusive), yielding each date as we go.
pt: Date
mt: instance
fn: england
fs: england()
fd: Create a copy of this Date object that uses the English/Colonial Day of Calendar Reform.
pt: Date
mt: instance
fn: eql?
fs: eql?(other)
fd: Is this Date equal to other?
pt: Date
mt: instance
fn: gregorian?
fs: gregorian?(jd, sg)
fd: Does a given Julian Day Number fall inside the new-style (Gregorian) calendar?
pt: Date
mt: class
fn: gregorian?
fs: gregorian?()
fd: Is the current date new-style (Gregorian Calendar)?
pt: Date
mt: instance
fn: gregorian
fs: gregorian()
fd: Create a copy of this Date object that always uses the Gregorian Calendar.
pt: Date
mt: instance
fn: gregorian_leap?
fs: gregorian_leap?(y)
fd: Is a year a leap year in the Gregorian calendar?
pt: Date
mt: class
fn: hash
fs: hash()
fd: Calculate a hash value for this date.
pt: Date
mt: instance
fn: inspect
fs: inspect()
fd: Return internal object state as a programmer-readable string.
pt: Date
mt: instance
fn: italy
fs: italy()
fd: Create a copy of this Date object that uses the Italian/Catholic Day of Calendar Reform.
pt: Date
mt: instance
fn: jd
fs: jd(jd=0, sg=ITALY)
fd: Create a new Date object from a Julian Day Number.
pt: Date
mt: class
fn: jd
fs: jd()
fd: Get the date as a Julian Day Number.
pt: Date
mt: instance
fn: jd_to_ajd
fs: jd_to_ajd(jd, fr, of=0)
fd: Convert a (civil) Julian Day Number to an Astronomical Julian Day Number.
pt: Date
mt: class
fn: jd_to_civil
fs: jd_to_civil(jd, sg=GREGORIAN)
fd: Convert a Julian Day Number to a Civil Date. jd is the Julian Day Number. sg specifies the Day of Calendar Reform.
pt: Date
mt: class
fn: jd_to_commercial
fs: jd_to_commercial(jd, sg=GREGORIAN)
fd: Convert a Julian Day Number to a Commercial Date
pt: Date
mt: class
fn: jd_to_ld
fs: jd_to_ld(jd)
fd: Convert a Julian Day Number to the number of days since the adoption of the Gregorian Calendar (in Italy).
pt: Date
mt: class
fn: jd_to_mjd
fs: jd_to_mjd(jd)
fd: Convert a Julian Day Number to a Modified Julian Day Number.
pt: Date
mt: class
fn: jd_to_ordinal
fs: jd_to_ordinal(jd, sg=GREGORIAN)
fd: Convert a Julian Day Number to an Ordinal Date.
pt: Date
mt: class
fn: jd_to_wday
fs: jd_to_wday(jd)
fd: Convert a Julian Day Number to the day of the week.
pt: Date
mt: class
fn: julian?
fs: julian?(jd, sg)
fd: Does a given Julian Day Number fall inside the old-style (Julian) calendar?
pt: Date
mt: class
fn: julian?
fs: julian?()
fd: Is the current date old-style (Julian Calendar)?
pt: Date
mt: instance
fn: julian
fs: julian()
fd: Create a copy of this Date object that always uses the Julian Calendar.
pt: Date
mt: instance
fn: julian_leap?
fs: julian_leap?(y)
fd: Is a year a leap year in the Julian calendar?
pt: Date
mt: class
fn: ld
fs: ld()
fd: Get the date as the number of days since the Day of Calendar Reform (in Italy and the Catholic countries).
pt: Date
mt: instance
fn: ld_to_jd
fs: ld_to_jd(ld)
fd: Convert a count of the number of days since the adoption of the Gregorian Calendar (in Italy) to a Julian Day Number.
pt: Date
mt: class
fn: leap?
fs: leap?()
fd: Is this a leap year?
pt: Date
mt: instance
fn: mday
fs: mday()
fd: Get the day-of-the-month of this date.
pt: Date
mt: instance
fn: mjd
fs: mjd()
fd: Get the date as a Modified Julian Day Number.
pt: Date
mt: instance
fn: mjd_to_jd
fs: mjd_to_jd(mjd)
fd: Convert a Modified Julian Day Number to a Julian Day Number.
pt: Date
mt: class
fn: mon
fs: mon()
fd: Get the month of this date.
pt: Date
mt: instance
fn: month
fs: month()
fd: "Alias for #mon"
pt: Date
mt: instance
fn: new
fs: new(ajd=0, of=0, sg=ITALY)
fd: "<b>NOTE</b> this is the documentation for the method new!(). If you are reading this as the documentation for new(), that is because rdoc doesn't fully support the aliasing of the initialize() method. new() is in fact an alias for #civil(): read the documentation for that method instead."
pt: Date
mt: class
fn: new_start
fs: new_start(sg=self.class::ITALY)
fd: Create a copy of this Date object using a new Day of Calendar Reform.
pt: Date
mt: instance
fn: next
fs: next()
fd: Return a new Date one day after this one.
pt: Date
mt: instance
fn: ordinal
fs: ordinal(y=-4712, d=1, sg=ITALY)
fd: Create a new Date object from an Ordinal Date, specified by year y and day-of-year d. d can be negative, in which it counts backwards from the end of the year. No year wraparound is performed, however. An invalid value for d results in an ArgumentError being raised.
pt: Date
mt: class
fn: ordinal_to_jd
fs: ordinal_to_jd(y, d, sg=GREGORIAN)
fd: Convert an Ordinal Date to a Julian Day Number.
pt: Date
mt: class
fn: parse
fs: parse(str='-4712-01-01', comp=false, sg=ITALY)
fd: Create a new Date object by parsing from a String, without specifying the format.
pt: Date
mt: class
fn: start
fs: start()
fd: When is the Day of Calendar Reform for this Date object?
pt: Date
mt: instance
fn: step
fs: step(limit, step=1)
fd: Step the current date forward step days at a time (or backward, if step is negative) until we reach limit (inclusive), yielding the resultant date at each step.
pt: Date
mt: instance
fn: strftime
fs: strftime(fmt='%F')
fd: 
pt: Date
mt: instance
fn: strptime
fs: strptime(str='-4712-01-01', fmt='%F', sg=ITALY)
fd: Create a new Date object by parsing from a String according to a specified format.
pt: Date
mt: class
fn: succ
fs: succ()
fd: "Alias for #next"
pt: Date
mt: instance
fn: time_to_day_fraction
fs: time_to_day_fraction(h, min, s)
fd: Convert an h hour, min minutes, s seconds period to a fractional day.
pt: Date
mt: class
fn: to_s
fs: to_s()
fd: Return the date as a human-readable string.
pt: Date
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Date
mt: instance
fn: today
fs: today(sg=ITALY)
fd: Create a new Date object representing today.
pt: Date
mt: class
fn: upto
fs: upto(max)
fd: Step forward one day at a time until we reach max (inclusive), yielding each date as we go.
pt: Date
mt: instance
fn: valid_civil?
fs: valid_civil?(y, m, d, sg=ITALY)
fd: Do year y, month m, and day-of-month d make a valid Civil Date? Returns the corresponding Julian Day Number if they do, nil if they don't.
pt: Date
mt: class
fn: valid_commercial?
fs: valid_commercial?(y, w, d, sg=ITALY)
fd: Do year y, week-of-year w, and day-of-week d make a valid Commercial Date? Returns the corresponding Julian Day Number if they do, nil if they don't.
pt: Date
mt: class
fn: valid_jd?
fs: valid_jd?(jd, sg=ITALY)
fd: Is jd a valid Julian Day Number?
pt: Date
mt: class
fn: valid_ordinal?
fs: valid_ordinal?(y, d, sg=ITALY)
fd: Do the year y and day-of-year d make a valid Ordinal Date? Returns the corresponding Julian Day Number if they do, or nil if they don't.
pt: Date
mt: class
fn: valid_time?
fs: valid_time?(h, min, s)
fd: Do hour h, minute min, and second s constitute a valid time?
pt: Date
mt: class
fn: wday
fs: wday()
fd: Get the week day of this date. Sunday is day-of-week 0; Saturday is day-of-week 6.
pt: Date
mt: instance
fn: yday
fs: yday()
fd: Get the day-of-the-year of this date.
pt: Date
mt: instance
fn: year
fs: year()
fd: Get the year of this date.
pt: Date
mt: instance
fn: civil
fs: civil(y=-4712, m=1, d=1, h=0, min=0, s=0, of=0, sg=ITALY)
fd: Create a new DateTime object corresponding to the specified Civil Date and hour h, minute min, second s.
pt: DateTime
mt: class
fn: commercial
fs: commercial(y=1582, w=41, d=5, h=0, min=0, s=0, of=0, sg=ITALY)
fd: Create a new DateTime object corresponding to the specified Commercial Date and hour h, minute min, second s.
pt: DateTime
mt: class
fn: jd
fs: jd(jd=0, h=0, min=0, s=0, of=0, sg=ITALY)
fd: Create a new DateTime object corresponding to the specified Julian Day Number jd and hour h, minute min, second s.
pt: DateTime
mt: class
fn: new
fs: new
fd: 
pt: DateTime
mt: class
fn: ordinal
fs: ordinal(y=-4712, d=1, h=0, min=0, s=0, of=0, sg=ITALY)
fd: Create a new DateTime object corresponding to the specified Ordinal Date and hour h, minute min, second s.
pt: DateTime
mt: class
fn: parse
fs: parse(str='-4712-01-01T00:00:00+00:00', comp=false, sg=ITALY)
fd: Create a new DateTime object by parsing from a String, without specifying the format.
pt: DateTime
mt: class
fn: strftime
fs: strftime(fmt='%FT%T%:z')
fd: 
pt: DateTime
mt: instance
fn: strptime
fs: strptime(str='-4712-01-01T00:00:00+00:00', fmt='%FT%T%z', sg=ITALY)
fd: Create a new DateTime object by parsing from a String according to a specified format.
pt: DateTime
mt: class
fn: break_points
fs: break_points()
fd: 
pt: DEBUGGER__
mt: class
fn: break_points
fs: break_points()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: check_break_points
fs: check_break_points(file, klass, pos, binding, id)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: check_suspend
fs: check_suspend()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: clear_suspend
fs: clear_suspend()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: context
fs: context(th)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: debug_command
fs: debug_command(file, line, id, binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: debug_eval
fs: debug_eval(str, binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: debug_funcname
fs: debug_funcname(id)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: debug_method_info
fs: debug_method_info(input, binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: debug_print_help
fs: debug_print_help()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: debug_silent_eval
fs: debug_silent_eval(str, binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: debug_variable_info
fs: debug_variable_info(input, binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: display
fs: display()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: display_expression
fs: display_expression(exp, binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: display_expressions
fs: display_expressions(binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: display_frames
fs: display_frames(pos)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: display_list
fs: display_list(b, e, file, line)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: excn_handle
fs: excn_handle(file, line, id, binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: format_frame
fs: format_frame(pos)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: frame_set_pos
fs: frame_set_pos(file, line)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: line_at
fs: line_at(file, line)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: new
fs: new()
fd: 
pt: DEBUGGER__::Context
mt: class
fn: readline
fs: readline(prompt, hist)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: resume_all
fs: resume_all()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: set_last_thread
fs: set_last_thread(th)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: set_suspend
fs: set_suspend()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: set_trace
fs: set_trace(arg)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: set_trace_all
fs: set_trace_all(arg)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: stdout
fs: stdout()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: stop_next
fs: stop_next(n=1)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: suspend_all
fs: suspend_all()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: thnum
fs: thnum()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: trace?
fs: trace?()
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: trace_func
fs: trace_func(event, file, line, id, binding, klass)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: var_list
fs: var_list(ary, binding)
fd: 
pt: DEBUGGER__::Context
mt: instance
fn: context
fs: context(thread=Thread.current)
fd: 
pt: DEBUGGER__
mt: class
fn: debug_thread_info
fs: debug_thread_info(input, binding)
fd: 
pt: DEBUGGER__
mt: class
fn: display
fs: display()
fd: 
pt: DEBUGGER__
mt: class
fn: get_thread
fs: get_thread(num)
fd: 
pt: DEBUGGER__
mt: class
fn: interrupt
fs: interrupt()
fd: 
pt: DEBUGGER__
mt: class
fn: make_thread_list
fs: make_thread_list()
fd: 
pt: DEBUGGER__
mt: class
fn: lock
fs: lock()
fd: 
pt: DEBUGGER__::Mutex
mt: instance
fn: locked?
fs: locked?()
fd: 
pt: DEBUGGER__::Mutex
mt: instance
fn: new
fs: new()
fd: 
pt: DEBUGGER__::Mutex
mt: class
fn: unlock
fs: unlock()
fd: 
pt: DEBUGGER__::Mutex
mt: instance
fn: resume
fs: resume()
fd: 
pt: DEBUGGER__
mt: class
fn: set_last_thread
fs: set_last_thread(th)
fd: 
pt: DEBUGGER__
mt: class
fn: set_trace
fs: set_trace( arg )
fd: 
pt: DEBUGGER__
mt: class
fn: stdout=
fs: stdout=(s)
fd: 
pt: DEBUGGER__
mt: class
fn: stdout
fs: stdout()
fd: 
pt: DEBUGGER__
mt: class
fn: suspend
fs: suspend()
fd: 
pt: DEBUGGER__
mt: class
fn: thread_list
fs: thread_list(num)
fd: 
pt: DEBUGGER__
mt: class
fn: thread_list_all
fs: thread_list_all()
fd: 
pt: DEBUGGER__
mt: class
fn: waiting
fs: waiting()
fd: 
pt: DEBUGGER__
mt: class
fn: display_class_info
fs: display_class_info(klass, ri_reader)
fd: 
pt: DefaultDisplay
mt: instance
fn: display_class_list
fs: display_class_list(namespaces)
fd: 
pt: DefaultDisplay
mt: instance
fn: display_method_info
fs: display_method_info(method)
fd: 
pt: DefaultDisplay
mt: instance
fn: display_method_list
fs: display_method_list(methods)
fd: Display a list of method names
pt: DefaultDisplay
mt: instance
fn: display_usage
fs: display_usage()
fd: 
pt: DefaultDisplay
mt: instance
fn: list_known_classes
fs: list_known_classes(classes)
fd: 
pt: DefaultDisplay
mt: instance
fn: list_known_names
fs: list_known_names(names)
fd: 
pt: DefaultDisplay
mt: instance
fn: new
fs: new(options)
fd: 
pt: DefaultDisplay
mt: class
fn: marshal_dump
fs: marshal_dump()
fd: Serialization support for the object returned by __getobj__.
pt: Delegator
mt: instance
fn: marshal_load
fs: marshal_load(obj)
fd: Reinitializes delegation from a serialized object.
pt: Delegator
mt: instance
fn: method_missing
fs: method_missing(m, *args)
fd: Handles the magic of delegation through __getobj__.
pt: Delegator
mt: instance
fn: new
fs: new(obj)
fd: Pass in the obj to delegate method calls to. All methods supported by obj will be delegated to.
pt: Delegator
mt: class
fn: respond_to?
fs: respond_to?(m)
fd: Checks for a method provided by this the delegate object by fowarding the call through __getobj__.
pt: Delegator
mt: instance
fn: chdir
fs: chdir( [ string] )
fd: Changes the current working directory of the process to the given string. When called without an argument, changes the directory to the value of the environment variable HOME, or LOGDIR. SystemCallError (probably Errno::ENOENT) if the target directory does not exist.
pt: Dir
mt: class
fn: chroot
fs: chroot( string )
fd: Changes this process's idea of the file system root. Only a privileged process may make this call. Not available on all platforms. On Unix systems, see chroot(2) for more information.
pt: Dir
mt: class
fn: close
fs: close
fd: Closes the directory stream. Any further attempts to access dir will raise an IOError.
pt: Dir
mt: instance
fn: delete
fs: delete( string )
fd: Deletes the named directory. Raises a subclass of SystemCallError if the directory isn't empty.
pt: Dir
mt: class
fn: each
fs: each
fd: Calls the block once for each entry in this directory, passing the filename of each entry as a parameter to the block.
pt: Dir
mt: instance
fn: entries
fs: entries( dirname )
fd: Returns an array containing all of the filenames in the given directory. Will raise a SystemCallError if the named directory doesn't exist.
pt: Dir
mt: class
fn: foreach
fs: foreach( dirname )
fd: Calls the block once for each entry in the named directory, passing the filename of each entry as a parameter to the block.
pt: Dir
mt: class
fn: getwd
fs: getwd
fd: Returns the path to the current working directory of this process as a string.
pt: Dir
mt: class
fn: glob
fs: glob( pattern, [flags] )
fd: Returns the filenames found by expanding pattern which is an Array of the patterns or the pattern String, either as an array or as parameters to the block. Note that this pattern is not a regexp (it's closer to a shell glob). See File::fnmatch for the meaning of the flags parameter. Note that case sensitivity depends on your system (so File::FNM_CASEFOLD is ignored)
pt: Dir
mt: class
fn: mkdir
fs: mkdir( string [, integer] )
fd: Makes a new directory named by string, with permissions specified by the optional parameter anInteger. The permissions may be modified by the value of File::umask, and are ignored on NT. Raises a SystemCallError if the directory cannot be created. See also the discussion of permissions in the class documentation for File.
pt: Dir
mt: class
fn: new
fs: new( string )
fd: Returns a new directory object for the named directory.
pt: Dir
mt: class
fn: open
fs: open( string )
fd: With no block, open is a synonym for Dir::new. If a block is present, it is passed aDir as a parameter. The directory is closed at the end of the block, and Dir::open returns the value of the block.
pt: Dir
mt: class
fn: path
fs: path
fd: Returns the path parameter passed to dir's constructor.
pt: Dir
mt: instance
fn: pos=
fs: pos=  dir.pos( integer )
fd: Synonym for Dir#seek, but returns the position parameter.
pt: Dir
mt: instance
fn: pos
fs: pos
fd: Returns the current position in dir. See also Dir#seek.
pt: Dir
mt: instance
fn: pwd
fs: pwd
fd: Returns the path to the current working directory of this process as a string.
pt: Dir
mt: class
fn: read
fs: read
fd: Reads the next entry from dir and returns it as a string. Returns nil at the end of the stream.
pt: Dir
mt: instance
fn: rewind
fs: rewind
fd: Repositions dir to the first entry.
pt: Dir
mt: instance
fn: rmdir
fs: rmdir( string )
fd: Deletes the named directory. Raises a subclass of SystemCallError if the directory isn't empty.
pt: Dir
mt: class
fn: seek
fs: seek( integer )
fd: Seeks to a particular location in dir. integer must be a value returned by Dir#tell.
pt: Dir
mt: instance
fn: tell
fs: tell
fd: Returns the current position in dir. See also Dir#seek.
pt: Dir
mt: instance
fn: tmpdir
fs: tmpdir()
fd: Returns the operating system's temporary file path.
pt: Dir
mt: class
fn: unlink
fs: unlink( string )
fd: Deletes the named directory. Raises a subclass of SystemCallError if the directory isn't empty.
pt: Dir
mt: class
fn: change_tab
fs: change_tab( t )
fd: if we don't like 4 spaces, we can change it any time
pt: DOT
mt: instance
fn: new
fs: new( params = {}, option_list = GRAPH_OPTS )
fd: 
pt: DOT::DOTDigraph
mt: class
fn: new
fs: new( params = {}, option_list = EDGE_OPTS )
fd: 
pt: DOT::DOTEdge
mt: class
fn: to_s
fs: to_s( t = '' )
fd: 
pt: DOT::DOTEdge
mt: instance
fn: each_option
fs: each_option()
fd: 
pt: DOT::DOTElement
mt: instance
fn: each_option_pair
fs: each_option_pair()
fd: 
pt: DOT::DOTElement
mt: instance
fn: new
fs: new( params = {}, option_list = [] )
fd: 
pt: DOT::DOTElement
mt: class
fn: each_port
fs: each_port()
fd: 
pt: DOT::DOTNode
mt: instance
fn: new
fs: new( params = {}, option_list = NODE_OPTS )
fd: 
pt: DOT::DOTNode
mt: class
fn: pop
fs: pop()
fd: 
pt: DOT::DOTNode
mt: instance
fn: push
fs: push( thing )
fd: 
pt: DOT::DOTNode
mt: instance
fn: to_s
fs: to_s( t = '' )
fd: 
pt: DOT::DOTNode
mt: instance
fn: new
fs: new( params = {} )
fd: 
pt: DOT::DOTPort
mt: class
fn: to_s
fs: to_s()
fd: 
pt: DOT::DOTPort
mt: instance
fn: new
fs: new( params = {} )
fd: 
pt: DOT::DOTSimpleElement
mt: class
fn: to_s
fs: to_s()
fd: 
pt: DOT::DOTSimpleElement
mt: instance
fn: each_node
fs: each_node()
fd: 
pt: DOT::DOTSubgraph
mt: instance
fn: new
fs: new( params = {}, option_list = GRAPH_OPTS )
fd: 
pt: DOT::DOTSubgraph
mt: class
fn: pop
fs: pop()
fd: 
pt: DOT::DOTSubgraph
mt: instance
fn: push
fs: push( thing )
fd: 
pt: DOT::DOTSubgraph
mt: instance
fn: to_s
fs: to_s( t = '' )
fd: 
pt: DOT::DOTSubgraph
mt: instance
fn: config
fs: config()
fd: Get the configuration of the current server.
pt: DRb
mt: instance
fn: current_server
fs: current_server()
fd: Get the 'current' server.
pt: DRb
mt: instance
fn: new
fs: new(ary)
fd: 
pt: DRb::DRbArray
mt: class
fn: to_id
fs: to_id(obj)
fd: Convert an object into a reference id.
pt: DRb::DRbIdConv
mt: instance
fn: to_obj
fs: to_obj(ref)
fd: Convert an object reference id to an object.
pt: DRb::DRbIdConv
mt: instance
fn: eql?
fs: eql?(other)
fd: "Alias for #=="
pt: DRb::DRbObject
mt: instance
fn: hash
fs: hash()
fd: 
pt: DRb::DRbObject
mt: instance
fn: method_missing
fs: method_missing(msg_id, *a, &b)
fd: Routes method calls to the referenced object.
pt: DRb::DRbObject
mt: instance
fn: new
fs: new(obj, uri=nil)
fd: Create a new remote object stub.
pt: DRb::DRbObject
mt: class
fn: new_with
fs: new_with(uri, ref)
fd: 
pt: DRb::DRbObject
mt: class
fn: new_with_uri
fs: new_with_uri(uri)
fd: Create a new DRbObject from a URI alone.
pt: DRb::DRbObject
mt: class
fn: prepare_backtrace
fs: prepare_backtrace(uri, result)
fd: 
pt: DRb::DRbObject
mt: class
fn: respond_to?
fs: respond_to?(msg_id, priv=false)
fd: 
pt: DRb::DRbObject
mt: instance
fn: with_friend
fs: with_friend(uri)
fd: 
pt: DRb::DRbObject
mt: class
fn: notify_observers
fs: notify_observers(*arg)
fd: 
pt: DRb::DRbObservable
mt: instance
fn: add_protocol
fs: add_protocol(prot)
fd: Add a new protocol to the DRbProtocol module.
pt: DRb::DRbProtocol
mt: instance
fn: open
fs: open(uri, config, first=true)
fd: Open a client connection to uri with the configuration config.
pt: DRb::DRbProtocol
mt: instance
fn: open_server
fs: open_server(uri, config, first=true)
fd: Open a server listening for connections at uri with configuration config.
pt: DRb::DRbProtocol
mt: instance
fn: uri_option
fs: uri_option(uri, config, first=true)
fd: Parse uri into a [uri, option] pair.
pt: DRb::DRbProtocol
mt: instance
fn: new
fs: new(error)
fd: 
pt: DRb::DRbRemoteError
mt: class
fn: alive?
fs: alive?()
fd: Is this server alive?
pt: DRb::DRbServer
mt: instance
fn: check_insecure_method
fs: check_insecure_method(obj, msg_id)
fd: Check that a method is callable via dRuby.
pt: DRb::DRbServer
mt: instance
fn: default_acl
fs: default_acl(acl)
fd: Set the default value for the :acl option.
pt: DRb::DRbServer
mt: class
fn: default_argc_limit
fs: default_argc_limit(argc)
fd: Set the default value for the :argc_limit option.
pt: DRb::DRbServer
mt: class
fn: default_id_conv
fs: default_id_conv(idconv)
fd: Set the default value for the :id_conv option.
pt: DRb::DRbServer
mt: class
fn: default_load_limit
fs: default_load_limit(sz)
fd: Set the default value for the :load_limit option.
pt: DRb::DRbServer
mt: class
fn: default_safe_level
fs: default_safe_level(level)
fd: 
pt: DRb::DRbServer
mt: class
fn: block_yield
fs: block_yield(x)
fd: 
pt: DRb::DRbServer::InvokeMethod18Mixin
mt: instance
fn: perform_with_block
fs: perform_with_block()
fd: 
pt: DRb::DRbServer::InvokeMethod18Mixin
mt: instance
fn: new
fs: new(uri=nil, front=nil, config_or_acl=nil)
fd: Create a new DRbServer instance.
pt: DRb::DRbServer
mt: class
fn: stop_service
fs: stop_service()
fd: Stop this server.
pt: DRb::DRbServer
mt: instance
fn: to_id
fs: to_id(obj)
fd: Convert a local object to a dRuby reference.
pt: DRb::DRbServer
mt: instance
fn: to_obj
fs: to_obj(ref)
fd: Convert a dRuby reference to the local object it refers to.
pt: DRb::DRbServer
mt: instance
fn: verbose=
fs: verbose=(on)
fd: Set the default value of the :verbose option.
pt: DRb::DRbServer
mt: class
fn: verbose=
fs: verbose=(v)
fd: Set whether to operate in verbose mode.
pt: DRb::DRbServer
mt: instance
fn: verbose
fs: verbose()
fd: Get the default value of the :verbose option.
pt: DRb::DRbServer
mt: class
fn: verbose
fs: verbose()
fd: Get whether the server is in verbose mode.
pt: DRb::DRbServer
mt: instance
fn: accept
fs: accept()
fd: 
pt: DRb::DRbSSLSocket
mt: instance
fn: close
fs: close()
fd: 
pt: DRb::DRbSSLSocket
mt: instance
fn: new
fs: new(uri, soc, config, is_established)
fd: 
pt: DRb::DRbSSLSocket
mt: class
fn: open
fs: open(uri, config)
fd: 
pt: DRb::DRbSSLSocket
mt: class
fn: open_server
fs: open_server(uri, config)
fd: 
pt: DRb::DRbSSLSocket
mt: class
fn: parse_uri
fs: parse_uri(uri)
fd: 
pt: DRb::DRbSSLSocket
mt: class
fn: accept
fs: accept(tcp)
fd: 
pt: DRb::DRbSSLSocket::SSLConfig
mt: instance
fn: connect
fs: connect(tcp)
fd: 
pt: DRb::DRbSSLSocket::SSLConfig
mt: instance
fn: new
fs: new(config)
fd: 
pt: DRb::DRbSSLSocket::SSLConfig
mt: class
fn: setup_certificate
fs: setup_certificate()
fd: 
pt: DRb::DRbSSLSocket::SSLConfig
mt: instance
fn: setup_ssl_context
fs: setup_ssl_context()
fd: 
pt: DRb::DRbSSLSocket::SSLConfig
mt: instance
fn: stream
fs: stream()
fd: 
pt: DRb::DRbSSLSocket
mt: instance
fn: uri_option
fs: uri_option(uri, config)
fd: 
pt: DRb::DRbSSLSocket
mt: class
fn: accept
fs: accept()
fd: "On the server side, for an instance returned by #open_server, accept a client connection and return a new instance to handle the server's side of this client-server session."
pt: DRb::DRbTCPSocket
mt: instance
fn: alive?
fs: alive?()
fd: Check to see if this connection is alive.
pt: DRb::DRbTCPSocket
mt: instance
fn: close
fs: close()
fd: Close the connection.
pt: DRb::DRbTCPSocket
mt: instance
fn: getservername
fs: getservername()
fd: 
pt: DRb::DRbTCPSocket
mt: class
fn: new
fs: new(uri, soc, config={})
fd: Create a new DRbTCPSocket instance.
pt: DRb::DRbTCPSocket
mt: class
fn: open
fs: open(uri, config)
fd: Open a client connection to uri using configuration config.
pt: DRb::DRbTCPSocket
mt: class
fn: open_server
fs: open_server(uri, config)
fd: Open a server listening for connections at uri using configuration config.
pt: DRb::DRbTCPSocket
mt: class
fn: open_server_inaddr_any
fs: open_server_inaddr_any(host, port)
fd: 
pt: DRb::DRbTCPSocket
mt: class
fn: peeraddr
fs: peeraddr()
fd: Get the address of our TCP peer (the other end of the socket we are bound to.
pt: DRb::DRbTCPSocket
mt: instance
fn: recv_reply
fs: recv_reply()
fd: On the client side, receive a reply from the server.
pt: DRb::DRbTCPSocket
mt: instance
fn: recv_request
fs: recv_request()
fd: On the server side, receive a request from the client.
pt: DRb::DRbTCPSocket
mt: instance
fn: send_reply
fs: send_reply(succ, result)
fd: On the server side, send a reply to the client.
pt: DRb::DRbTCPSocket
mt: instance
fn: send_request
fs: send_request(ref, msg_id, arg, b)
fd: On the client side, send a request to the server.
pt: DRb::DRbTCPSocket
mt: instance
fn: stream
fs: stream()
fd: Get the socket.
pt: DRb::DRbTCPSocket
mt: instance
fn: uri_option
fs: uri_option(uri, config)
fd: Parse uri into a [uri, option] pair.
pt: DRb::DRbTCPSocket
mt: class
fn: accept
fs: accept()
fd: 
pt: DRb::DRbUNIXSocket
mt: instance
fn: close
fs: close()
fd: 
pt: DRb::DRbUNIXSocket
mt: instance
fn: new
fs: new(uri, soc, config={}, server_mode = false)
fd: 
pt: DRb::DRbUNIXSocket
mt: class
fn: open
fs: open(uri, config)
fd: 
pt: DRb::DRbUNIXSocket
mt: class
fn: open_server
fs: open_server(uri, config)
fd: 
pt: DRb::DRbUNIXSocket
mt: class
fn: parse_uri
fs: parse_uri(uri)
fd: 
pt: DRb::DRbUNIXSocket
mt: class
fn: set_sockopt
fs: set_sockopt(soc)
fd: 
pt: DRb::DRbUNIXSocket
mt: instance
fn: uri_option
fs: uri_option(uri, config)
fd: 
pt: DRb::DRbUNIXSocket
mt: class
fn: exception
fs: exception()
fd: Create a DRbUnknownError exception containing this object.
pt: DRb::DRbUnknown
mt: instance
fn: new
fs: new(err, buf)
fd: Create a new DRbUnknown object.
pt: DRb::DRbUnknown
mt: class
fn: reload
fs: reload()
fd: Attempt to load the wrapped marshalled object again.
pt: DRb::DRbUnknown
mt: instance
fn: new
fs: new(unknown)
fd: Create a new DRbUnknownError for the DRb::DRbUnknown object unknown
pt: DRb::DRbUnknownError
mt: class
fn: alive?
fs: alive?()
fd: 
pt: DRb::ExtServ
mt: instance
fn: front
fs: front()
fd: 
pt: DRb::ExtServ
mt: instance
fn: new
fs: new(there, name, server=nil)
fd: 
pt: DRb::ExtServ
mt: class
fn: stop_service
fs: stop_service()
fd: 
pt: DRb::ExtServ
mt: instance
fn: command=
fs: command=(cmd)
fd: 
pt: DRb::ExtServManager
mt: class
fn: command
fs: command()
fd: 
pt: DRb::ExtServManager
mt: class
fn: new
fs: new()
fd: 
pt: DRb::ExtServManager
mt: class
fn: regist
fs: regist(name, ro)
fd: 
pt: DRb::ExtServManager
mt: instance
fn: service
fs: service(name)
fd: 
pt: DRb::ExtServManager
mt: instance
fn: unregist
fs: unregist(name)
fd: 
pt: DRb::ExtServManager
mt: instance
fn: fetch_server
fs: fetch_server(uri)
fd: 
pt: DRb
mt: instance
fn: front
fs: front()
fd: Get the front object of the current server.
pt: DRb
mt: instance
fn: new
fs: new()
fd: 
pt: DRb::GW
mt: class
fn: to_obj
fs: to_obj(ref)
fd: 
pt: DRb::GWIdConv
mt: instance
fn: here?
fs: here?(uri)
fd: Is uri the URI for the current local server?
pt: DRb
mt: instance
fn: install_acl
fs: install_acl(acl)
fd: Set the default acl.
pt: DRb
mt: instance
fn: install_id_conv
fs: install_id_conv(idconv)
fd: Set the default id conv object.
pt: DRb
mt: instance
fn: regist_server
fs: regist_server(server)
fd: 
pt: DRb
mt: instance
fn: remove_server
fs: remove_server(server)
fd: 
pt: DRb
mt: instance
fn: start_service
fs: start_service(uri=nil, front=nil, config=nil)
fd: Start a dRuby server locally.
pt: DRb
mt: instance
fn: stop_service
fs: stop_service()
fd: Stop the local dRuby server.
pt: DRb
mt: instance
fn: thread
fs: thread()
fd: Get the thread of the primary server.
pt: DRb
mt: instance
fn: new
fs: new(timeout=600)
fd: 
pt: DRb::TimerIdConv
mt: class
fn: add
fs: add(obj)
fd: 
pt: DRb::TimerIdConv::TimerHolder2
mt: instance
fn: fetch
fs: fetch(key, dv=@sentinel)
fd: 
pt: DRb::TimerIdConv::TimerHolder2
mt: instance
fn: include?
fs: include?(key)
fd: 
pt: DRb::TimerIdConv::TimerHolder2
mt: instance
fn: new
fs: new(timeout=600)
fd: 
pt: DRb::TimerIdConv::TimerHolder2
mt: class
fn: peek
fs: peek(key)
fd: 
pt: DRb::TimerIdConv::TimerHolder2
mt: instance
fn: to_id
fs: to_id(obj)
fd: 
pt: DRb::TimerIdConv
mt: instance
fn: to_obj
fs: to_obj(ref)
fd: 
pt: DRb::TimerIdConv
mt: instance
fn: to_id
fs: to_id(obj)
fd: Get a reference id for an object using the current server.
pt: DRb
mt: instance
fn: to_obj
fs: to_obj(ref)
fd: Convert a reference into an object using the current server.
pt: DRb
mt: instance
fn: uri
fs: uri()
fd: Get the URI defining the local dRuby space.
pt: DRb
mt: instance
fn: all?
fs: all?
fd: Passes each element of the collection to the given block. The method returns true if the block never returns false or nil. If the block is not given, Ruby adds an implicit block of {|obj| obj} (that is all? will return true only if none of the collection members are false or nil.)
pt: Enumerable
mt: instance
fn: any?
fs: any?
fd: Passes each element of the collection to the given block. The method returns true if the block ever returns a value other than false or nil. If the block is not given, Ruby adds an implicit block of {|obj| obj} (that is any? will return true if at least one of the collection members is not false or nil.
pt: Enumerable
mt: instance
fn: collect
fs: collect
fd: Returns a new array with the results of running block once for every element in enum.
pt: Enumerable
mt: instance
fn: detect
fs: detect(ifnone = nil)
fd: Passes each entry in enum to block. Returns the first for which block is not false. If no object matches, calls ifnone and returns its result when it is specified, or returns nil
pt: Enumerable
mt: instance
fn: each_cons
fs: each_cons  each_cons(n)
fd: Iterates the given block for each array of consecutive &lt;n&gt; elements.
pt: Enumerable
mt: instance
fn: each_slice
fs: each_slice(n)
fd: Iterates the given block for each slice of &lt;n&gt; elements.
pt: Enumerable
mt: instance
fn: each_with_index
fs: each_with_index
fd: Calls block with two arguments, the item and its index, for each item in enum.
pt: Enumerable
mt: instance
fn: entries
fs: entries
fd: Returns an array containing the items in enum.
pt: Enumerable
mt: instance
fn: enum_cons
fs: enum_cons(n)
fd: Returns Enumerable::Enumerator.new(self, :each_cons, n).
pt: Enumerable
mt: instance
fn: enum_slice
fs: enum_slice(n)
fd: Returns Enumerable::Enumerator.new(self, :each_slice, n).
pt: Enumerable
mt: instance
fn: enum_with_index
fs: enum_with_index
fd: Returns Enumerable::Enumerator.new(self, :each_with_index).
pt: Enumerable
mt: instance
fn: each
fs: each
fd: Iterates the given block using the object and the method specified in the first place.
pt: Enumerable::Enumerator
mt: instance
fn: new
fs: new(obj, method = :each, *args)
fd: Creates a new Enumerable::Enumerator object, which is to be used as an Enumerable object using the given object's given method with the given arguments.
pt: Enumerable::Enumerator
mt: class
fn: find
fs: find(ifnone = nil)
fd: Passes each entry in enum to block. Returns the first for which block is not false. If no object matches, calls ifnone and returns its result when it is specified, or returns nil
pt: Enumerable
mt: instance
fn: find_all
fs: find_all
fd: Returns an array containing all elements of enum for which block is not false (see also Enumerable#reject).
pt: Enumerable
mt: instance
fn: grep
fs: grep(pattern)
fd: Returns an array of every element in enum for which Pattern === element. If the optional block is supplied, each matching element is passed to it, and the block's result is stored in the output array.
pt: Enumerable
mt: instance
fn: include?
fs: include?(obj)
fd: Returns true if any member of enum equals obj. Equality is tested using ==.
pt: Enumerable
mt: instance
fn: inject
fs: inject(initial)
fd: Combines the elements of enum by applying the block to an accumulator value (memo) and each element in turn. At each step, memo is set to the value returned by the block. The first form lets you supply an initial value for memo. The second form uses the first element of the collection as a the initial value (and skips that element while iterating).
pt: Enumerable
mt: instance
fn: map
fs: map
fd: Returns a new array with the results of running block once for every element in enum.
pt: Enumerable
mt: instance
fn: max
fs: max
fd: Returns the object in enum with the maximum value. The first form assumes all objects implement Comparable; the second uses the block to return a &lt;=&gt; b.
pt: Enumerable
mt: instance
fn: member?
fs: member?(obj)
fd: Returns true if any member of enum equals obj. Equality is tested using ==.
pt: Enumerable
mt: instance
fn: min
fs: min
fd: Returns the object in enum with the minimum value. The first form assumes all objects implement Comparable; the second uses the block to return a &lt;=&gt; b.
pt: Enumerable
mt: instance
fn: partition
fs: partition
fd: Returns two arrays, the first containing the elements of enum for which the block evaluates to true, the second containing the rest.
pt: Enumerable
mt: instance
fn: reject
fs: reject
fd: Returns an array for all elements of enum for which block is false (see also Enumerable#find_all).
pt: Enumerable
mt: instance
fn: select
fs: select
fd: Returns an array containing all elements of enum for which block is not false (see also Enumerable#reject).
pt: Enumerable
mt: instance
fn: sort
fs: sort
fd: Returns an array containing the items in enum sorted, either according to their own &lt;=&gt; method, or by using the results of the supplied block. The block should return -1, 0, or +1 depending on the comparison between a and b. As of Ruby 1.8, the method Enumerable#sort_by implements a built-in Schwartzian Transform, useful when key computation or comparison is expensive..
pt: Enumerable
mt: instance
fn: sort_by
fs: sort_by
fd: Sorts enum using a set of keys generated by mapping the values in enum through the given block.
pt: Enumerable
mt: instance
fn: to_a
fs: to_a
fd: Returns an array containing the items in enum.
pt: Enumerable
mt: instance
fn: to_set
fs: to_set(klass = Set, *args, &block)
fd: Makes a set from the enumerable object with given arguments. Needs to +require &quot;set&quot;+ to use this method.
pt: Enumerable
mt: instance
fn: zip
fs: zip(arg, ...)
fd: Converts any arguments to arrays, then merges elements of enum with corresponding elements from each argument. This generates a sequence of enum#size n-element arrays, where n is one more that the count of arguments. If the size of any argument is less than enum#size, nil values are supplied. If a block given, it is invoked for each output array, otherwise an array of arrays is returned.
pt: Enumerable
mt: instance
fn: new
fs: new(str, safe_level=nil, trim_mode=nil, eoutvar='_erbout')
fd: Constructs a new ERB object with the template specified in str.
pt: ERB
mt: class
fn: result
fs: result(b=TOPLEVEL_BINDING)
fd: Executes the generated ERB code to produce a completed template, returning the results of that code. (See ERB#new for details on how this process can be affected by safe_level.)
pt: ERB
mt: instance
fn: run
fs: run(b=TOPLEVEL_BINDING)
fd: Generate results and print them. (see ERB#result)
pt: ERB
mt: instance
fn: set_eoutvar
fs: set_eoutvar(compiler, eoutvar = '_erbout')
fd: Can be used to set eoutvar as described in ERB#new. It's probably easier to just use the constructor though, since calling this method requires the setup of an ERB compiler object.
pt: ERB
mt: instance
fn: h
fs: h(s)
fd: "Alias for #html_escape"
pt: ERB::Util
mt: instance
fn: html_escape
fs: html_escape(s)
fd: A utility method for escaping HTML tag characters in s.
pt: ERB::Util
mt: instance
fn: u
fs: u(s)
fd: "Alias for #url_encode"
pt: ERB::Util
mt: instance
fn: url_encode
fs: url_encode(s)
fd: A utility method for encoding the String s as a URL.
pt: ERB::Util
mt: instance
fn: version
fs: version()
fd: Returns revision information for the erb.rb module.
pt: ERB
mt: class
fn: backtrace
fs: backtrace
fd: "Returns any backtrace associated with the exception. The backtrace is an array of strings, each containing either ``filename:lineNo: in `method''' or ``filename:lineNo.''"
pt: Exception
mt: instance
fn: exception
fs: exception(string)
fd: With no argument, or if the argument is the same as the receiver, return the receiver. Otherwise, create a new exception object of the same class as the receiver, but with a message equal to string.to_str.
pt: Exception
mt: class
fn: exception
fs: exception(string)
fd: With no argument, or if the argument is the same as the receiver, return the receiver. Otherwise, create a new exception object of the same class as the receiver, but with a message equal to string.to_str.
pt: Exception
mt: instance
fn: inspect
fs: inspect
fd: Return this exception's class name an message
pt: Exception
mt: instance
fn: message
fs: message
fd: Returns the result of invoking exception.to_s. Normally this returns the exception's message or name. By supplying a to_str method, exceptions are agreeing to be used where Strings are expected.
pt: Exception
mt: instance
fn: new
fs: new(msg = nil)
fd: Construct a new Exception object, optionally passing in a message.
pt: Exception
mt: class
fn: set_backtrace
fs: set_backtrace(array)
fd: Sets the backtrace information associated with exc. The argument must be an array of String objects in the format described in Exception#backtrace.
pt: Exception
mt: instance
fn: to_s
fs: to_s
fd: Returns exception's message (or the name of the exception if no message is set).
pt: Exception
mt: instance
fn: to_str
fs: to_str
fd: Returns the result of invoking exception.to_s. Normally this returns the exception's message or name. By supplying a to_str method, exceptions are agreeing to be used where Strings are expected.
pt: Exception
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Exception
mt: instance
fn: yaml_new
fs: yaml_new( klass, tag, val )
fd: 
pt: Exception
mt: class
fn: bind
fs: bind(cl)
fd: 
pt: Exception2MessageMapper
mt: instance
fn: def_e2message
fs: def_e2message(c, m)
fd: def_e2message(c, m)
pt: Exception2MessageMapper
mt: instance
fn: def_exception
fs: def_exception(n, m, s = StandardError)
fd: def_exception(n, m, s)
pt: Exception2MessageMapper
mt: instance
fn: def_e2message
fs: def_e2message(k, c, m)
fd: E2MM.def_exception(k, e, m)
pt: Exception2MessageMapper::E2MM
mt: class
fn: def_exception
fs: def_exception(k, n, m, s = StandardError)
fd: E2MM.def_exception(k, n, m, s)
pt: Exception2MessageMapper::E2MM
mt: class
fn: e2mm_message
fs: e2mm_message(klass, exp)
fd: 
pt: Exception2MessageMapper::E2MM
mt: class
fn: extend_object
fs: extend_object(cl)
fd: 
pt: Exception2MessageMapper::E2MM
mt: class
fn: extend_to
fs: extend_to(b)
fd: backward compatibility
pt: Exception2MessageMapper::E2MM
mt: class
fn: Raise
fs: Raise(klass = E2MM, err = nil, *rest)
fd: Fail(klass, err, *rest)
pt: Exception2MessageMapper::E2MM
mt: class
fn: Fail
fs: Fail(err = nil, *rest)
fd: "Alias for #Raise"
pt: Exception2MessageMapper
mt: instance
fn: Raise
fs: Raise(err = nil, *rest)
fd: Fail(err, *rest)
pt: Exception2MessageMapper
mt: instance
fn: new
fs: new
fd: 
pt: FalseClass
mt: class
fn: to_s
fs: to_s
fd: "'nuf said..."
pt: FalseClass
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: FalseClass
mt: instance
fn: atime
fs: atime(file_name)
fd: Returns the last access time for the named file as a Time object).
pt: File
mt: class
fn: atime
fs: atime
fd: Returns the last access time (a Time object)
pt: File
mt: instance
fn: basename
fs: basename(file_name [, suffix] )
fd: Returns the last component of the filename given in file_name, which must be formed using forward slashes (``/'') regardless of the separator used on the local file system. If suffix is given and present at the end of file_name, it is removed.
pt: File
mt: class
fn: blockdev?
fs: blockdev?(file_name)
fd: Returns true if the named file is a block device.
pt: File
mt: class
fn: catname
fs: catname(from, to)
fd: If to is a valid directory, from will be appended to to, adding and escaping backslashes as necessary. Otherwise, to will be returned. Useful for appending from to to only if the filename was not specified in to.
pt: File
mt: class
fn: chardev?
fs: chardev?(file_name)
fd: Returns true if the named file is a character device.
pt: File
mt: class
fn: chmod
fs: chmod(mode, *files)
fd: Changes permission bits on files to the bit pattern represented by mode. If the last parameter isn't a String, verbose mode will be enabled.
pt: File
mt: class
fn: chmod
fs: chmod(mode_int)
fd: Changes permission bits on file to the bit pattern represented by mode_int. Actual effects are platform dependent; on Unix systems, see chmod(2) for details. Follows symbolic links. Also see File#lchmod.
pt: File
mt: instance
fn: chown
fs: chown(owner_int, group_int, file_name,... )
fd: Changes the owner and group of the named file(s) to the given numeric owner and group id's. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file's group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Returns the number of files processed.
pt: File
mt: class
fn: chown
fs: chown(owner_int, group_int )
fd: Changes the owner and group of file to the given numeric owner and group id's. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file's group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Follows symbolic links. See also File#lchown.
pt: File
mt: instance
fn: compare
fs: compare(from, to, verbose = false)
fd: Returns true if and only if the contents of files from and to are identical. If verbose is true, from &lt;=&gt; to is printed.
pt: File
mt: class
fn: copy
fs: copy(from, to, verbose = false)
fd: "Copies a file from to to using #syscopy. If to is a directory, copies from to to/from. If verbose is true, from -&gt; to is printed."
pt: File
mt: class
fn: ctime
fs: ctime(file_name)
fd: Returns the change time for the named file (the time at which directory information about the file was changed, not the file itself).
pt: File
mt: class
fn: ctime
fs: ctime
fd: Returns the change time for file (that is, the time directory information about the file was changed, not the file itself).
pt: File
mt: instance
fn: delete
fs: delete(file_name, ...)
fd: Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. See also Dir::rmdir.
pt: File
mt: class
fn: directory?
fs: directory?(file_name)
fd: Returns true if the named file is a directory, false otherwise.
pt: File
mt: class
fn: dirname
fs: dirname(file_name )
fd: Returns all components of the filename given in file_name except the last one. The filename must be formed using forward slashes (``/'') regardless of the separator used on the local file system.
pt: File
mt: class
fn: executable?
fs: executable?(file_name)
fd: Returns true if the named file is executable by the effective user id of this process.
pt: File
mt: class
fn: executable_real?
fs: executable_real?(file_name)
fd: Returns true if the named file is executable by the real user id of this process.
pt: File
mt: class
fn: exist?
fs: exist?(file_name)
fd: Return true if the named file exists.
pt: File
mt: class
fn: exists?
fs: exists?(file_name)
fd: Return true if the named file exists.
pt: File
mt: class
fn: expand_path
fs: expand_path(file_name [, dir_string] )
fd: Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a ``~'', which expands to the process owner's home directory (the environment variable HOME must be set correctly). ``~user'' expands to the named user's home directory.
pt: File
mt: class
fn: extname
fs: extname(path)
fd: Returns the extension (the portion of file name in path after the period).
pt: File
mt: class
fn: file?
fs: file?(file_name)
fd: Returns true if the named file exists and is a regular file.
pt: File
mt: class
fn: flock
fs: flock(locking_constant )
fd: Locks or unlocks a file according to locking_constant (a logical or of the values in the table below). Returns false if File::LOCK_NB is specified and the operation would otherwise have blocked. Not available on all platforms.
pt: File
mt: instance
fn: fnmatch?
fs: fnmatch?( pattern, path, [flags] )
fd: "Returns true if path matches against pattern The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters:"
pt: File
mt: class
fn: fnmatch
fs: fnmatch( pattern, path, [flags] )
fd: "Returns true if path matches against pattern The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters:"
pt: File
mt: class
fn: ftype
fs: ftype(file_name)
fd: Identifies the type of the named file; the return string is one of ``file'', ``directory'', ``characterSpecial'', ``blockSpecial'', ``fifo'', ``link'', ``socket'', or ``unknown''.
pt: File
mt: class
fn: grpowned?
fs: grpowned?(file_name)
fd: Returns true if the named file exists and the effective group id of the calling process is the owner of the file. Returns false on Windows.
pt: File
mt: class
fn: identical?
fs: identical?(file_1, file_2)
fd: Returns true if the named files are identical.
pt: File
mt: class
fn: install
fs: install(from, to, mode = nil, verbose = false)
fd: If src is not the same as dest, copies it and changes the permission mode to mode. If dest is a directory, destination is dest/src. If mode is not set, default is used. If verbose is set to true, the name of each file copied will be printed.
pt: File
mt: class
fn: join
fs: join(string, ...)
fd: Returns a new string formed by joining the strings using File::SEPARATOR.
pt: File
mt: class
fn: lchmod
fs: lchmod(mode_int, file_name, ...)
fd: Equivalent to File::chmod, but does not follow symbolic links (so it will change the permissions associated with the link, not the file referenced by the link). Often not available.
pt: File
mt: class
fn: lchown
fs: lchown(owner_int, group_int, file_name,..)
fd: Equivalent to File::chown, but does not follow symbolic links (so it will change the owner associated with the link, not the file referenced by the link). Often not available. Returns number of files in the argument list.
pt: File
mt: class
fn: link
fs: link(old_name, new_name)
fd: Creates a new name for an existing file using a hard link. Will not overwrite new_name if it already exists (raising a subclass of SystemCallError). Not available on all platforms.
pt: File
mt: class
fn: lstat
fs: lstat(file_name)
fd: Same as File::stat, but does not follow the last symbolic link. Instead, reports on the link itself.
pt: File
mt: class
fn: lstat
fs: lstat
fd: Same as IO#stat, but does not follow the last symbolic link. Instead, reports on the link itself.
pt: File
mt: instance
fn: makedirs
fs: makedirs(*dirs)
fd: Creates a directory and all its parent directories. For example,
pt: File
mt: class
fn: move
fs: move(from, to, verbose = false)
fd: "Moves a file from to to using #syscopy. If to is a directory, copies from from to to/from. If verbose is true, from -&gt; to is printed."
pt: File
mt: class
fn: mtime
fs: mtime(file_name)
fd: Returns the modification time for the named file as a Time object.
pt: File
mt: class
fn: mtime
fs: mtime
fd: Returns the modification time for file.
pt: File
mt: instance
fn: new
fs: new(filename, mode="r")
fd: Opens the file named by filename according to mode (default is ``r'') and returns a new File object. See the description of class IO for a description of mode. The file mode may optionally be specified as a Fixnum by or-ing together the flags (O_RDONLY etc, again described under IO). Optional permission bits may be given in perm. These mode and permission bits are platform dependent; on Unix systems, see open(2) for details.
pt: File
mt: class
fn: o_chmod
fs: o_chmod(p1)
fd: "Alias for #chmod"
pt: File
mt: instance
fn: owned?
fs: owned?(file_name)
fd: Returns true if the named file exists and the effective used id of the calling process is the owner of the file.
pt: File
mt: class
fn: path
fs: path
fd: Returns the pathname used to create file as a string. Does not normalize the name.
pt: File
mt: instance
fn: pipe?
fs: pipe?(file_name)
fd: Returns true if the named file is a pipe.
pt: File
mt: class
fn: readable?
fs: readable?(file_name)
fd: Returns true if the named file is readable by the effective user id of this process.
pt: File
mt: class
fn: readable_real?
fs: readable_real?(file_name)
fd: Returns true if the named file is readable by the real user id of this process.
pt: File
mt: class
fn: readlink
fs: readlink(link_name)
fd: Returns the name of the file referenced by the given link. Not available on all platforms.
pt: File
mt: class
fn: rename
fs: rename(old_name, new_name)
fd: Renames the given file to the new name. Raises a SystemCallError if the file cannot be renamed.
pt: File
mt: class
fn: safe_unlink
fs: safe_unlink(*files)
fd: Removes a list of files. Each parameter should be the name of the file to delete. If the last parameter isn't a String, verbose mode will be enabled. Returns the number of files deleted.
pt: File
mt: class
fn: setgid?
fs: setgid?(file_name)
fd: Returns true if the named file has the setgid bit set.
pt: File
mt: class
fn: setuid?
fs: setuid?(file_name)
fd: Returns true if the named file has the setuid bit set.
pt: File
mt: class
fn: size?
fs: size?(file_name)
fd: Returns nil if file_name doesn't exist or has zero size, the size of the file otherwise.
pt: File
mt: class
fn: size
fs: size(file_name)
fd: Returns the size of file_name.
pt: File
mt: class
fn: socket?
fs: socket?(file_name)
fd: Returns true if the named file is a socket.
pt: File
mt: class
fn: split
fs: split(file_name)
fd: Splits the given string into a directory and a file component and returns them in a two-element array. See also File::dirname and File::basename.
pt: File
mt: class
fn: atime
fs: atime
fd: Returns the last access time for this file as an object of class Time.
pt: File::Stat
mt: instance
fn: blksize
fs: blksize
fd: Returns the native file system's block size. Will return nil on platforms that don't support this information.
pt: File::Stat
mt: instance
fn: blockdev?
fs: blockdev?
fd: Returns true if the file is a block device, false if it isn't or if the operating system doesn't support this feature.
pt: File::Stat
mt: instance
fn: blocks
fs: blocks
fd: Returns the number of native file system blocks allocated for this file, or nil if the operating system doesn't support this feature.
pt: File::Stat
mt: instance
fn: chardev?
fs: chardev?
fd: Returns true if the file is a character device, false if it isn't or if the operating system doesn't support this feature.
pt: File::Stat
mt: instance
fn: ctime
fs: ctime
fd: Returns the change time for stat (that is, the time directory information about the file was changed, not the file itself).
pt: File::Stat
mt: instance
fn: dev
fs: dev
fd: Returns an integer representing the device on which stat resides.
pt: File::Stat
mt: instance
fn: dev_major
fs: dev_major
fd: Returns the major part of File_Stat#dev or nil.
pt: File::Stat
mt: instance
fn: dev_minor
fs: dev_minor
fd: Returns the minor part of File_Stat#dev or nil.
pt: File::Stat
mt: instance
fn: directory?
fs: directory?
fd: Returns true if stat is a directory, false otherwise.
pt: File::Stat
mt: instance
fn: executable?
fs: executable?
fd: Returns true if stat is executable or if the operating system doesn't distinguish executable files from nonexecutable files. The tests are made using the effective owner of the process.
pt: File::Stat
mt: instance
fn: executable_real?
fs: executable_real?
fd: Same as executable?, but tests using the real owner of the process.
pt: File::Stat
mt: instance
fn: file?
fs: file?
fd: Returns true if stat is a regular file (not a device file, pipe, socket, etc.).
pt: File::Stat
mt: instance
fn: ftype
fs: ftype
fd: "Identifies the type of stat. The return string is one of: ``file'', ``directory'', ``characterSpecial'', ``blockSpecial'', ``fifo'', ``link'', ``socket'', or ``unknown''."
pt: File::Stat
mt: instance
fn: gid
fs: gid
fd: Returns the numeric group id of the owner of stat.
pt: File::Stat
mt: instance
fn: grpowned?
fs: grpowned?
fd: Returns true if the effective group id of the process is the same as the group id of stat. On Windows NT, returns false.
pt: File::Stat
mt: instance
fn: ino
fs: ino
fd: Returns the inode number for stat.
pt: File::Stat
mt: instance
fn: inspect
fs: inspect
fd: Produce a nicely formatted description of stat.
pt: File::Stat
mt: instance
fn: mode
fs: mode
fd: Returns an integer representing the permission bits of stat. The meaning of the bits is platform dependent; on Unix systems, see stat(2).
pt: File::Stat
mt: instance
fn: mtime
fs: mtime
fd: Returns the modification time of stat.
pt: File::Stat
mt: instance
fn: new
fs: new
fd: "  File::Stat.new(file_name)  =&gt; stat\n"
pt: File::Stat
mt: class
fn: nlink
fs: nlink
fd: Returns the number of hard links to stat.
pt: File::Stat
mt: instance
fn: owned?
fs: owned?
fd: Returns true if the effective user id of the process is the same as the owner of stat.
pt: File::Stat
mt: instance
fn: pipe?
fs: pipe?
fd: Returns true if the operating system supports pipes and stat is a pipe; false otherwise.
pt: File::Stat
mt: instance
fn: pretty_print
fs: pretty_print(q)
fd: 
pt: File::Stat
mt: instance
fn: rdev
fs: rdev
fd: Returns an integer representing the device type on which stat resides. Returns nil if the operating system doesn't support this feature.
pt: File::Stat
mt: instance
fn: rdev_major
fs: rdev_major
fd: Returns the major part of File_Stat#rdev or nil.
pt: File::Stat
mt: instance
fn: rdev_minor
fs: rdev_minor
fd: Returns the minor part of File_Stat#rdev or nil.
pt: File::Stat
mt: instance
fn: readable?
fs: readable?
fd: Returns true if stat is readable by the effective user id of this process.
pt: File::Stat
mt: instance
fn: readable_real?
fs: readable_real?
fd: Returns true if stat is readable by the real user id of this process.
pt: File::Stat
mt: instance
fn: setgid?
fs: setgid?
fd: Returns true if stat has the set-group-id permission bit set, false if it doesn't or if the operating system doesn't support this feature.
pt: File::Stat
mt: instance
fn: setuid?
fs: setuid?
fd: Returns true if stat has the set-user-id permission bit set, false if it doesn't or if the operating system doesn't support this feature.
pt: File::Stat
mt: instance
fn: size?
fs: size?
fd: Returns the size of stat in bytes.
pt: File::Stat
mt: instance
fn: size
fs: size
fd: Returns the size of stat in bytes.
pt: File::Stat
mt: instance
fn: socket?
fs: socket?
fd: Returns true if stat is a socket, false if it isn't or if the operating system doesn't support this feature.
pt: File::Stat
mt: instance
fn: sticky?
fs: sticky?
fd: Returns true if stat has its sticky bit set, false if it doesn't or if the operating system doesn't support this feature.
pt: File::Stat
mt: instance
fn: symlink?
fs: symlink?
fd: Returns true if stat is a symbolic link, false if it isn't or if the operating system doesn't support this feature. As File::stat automatically follows symbolic links, symlink? will always be false for an object returned by File::stat.
pt: File::Stat
mt: instance
fn: uid
fs: uid
fd: Returns the numeric user id of the owner of stat.
pt: File::Stat
mt: instance
fn: writable?
fs: writable?
fd: Returns true if stat is writable by the effective user id of this process.
pt: File::Stat
mt: instance
fn: writable_real?
fs: writable_real?
fd: Returns true if stat is writable by the real user id of this process.
pt: File::Stat
mt: instance
fn: zero?
fs: zero?
fd: Returns true if stat is a zero-length file; false otherwise.
pt: File::Stat
mt: instance
fn: stat
fs: stat(file_name)
fd: Returns a File::Stat object for the named file (see File::Stat).
pt: File
mt: class
fn: sticky?
fs: sticky?(file_name)
fd: Returns true if the named file has the sticky bit set.
pt: File
mt: class
fn: symlink?
fs: symlink?(file_name)
fd: Returns true if the named file is a symbolic link.
pt: File
mt: class
fn: symlink
fs: symlink(old_name, new_name)
fd: Creates a symbolic link called new_name for the existing file old_name. Raises a NotImplemented exception on platforms that do not support symbolic links.
pt: File
mt: class
fn: syscopy
fs: syscopy(from, to)
fd: Copies a file from to to. If to is a directory, copies from to to/from.
pt: File
mt: class
fn: truncate
fs: truncate(file_name, integer)
fd: Truncates the file file_name to be at most integer bytes long. Not available on all platforms.
pt: File
mt: class
fn: truncate
fs: truncate(integer)
fd: Truncates file to at most integer bytes. The file must be opened for writing. Not available on all platforms.
pt: File
mt: instance
fn: umask
fs: umask()
fd: Returns the current umask value for this process. If the optional argument is given, set the umask to that value and return the previous value. Umask values are subtracted from the default permissions, so a umask of 0222 would make a file read-only for everyone.
pt: File
mt: class
fn: unlink
fs: unlink(file_name, ...)
fd: Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. See also Dir::rmdir.
pt: File
mt: class
fn: utime
fs: utime(atime, mtime, file_name,...)
fd: Sets the access and modification times of each named file to the first two arguments. Returns the number of file names in the argument list.
pt: File
mt: class
fn: writable?
fs: writable?(file_name)
fd: Returns true if the named file is writable by the effective user id of this process.
pt: File
mt: class
fn: writable_real?
fs: writable_real?(file_name)
fd: Returns true if the named file is writable by the real user id of this process.
pt: File
mt: class
fn: zero?
fs: zero?(file_name)
fd: Returns true if the named file exists and has a zero size.
pt: File
mt: class
fn: blockdev?
fs: blockdev?(file_name)
fd: Returns true if the named file is a block device.
pt: FileTest
mt: instance
fn: chardev?
fs: chardev?(file_name)
fd: Returns true if the named file is a character device.
pt: FileTest
mt: instance
fn: directory?
fs: directory?(file_name)
fd: Returns true if the named file is a directory, false otherwise.
pt: FileTest
mt: instance
fn: executable?
fs: executable?(file_name)
fd: Returns true if the named file is executable by the effective user id of this process.
pt: FileTest
mt: instance
fn: executable_real?
fs: executable_real?(file_name)
fd: Returns true if the named file is executable by the real user id of this process.
pt: FileTest
mt: instance
fn: exist?
fs: exist?(file_name)
fd: Return true if the named file exists.
pt: FileTest
mt: instance
fn: exists?
fs: exists?(file_name)
fd: Return true if the named file exists.
pt: FileTest
mt: instance
fn: file?
fs: file?(file_name)
fd: Returns true if the named file exists and is a regular file.
pt: FileTest
mt: instance
fn: grpowned?
fs: grpowned?(file_name)
fd: Returns true if the named file exists and the effective group id of the calling process is the owner of the file. Returns false on Windows.
pt: FileTest
mt: instance
fn: identical?
fs: identical?(file_1, file_2)
fd: Returns true if the named files are identical.
pt: FileTest
mt: instance
fn: owned?
fs: owned?(file_name)
fd: Returns true if the named file exists and the effective used id of the calling process is the owner of the file.
pt: FileTest
mt: instance
fn: pipe?
fs: pipe?(file_name)
fd: Returns true if the named file is a pipe.
pt: FileTest
mt: instance
fn: readable?
fs: readable?(file_name)
fd: Returns true if the named file is readable by the effective user id of this process.
pt: FileTest
mt: instance
fn: readable_real?
fs: readable_real?(file_name)
fd: Returns true if the named file is readable by the real user id of this process.
pt: FileTest
mt: instance
fn: setgid?
fs: setgid?(file_name)
fd: Returns true if the named file has the setgid bit set.
pt: FileTest
mt: instance
fn: setuid?
fs: setuid?(file_name)
fd: Returns true if the named file has the setuid bit set.
pt: FileTest
mt: instance
fn: size?
fs: size?(file_name)
fd: Returns nil if file_name doesn't exist or has zero size, the size of the file otherwise.
pt: FileTest
mt: instance
fn: size
fs: size(file_name)
fd: Returns the size of file_name.
pt: FileTest
mt: instance
fn: socket?
fs: socket?(file_name)
fd: Returns true if the named file is a socket.
pt: FileTest
mt: instance
fn: sticky?
fs: sticky?(file_name)
fd: Returns true if the named file has the sticky bit set.
pt: FileTest
mt: instance
fn: symlink?
fs: symlink?(file_name)
fd: Returns true if the named file is a symbolic link.
pt: FileTest
mt: instance
fn: writable?
fs: writable?(file_name)
fd: Returns true if the named file is writable by the effective user id of this process.
pt: FileTest
mt: instance
fn: writable_real?
fs: writable_real?(file_name)
fd: Returns true if the named file is writable by the real user id of this process.
pt: FileTest
mt: instance
fn: zero?
fs: zero?(file_name)
fd: Returns true if the named file exists and has a zero size.
pt: FileTest
mt: instance
fn: cd
fs: cd(dir, options = {})
fd: "Options: verbose"
pt: FileUtils
mt: instance
fn: chdir
fs: chdir(dir, options = {})
fd: "Alias for #cd"
pt: FileUtils
mt: instance
fn: chmod
fs: chmod(mode, list, options = {})
fd: "Options: noop verbose"
pt: FileUtils
mt: instance
fn: chmod_R
fs: chmod_R(mode, list, options = {})
fd: "Options: noop verbose force"
pt: FileUtils
mt: instance
fn: chown
fs: chown(user, group, list, options = {})
fd: "Options: noop verbose"
pt: FileUtils
mt: instance
fn: chown_R
fs: chown_R(user, group, list, options = {})
fd: "Options: noop verbose force"
pt: FileUtils
mt: instance
fn: cmp
fs: cmp(a, b)
fd: "Alias for #compare_file"
pt: FileUtils
mt: instance
fn: compare_file
fs: compare_file(a, b)
fd: Returns true if the contents of a file A and a file B are identical.
pt: FileUtils
mt: instance
fn: compare_stream
fs: compare_stream(a, b)
fd: Returns true if the contents of a stream a and b are identical.
pt: FileUtils
mt: instance
fn: copy
fs: copy(src, dest, options = {})
fd: "Alias for #cp"
pt: FileUtils
mt: instance
fn: copy_entry
fs: copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
fd: Copies a file system entry src to dest. If src is a directory, this method copies its contents recursively. This method preserves file types, c.f. symlink, directory... (FIFO, device files and etc. are not supported yet)
pt: FileUtils
mt: instance
fn: copy_file
fs: copy_file(src, dest, preserve = false, dereference = true)
fd: Copies file contents of src to dest. Both of src and dest must be a path name.
pt: FileUtils
mt: instance
fn: copy_stream
fs: copy_stream(src, dest)
fd: "Copies stream src to dest. src must respond to #read(n) and dest must respond to #write(str)."
pt: FileUtils
mt: instance
fn: cp
fs: cp(src, dest, options = {})
fd: "Options: preserve noop verbose"
pt: FileUtils
mt: instance
fn: cp_r
fs: cp_r(src, dest, options = {})
fd: "Options: preserve noop verbose dereference_root remove_destination"
pt: FileUtils
mt: instance
fn: fu_have_symlink?
fs: fu_have_symlink?(
fd: 
pt: FileUtils
mt: instance
fn: fu_world_writable?
fs: fu_world_writable?(st)
fd: 
pt: FileUtils
mt: instance
fn: getwd
fs: getwd()
fd: "Alias for #pwd"
pt: FileUtils
mt: instance
fn: identical?
fs: identical?(a, b)
fd: "Alias for #compare_file"
pt: FileUtils
mt: instance
fn: install
fs: install(src, dest, options = {})
fd: "Options: mode preserve noop verbose"
pt: FileUtils
mt: instance
fn: link
fs: link(src, dest, options = {})
fd: "Alias for #ln"
pt: FileUtils
mt: instance
fn: ln
fs: ln(src, dest, options = {})
fd: "Options: force noop verbose"
pt: FileUtils
mt: instance
fn: ln_s
fs: ln_s(src, dest, options = {})
fd: "Options: force noop verbose"
pt: FileUtils
mt: instance
fn: ln_sf
fs: ln_sf(src, dest, options = {})
fd: "Options: noop verbose"
pt: FileUtils
mt: instance
fn: makedirs
fs: makedirs(list, options = {})
fd: "Alias for #mkdir_p"
pt: FileUtils
mt: instance
fn: mkdir
fs: mkdir(list, options = {})
fd: "Options: mode noop verbose"
pt: FileUtils
mt: instance
fn: mkdir_p
fs: mkdir_p(list, options = {})
fd: "Options: mode noop verbose"
pt: FileUtils
mt: instance
fn: mkpath
fs: mkpath(list, options = {})
fd: "Alias for #mkdir_p"
pt: FileUtils
mt: instance
fn: move
fs: move(src, dest, options = {})
fd: "Alias for #mv"
pt: FileUtils
mt: instance
fn: mv
fs: mv(src, dest, options = {})
fd: "Options: force noop verbose"
pt: FileUtils
mt: instance
fn: pwd
fs: pwd()
fd: "Options: (none)"
pt: FileUtils
mt: instance
fn: remove
fs: remove(list, options = {})
fd: "Alias for #rm"
pt: FileUtils
mt: instance
fn: remove_dir
fs: remove_dir(path, force = false)
fd: Removes a directory dir and its contents recursively. This method ignores StandardError if force is true.
pt: FileUtils
mt: instance
fn: remove_entry
fs: remove_entry(path, force = false)
fd: This method removes a file system entry path. path might be a regular file, a directory, or something. If path is a directory, remove it recursively.
pt: FileUtils
mt: instance
fn: remove_entry_secure
fs: remove_entry_secure(path, force = false)
fd: "This method removes a file system entry path. path shall be a regular file, a directory, or something. If path is a directory, remove it recursively. This method is required to avoid TOCTTOU (time-of-check-to-time-of-use) local security vulnerability of #rm_r. #rm_r causes security hole when:"
pt: FileUtils
mt: instance
fn: remove_file
fs: remove_file(path, force = false)
fd: Removes a file path. This method ignores StandardError if force is true.
pt: FileUtils
mt: instance
fn: rm
fs: rm(list, options = {})
fd: "Options: force noop verbose"
pt: FileUtils
mt: instance
fn: rm_f
fs: rm_f(list, options = {})
fd: "Options: noop verbose"
pt: FileUtils
mt: instance
fn: rm_r
fs: rm_r(list, options = {})
fd: "Options: force noop verbose secure"
pt: FileUtils
mt: instance
fn: rm_rf
fs: rm_rf(list, options = {})
fd: "Options: noop verbose secure"
pt: FileUtils
mt: instance
fn: rmdir
fs: rmdir(list, options = {})
fd: "Options: noop, verbose"
pt: FileUtils
mt: instance
fn: rmtree
fs: rmtree(list, options = {})
fd: "Alias for #rm_rf"
pt: FileUtils
mt: instance
fn: safe_unlink
fs: safe_unlink(list, options = {})
fd: "Alias for #rm_f"
pt: FileUtils
mt: instance
fn: symlink
fs: symlink(src, dest, options = {})
fd: "Alias for #ln_s"
pt: FileUtils
mt: instance
fn: touch
fs: touch(list, options = {})
fd: "Options: noop verbose"
pt: FileUtils
mt: instance
fn: uptodate?
fs: uptodate?(new, old_list, options = nil)
fd: "Options: (none)"
pt: FileUtils
mt: instance
fn: add_dependency
fs: add_dependency(obj, dependant, method = :finalize, *opt)
fd: add dependency R_method(obj, dependant)
pt: Finalizer
mt: class
fn: delete_all_by_dependant
fs: delete_all_by_dependant(dependant)
fd: delete dependency R_*(*, dependant)
pt: Finalizer
mt: class
fn: delete_all_dependency
fs: delete_all_dependency(id, dependant)
fd: delete dependency R_*(obj, dependant)
pt: Finalizer
mt: class
fn: delete_by_dependant
fs: delete_by_dependant(dependant, method = :finalize)
fd: delete dependency R_method(*, dependant)
pt: Finalizer
mt: class
fn: delete_dependency
fs: delete_dependency(id, dependant, method = :finalize)
fd: delete dependency R_method(obj, dependant)
pt: Finalizer
mt: class
fn: finalize_all
fs: finalize_all()
fd: finalize all dependants registered to the Finalizer.
pt: Finalizer
mt: class
fn: finalize_all_by_dependant
fs: finalize_all_by_dependant(dependant)
fd: finalize all dependants connected by dependency R_*(*, dependtant)
pt: Finalizer
mt: class
fn: finalize_all_dependency
fs: finalize_all_dependency(id, dependant)
fd: finalize all dependants connected by dependency R_*(obj, dependtant)
pt: Finalizer
mt: class
fn: finalize_by_dependant
fs: finalize_by_dependant(dependant, method = :finalize)
fd: finalize the dependant connected by dependency R_method(*, dependtant)
pt: Finalizer
mt: class
fn: finalize_dependency
fs: finalize_dependency(id, dependant, method = :finalize)
fd: finalize the depandant connected by dependency R_method(obj, dependtant)
pt: Finalizer
mt: class
fn: safe
fs: safe()
fd: method to call finalize_* safely.
pt: Finalizer
mt: class
fn: find
fs: find(*paths)
fd: Calls the associated block with the name of every file and directory listed as arguments, then recursively on their subdirectories, and so on.
pt: Find
mt: instance
fn: prune
fs: prune()
fd: Skips the current file or directory, restarting the loop with the next entry. If the current file is a directory, that directory will not be recursively entered. Meaningful only within the block associated with Find::find.
pt: Find
mt: instance
fn: abs
fs: abs
fd: Returns the absolute value of fix.
pt: Fixnum
mt: instance
fn: dclone
fs: dclone()
fd: 
pt: Fixnum
mt: instance
fn: div
fs: div(numeric)
fd: "Performs division: the class of the resulting object depends on the class of numeric and on the magnitude of the result."
pt: Fixnum
mt: instance
fn: divmod
fs: divmod(numeric)
fd: See Numeric#divmod.
pt: Fixnum
mt: instance
fn: id2name
fs: id2name
fd: Returns the name of the object whose symbol id is fix. If there is no symbol in the symbol table with this value, returns nil. id2name has nothing to do with the Object.id method. See also Fixnum#to_sym, String#intern, and class Symbol.
pt: Fixnum
mt: instance
fn: induced_from
fs: induced_from(obj)
fd: Convert obj to a Fixnum. Works with numeric parameters. Also works with Symbols, but this is deprecated.
pt: Fixnum
mt: class
fn: modulo
fs: modulo(other)
fd: Returns fix modulo other. See Numeric.divmod for more information.
pt: Fixnum
mt: instance
fn: new
fs: new
fd: 
pt: Fixnum
mt: class
fn: power!
fs: power!(p1)
fd: "Alias for #**"
pt: Fixnum
mt: instance
fn: quo
fs: quo(other)
fd: If Rational is defined, returns a Rational number instead of a Fixnum.
pt: Fixnum
mt: instance
fn: rdiv
fs: rdiv(p1)
fd: "Alias for #quo"
pt: Fixnum
mt: instance
fn: rpower
fs: rpower(other)
fd: Returns a Rational number if the result is in fact rational (i.e. other &lt; 0).
pt: Fixnum
mt: instance
fn: size
fs: size
fd: Returns the number of bytes in the machine representation of a Fixnum.
pt: Fixnum
mt: instance
fn: to_f
fs: to_f
fd: Converts fix to a Float.
pt: Fixnum
mt: instance
fn: to_s
fs: to_s( base=10 )
fd: Returns a string containing the representation of fix radix base (between 2 and 36).
pt: Fixnum
mt: instance
fn: to_sym
fs: to_sym
fd: Returns the symbol whose integer value is fix. See also Fixnum#id2name.
pt: Fixnum
mt: instance
fn: zero?
fs: zero?
fd: Returns true if fix is zero.
pt: Fixnum
mt: instance
fn: abs
fs: abs
fd: Returns the absolute value of flt.
pt: Float
mt: instance
fn: ceil
fs: ceil
fd: Returns the smallest Integer greater than or equal to flt.
pt: Float
mt: instance
fn: coerce
fs: coerce(p1)
fd: "MISSING: documentation"
pt: Float
mt: instance
fn: dclone
fs: dclone()
fd: 
pt: Float
mt: instance
fn: divmod
fs: divmod(numeric)
fd: See Numeric#divmod.
pt: Float
mt: instance
fn: eql?
fs: eql?(obj)
fd: Returns true only if obj is a Float with the same value as flt. Contrast this with Float#==, which performs type conversions.
pt: Float
mt: instance
fn: finite?
fs: finite?
fd: Returns true if flt is a valid IEEE floating point number (it is not infinite, and nan? is false).
pt: Float
mt: instance
fn: floor
fs: floor
fd: Returns the largest integer less than or equal to flt.
pt: Float
mt: instance
fn: hash
fs: hash
fd: Returns a hash code for this float.
pt: Float
mt: instance
fn: induced_from
fs: induced_from(obj)
fd: Convert obj to a float.
pt: Float
mt: class
fn: infinite?
fs: infinite?
fd: Returns nil, -1, or +1 depending on whether flt is finite, -infinity, or +infinity.
pt: Float
mt: instance
fn: modulo
fs: modulo(other)
fd: Return the modulo after division of flt by other.
pt: Float
mt: instance
fn: nan?
fs: nan?
fd: Returns true if flt is an invalid IEEE floating point number.
pt: Float
mt: instance
fn: new
fs: new
fd: 
pt: Float
mt: class
fn: round
fs: round
fd: "Rounds flt to the nearest integer. Equivalent to:"
pt: Float
mt: instance
fn: to_f
fs: to_f
fd: As flt is already a float, returns self.
pt: Float
mt: instance
fn: to_i
fs: to_i
fd: Returns flt truncated to an Integer.
pt: Float
mt: instance
fn: to_int
fs: to_int
fd: Returns flt truncated to an Integer.
pt: Float
mt: instance
fn: to_s
fs: to_s
fd: Returns a string containing a representation of self. As well as a fixed or exponential form of the number, the call may return ``NaN'', ``Infinity'', and ``-Infinity''.
pt: Float
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Float
mt: instance
fn: truncate
fs: truncate
fd: Returns flt truncated to an Integer.
pt: Float
mt: instance
fn: zero?
fs: zero?
fd: Returns true if flt is 0.0.
pt: Float
mt: instance
fn: hello
fs: hello(it)
fd: 
pt: Foo
mt: instance
fn: new
fs: new(str)
fd: 
pt: Foo
mt: class
fn: to_s
fs: to_s()
fd: 
pt: Foo
mt: instance
fn: def_delegator
fs: def_delegator(accessor, method, ali = method)
fd: "Alias for #def_instance_delegator"
pt: Forwardable
mt: instance
fn: def_delegators
fs: def_delegators(accessor, *methods)
fd: "Alias for #def_instance_delegators"
pt: Forwardable
mt: instance
fn: def_instance_delegator
fs: def_instance_delegator(accessor, method, ali = method)
fd: Defines a method method which delegates to obj (i.e. it calls the method of the same name in obj). If new_name is provided, it is used as the name for the delegate method.
pt: Forwardable
mt: instance
fn: def_instance_delegators
fs: def_instance_delegators(accessor, *methods)
fd: "Shortcut for defining multiple delegator methods, but with no provision for using a different name. The following two code samples have the same effect:"
pt: Forwardable
mt: instance
fn: disable
fs: disable
fd: Disables garbage collection, returning true if garbage collection was already disabled.
pt: GC
mt: class
fn: enable
fs: enable
fd: Enables garbage collection, returning true if garbage collection was previously disabled.
pt: GC
mt: class
fn: garbage_collect
fs: garbage_collect
fd: Initiates garbage collection, unless manually disabled.
pt: GC
mt: instance
fn: start
fs: start
fd: Initiates garbage collection, unless manually disabled.
pt: GC
mt: class
fn: current
fs: current()
fd: Returns the element at the current position.
pt: Generator
mt: instance
fn: each
fs: each()
fd: Rewinds the generator and enumerates the elements.
pt: Generator
mt: instance
fn: end?
fs: end?()
fd: Returns true if the generator has reached the end.
pt: Generator
mt: instance
fn: index
fs: index()
fd: Returns the current index (position) counting from zero.
pt: Generator
mt: instance
fn: new
fs: new(enum = nil, &block)
fd: Creates a new generator either from an Enumerable object or from a block.
pt: Generator
mt: class
fn: next?
fs: next?()
fd: Returns true if the generator has not reached the end yet.
pt: Generator
mt: instance
fn: next
fs: next()
fd: Returns the element at the current position and moves forward.
pt: Generator
mt: instance
fn: pos
fs: pos()
fd: Returns the current index (position) counting from zero.
pt: Generator
mt: instance
fn: rewind
fs: rewind()
fd: Rewinds the generator.
pt: Generator
mt: instance
fn: yield
fs: yield(value)
fd: Yields an element to the generator.
pt: Generator
mt: instance
fn: add
fs: add(name, html_class)
fd: 
pt: Generators::AllReferences
mt: class
fn: keys
fs: keys()
fd: 
pt: Generators::AllReferences
mt: class
fn: reset
fs: reset()
fd: 
pt: Generators::AllReferences
mt: class
fn: check_for_html_help_workshop
fs: check_for_html_help_workshop()
fd: 
pt: Generators::CHMGenerator
mt: instance
fn: compile_project
fs: compile_project()
fd: Invoke the windows help compiler to compiler the project
pt: Generators::CHMGenerator
mt: instance
fn: create_contents_and_index
fs: create_contents_and_index()
fd: The contents is a list of all files and modules. For each we include as sub-entries the list of methods they contain. As we build the contents we also build an index file
pt: Generators::CHMGenerator
mt: instance
fn: create_help_project
fs: create_help_project()
fd: The project contains the project file, a table of contents and an index
pt: Generators::CHMGenerator
mt: instance
fn: create_project_file
fs: create_project_file()
fd: The project file links together all the various files that go to make up the help.
pt: Generators::CHMGenerator
mt: instance
fn: for
fs: for(options)
fd: Standard generator factory
pt: Generators::CHMGenerator
mt: class
fn: generate
fs: generate(info)
fd: Generate the html as normal, then wrap it in a help project
pt: Generators::CHMGenerator
mt: instance
fn: new
fs: new(*args)
fd: 
pt: Generators::CHMGenerator
mt: class
fn: add_table_of_sections
fs: add_table_of_sections()
fd: create table of contents if we contain sections
pt: Generators::ContextUser
mt: instance
fn: aref_to
fs: aref_to(target)
fd: 
pt: Generators::ContextUser
mt: instance
fn: as_href
fs: as_href(from_path)
fd: return a reference to outselves to be used as an href= the form depends on whether we're all in one file or in multiple files
pt: Generators::ContextUser
mt: instance
fn: build_alias_summary_list
fs: build_alias_summary_list(section)
fd: Build a list of aliases for which we couldn't find a corresponding method
pt: Generators::ContextUser
mt: instance
fn: build_class_list
fs: build_class_list(level, from, section, infile=nil)
fd: Build the structured list of classes and modules contained in this context.
pt: Generators::ContextUser
mt: instance
fn: build_constants_summary_list
fs: build_constants_summary_list(section)
fd: Build a list of constants
pt: Generators::ContextUser
mt: instance
fn: build_include_list
fs: build_include_list(context)
fd: 
pt: Generators::ContextUser
mt: instance
fn: build_method_detail_list
fs: build_method_detail_list(section)
fd: Build an array of arrays of method details. The outer array has up to six entries, public, private, and protected for both class methods, the other for instance methods. The inner arrays contain a hash for each method
pt: Generators::ContextUser
mt: instance
fn: build_method_summary_list
fs: build_method_summary_list(path_prefix="")
fd: Build a summary list of all the methods in this context
pt: Generators::ContextUser
mt: instance
fn: build_requires_list
fs: build_requires_list(context)
fd: 
pt: Generators::ContextUser
mt: instance
fn: collect_methods
fs: collect_methods()
fd: Create a list of HtmlMethod objects for each method in the corresponding context object. If the @options.show_all variable is set (corresponding to the --all option, we include all methods, otherwise just the public ones.
pt: Generators::ContextUser
mt: instance
fn: diagram_reference
fs: diagram_reference(diagram)
fd: 
pt: Generators::ContextUser
mt: instance
fn: document_self
fs: document_self()
fd: 
pt: Generators::ContextUser
mt: instance
fn: find_symbol
fs: find_symbol(symbol, method=nil)
fd: Find a symbol in ourselves or our parent
pt: Generators::ContextUser
mt: instance
fn: href
fs: href(link, cls, name)
fd: convenience method to build a hyperlink
pt: Generators::ContextUser
mt: instance
fn: new
fs: new(context, options)
fd: 
pt: Generators::ContextUser
mt: class
fn: potentially_referenced_list
fs: potentially_referenced_list(array)
fd: "Build a list from an array of Htmlxxx items. Look up each in the AllReferences hash: if we find a corresponding entry, we generate a hyperlink to it, otherwise just output the name. However, some names potentially need massaging. For example, you may require a Ruby file without the .rb extension, but the file names we know about may have it. To deal with this, we pass in a block which performs the massaging, returning an array of alternative names to match"
pt: Generators::ContextUser
mt: instance
fn: url
fs: url(target)
fd: 
pt: Generators::ContextUser
mt: instance
fn: build_attribute_list
fs: build_attribute_list(section)
fd: 
pt: Generators::HtmlClass
mt: instance
fn: class_attribute_values
fs: class_attribute_values()
fd: 
pt: Generators::HtmlClass
mt: instance
fn: http_url
fs: http_url(full_name, prefix)
fd: return the relative file name to store this class in, which is also its url
pt: Generators::HtmlClass
mt: instance
fn: index_name
fs: index_name()
fd: 
pt: Generators::HtmlClass
mt: instance
fn: name
fs: name()
fd: 
pt: Generators::HtmlClass
mt: instance
fn: new
fs: new(context, html_file, prefix, options)
fd: 
pt: Generators::HtmlClass
mt: class
fn: parent_name
fs: parent_name()
fd: 
pt: Generators::HtmlClass
mt: instance
fn: value_hash
fs: value_hash()
fd: 
pt: Generators::HtmlClass
mt: instance
fn: write_on
fs: write_on(f)
fd: 
pt: Generators::HtmlClass
mt: instance
fn: file_attribute_values
fs: file_attribute_values()
fd: 
pt: Generators::HtmlFile
mt: instance
fn: filename_to_label
fs: filename_to_label()
fd: 
pt: Generators::HtmlFile
mt: instance
fn: http_url
fs: http_url(file_dir)
fd: 
pt: Generators::HtmlFile
mt: instance
fn: index_name
fs: index_name()
fd: 
pt: Generators::HtmlFile
mt: instance
fn: new
fs: new(context, options, file_dir)
fd: 
pt: Generators::HtmlFile
mt: class
fn: parent_name
fs: parent_name()
fd: 
pt: Generators::HtmlFile
mt: instance
fn: value_hash
fs: value_hash()
fd: 
pt: Generators::HtmlFile
mt: instance
fn: write_on
fs: write_on(f)
fd: 
pt: Generators::HtmlFile
mt: instance
fn: for
fs: for(options)
fd: Generators may need to return specific subclasses depending on the options they are passed. Because of this we create them using a factory
pt: Generators::HTMLGenerator
mt: class
fn: gen_url
fs: gen_url(path, target)
fd: convert a target url to one that is relative to a given path
pt: Generators::HTMLGenerator
mt: class
fn: generate
fs: generate(toplevels)
fd: Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information.
pt: Generators::HTMLGenerator
mt: instance
fn: new
fs: new(options)
fd: Set up a new HTML generator. Basically all we do here is load up the correct output temlate
pt: Generators::HTMLGenerator
mt: class
fn: build_class_list
fs: build_class_list(from, html_file, class_dir)
fd: 
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: build_indices
fs: build_indices()
fd: "Generate:"
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: gen_an_index
fs: gen_an_index(collection, title)
fd: 
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: gen_class_index
fs: gen_class_index()
fd: 
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: gen_file_index
fs: gen_file_index()
fd: 
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: gen_into
fs: gen_into(list)
fd: 
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: gen_method_index
fs: gen_method_index()
fd: 
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: generate
fs: generate(info)
fd: Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information.
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: generate_xml
fs: generate_xml()
fd: Generate all the HTML. For the one-file case, we generate all the information in to one big hash
pt: Generators::HTMLGeneratorInOne
mt: instance
fn: new
fs: new(*args)
fd: 
pt: Generators::HTMLGeneratorInOne
mt: class
fn: add_line_numbers
fs: add_line_numbers(src)
fd: we rely on the fact that the first line of a source code listing has
pt: Generators::HtmlMethod
mt: instance
fn: aliases
fs: aliases()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: all_methods
fs: all_methods()
fd: 
pt: Generators::HtmlMethod
mt: class
fn: aref
fs: aref()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: as_href
fs: as_href(from_path)
fd: return a reference to outselves to be used as an href= the form depends on whether we're all in one file or in multiple files
pt: Generators::HtmlMethod
mt: instance
fn: call_seq
fs: call_seq()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: create_source_code_file
fs: create_source_code_file(code_body)
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: description
fs: description()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: document_self
fs: document_self()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: find_symbol
fs: find_symbol(symbol, method=nil)
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: index_name
fs: index_name()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: markup_code
fs: markup_code(tokens)
fd: Given a sequence of source tokens, mark up the source code to make it look purty.
pt: Generators::HtmlMethod
mt: instance
fn: name
fs: name()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: new
fs: new(context, html_class, options)
fd: 
pt: Generators::HtmlMethod
mt: class
fn: params
fs: params()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: parent_name
fs: parent_name()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: path
fs: path()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: reset
fs: reset()
fd: 
pt: Generators::HtmlMethod
mt: class
fn: section
fs: section()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: singleton
fs: singleton()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: visibility
fs: visibility()
fd: 
pt: Generators::HtmlMethod
mt: instance
fn: gen_url
fs: gen_url(url, text)
fd: "Generate a hyperlink for url, labeled with text. Handle the special cases for img: and link: described under handle_special_HYPEDLINK"
pt: Generators::HyperlinkHtml
mt: instance
fn: handle_special_CROSSREF
fs: handle_special_CROSSREF(special)
fd: "We're invoked when any text matches the CROSSREF pattern (defined in MarkUp). If we fine the corresponding reference, generate a hyperlink. If the name we're looking for contains no punctuation, we look for it up the module/class chain. For example, HyperlinkHtml is found, even without the Generators:: prefix, because we look for it in module Generators first."
pt: Generators::HyperlinkHtml
mt: instance
fn: handle_special_HYPERLINK
fs: handle_special_HYPERLINK(special)
fd: "And we're invoked with a potential external hyperlink mailto: just gets inserted. http: links are checked to see if they reference an image. If so, that image gets inserted using an &lt;img&gt; tag. Otherwise a conventional &lt;a href&gt; is used. We also support a special type of hyperlink, link:, which is a reference to a local file whose path is relative to the --op directory."
pt: Generators::HyperlinkHtml
mt: instance
fn: handle_special_TIDYLINK
fs: handle_special_TIDYLINK(special)
fd: HEre's a hypedlink where the label is different to the URL
pt: Generators::HyperlinkHtml
mt: instance
fn: new
fs: new(from_path, context)
fd: We need to record the html path of our caller so we can generate correct relative paths for any hyperlinks that we find
pt: Generators::HyperlinkHtml
mt: class
fn: cvs_url
fs: cvs_url(url, full_path)
fd: Build a webcvs URL with the given 'url' argument. URLs with a '%s' in them get the file's path sprintfed into them; otherwise they're just catenated together.
pt: Generators::MarkUp
mt: instance
fn: markup
fs: markup(str, remove_para=false)
fd: Convert a string in markup format into HTML. We keep a cached SimpleMarkup object lying around after the first time we're called per object.
pt: Generators::MarkUp
mt: instance
fn: style_url
fs: style_url(path, css_name=nil)
fd: Qualify a stylesheet URL; if if css_name does not begin with '/' or 'http[s]://', prepend a prefix relative to path. Otherwise, return it unmodified.
pt: Generators::MarkUp
mt: instance
fn: for
fs: for(options)
fd: Generators may need to return specific subclasses depending on the options they are passed. Because of this we create them using a factory
pt: Generators::RIGenerator
mt: class
fn: generate
fs: generate(toplevels)
fd: Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information.
pt: Generators::RIGenerator
mt: instance
fn: generate_class_info
fs: generate_class_info(cls)
fd: 
pt: Generators::RIGenerator
mt: instance
fn: generate_method_info
fs: generate_method_info(cls_desc, method)
fd: 
pt: Generators::RIGenerator
mt: instance
fn: new
fs: new(options)
fd: Set up a new HTML generator. Basically all we do here is load up the correct output temlate
pt: Generators::RIGenerator
mt: class
fn: process_class
fs: process_class(from_class)
fd: 
pt: Generators::RIGenerator
mt: instance
fn: build_class_list
fs: build_class_list(from, html_file, class_dir)
fd: 
pt: Generators::XMLGenerator
mt: instance
fn: build_indices
fs: build_indices()
fd: "Generate:"
pt: Generators::XMLGenerator
mt: instance
fn: for
fs: for(options)
fd: Standard generator factory
pt: Generators::XMLGenerator
mt: class
fn: gen_an_index
fs: gen_an_index(collection, title)
fd: 
pt: Generators::XMLGenerator
mt: instance
fn: gen_class_index
fs: gen_class_index()
fd: 
pt: Generators::XMLGenerator
mt: instance
fn: gen_file_index
fs: gen_file_index()
fd: 
pt: Generators::XMLGenerator
mt: instance
fn: gen_into
fs: gen_into(list)
fd: 
pt: Generators::XMLGenerator
mt: instance
fn: gen_method_index
fs: gen_method_index()
fd: 
pt: Generators::XMLGenerator
mt: instance
fn: generate
fs: generate(info)
fd: Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information.
pt: Generators::XMLGenerator
mt: instance
fn: generate_xml
fs: generate_xml()
fd: Generate all the HTML. For the one-file case, we generate all the information in to one big hash
pt: Generators::XMLGenerator
mt: instance
fn: new
fs: new(*args)
fd: 
pt: Generators::XMLGenerator
mt: class
fn: each
fs: each()
fd: Iterator version of `get'.
pt: GetoptLong
mt: instance
fn: each_option
fs: each_option()
fd: "Alias for #each"
pt: GetoptLong
mt: instance
fn: error_message
fs: error_message()
fd: Return the appropriate error message in POSIX-defined format. If no error has occurred, returns nil.
pt: GetoptLong
mt: instance
fn: get
fs: get()
fd: Get next option name and its argument, as an Array of two elements.
pt: GetoptLong
mt: instance
fn: get_option
fs: get_option()
fd: "Alias for #get"
pt: GetoptLong
mt: instance
fn: new
fs: new(*arguments)
fd: Set up option processing.
pt: GetoptLong
mt: class
fn: ordering=
fs: ordering=(ordering)
fd: Set the handling of the ordering of options and arguments. A RuntimeError is raised if option processing has already started.
pt: GetoptLong
mt: instance
fn: set_options
fs: set_options(*arguments)
fd: Set options. Takes the same argument as GetoptLong.new.
pt: GetoptLong
mt: instance
fn: terminate
fs: terminate()
fd: Explicitly terminate option processing.
pt: GetoptLong
mt: instance
fn: terminated?
fs: terminated?()
fd: Returns true if option processing has terminated, false otherwise.
pt: GetoptLong
mt: instance
fn: connections
fs: connections()
fd: 
pt: GServer
mt: instance
fn: in_service?
fs: in_service?(port, host = DEFAULT_HOST)
fd: 
pt: GServer
mt: class
fn: join
fs: join()
fd: 
pt: GServer
mt: instance
fn: new
fs: new(port, host = DEFAULT_HOST, maxConnections = 4, stdlog = $stderr, audit = false, debug = false)
fd: 
pt: GServer
mt: class
fn: serve
fs: serve(io)
fd: 
pt: GServer
mt: instance
fn: shutdown
fs: shutdown()
fd: 
pt: GServer
mt: instance
fn: start
fs: start(maxConnections = -1)
fd: 
pt: GServer
mt: instance
fn: stop
fs: stop(port, host = DEFAULT_HOST)
fd: 
pt: GServer
mt: class
fn: stop
fs: stop()
fd: 
pt: GServer
mt: instance
fn: stopped?
fs: stopped?()
fd: 
pt: GServer
mt: instance
fn: clear
fs: clear
fd: Removes all key-value pairs from hsh.
pt: Hash
mt: instance
fn: default=
fs: default=
fd: Sets the default value, the value returned for a key that does not exist in the hash. It is not possible to set the a default to a Proc that will be executed on each key lookup.
pt: Hash
mt: instance
fn: default
fs: default(key=nil)
fd: Returns the default value, the value that would be returned by hsh[key] if key did not exist in hsh. See also Hash::new and Hash#default=.
pt: Hash
mt: instance
fn: default_proc
fs: default_proc
fd: If Hash::new was invoked with a block, return that block, otherwise return nil.
pt: Hash
mt: instance
fn: delete
fs: delete(key)
fd: Deletes and returns a key-value pair from hsh whose key is equal to key. If the key is not found, returns the default value. If the optional code block is given and the key is not found, pass in the key and return the result of block.
pt: Hash
mt: instance
fn: delete_if
fs: delete_if
fd: Deletes every key-value pair from hsh for which block evaluates to true.
pt: Hash
mt: instance
fn: each
fs: each
fd: Calls block once for each key in hsh, passing the key and value to the block as a two-element array. Because of the assignment semantics of block parameters, these elements will be split out if the block has two formal parameters. Also see Hash.each_pair, which will be marginally more efficient for blocks with two parameters.
pt: Hash
mt: instance
fn: each_key
fs: each_key
fd: Calls block once for each key in hsh, passing the key as a parameter.
pt: Hash
mt: instance
fn: each_pair
fs: each_pair
fd: Calls block once for each key in hsh, passing the key and value as parameters.
pt: Hash
mt: instance
fn: each_value
fs: each_value
fd: Calls block once for each key in hsh, passing the value as a parameter.
pt: Hash
mt: instance
fn: empty?
fs: empty?
fd: Returns true if hsh contains no key-value pairs.
pt: Hash
mt: instance
fn: fetch
fs: fetch(key [, default] )
fd: "Returns a value from the hash for the given key. If the key can't be found, there are several options: With no other arguments, it will raise an IndexError exception; if default is given, then that will be returned; if the optional code block is specified, then that will be run and its result returned."
pt: Hash
mt: instance
fn: has_key?
fs: has_key?(key)
fd: Returns true if the given key is present in hsh.
pt: Hash
mt: instance
fn: has_value?
fs: has_value?(value)
fd: Returns true if the given value is present for some key in hsh.
pt: Hash
mt: instance
fn: include?
fs: include?(key)
fd: Returns true if the given key is present in hsh.
pt: Hash
mt: instance
fn: index
fs: index(value)
fd: Returns the key for a given value. If not found, returns nil.
pt: Hash
mt: instance
fn: indexes
fs: indexes(key, ...)
fd: Deprecated in favor of Hash#select.
pt: Hash
mt: instance
fn: indices
fs: indices(key, ...)
fd: Deprecated in favor of Hash#select.
pt: Hash
mt: instance
fn: initialize_copy
fs: initialize_copy  hsh.replace(other_hash)
fd: Replaces the contents of hsh with the contents of other_hash.
pt: Hash
mt: instance
fn: inspect
fs: inspect
fd: Return the contents of this hash as a string.
pt: Hash
mt: instance
fn: invert
fs: invert
fd: Returns a new hash created by using hsh's values as keys, and the keys as values.
pt: Hash
mt: instance
fn: key?
fs: key?(key)
fd: Returns true if the given key is present in hsh.
pt: Hash
mt: instance
fn: keys
fs: keys
fd: Returns a new array populated with the keys from this hash. See also Hash#values.
pt: Hash
mt: instance
fn: length
fs: length
fd: Returns the number of key-value pairs in the hash.
pt: Hash
mt: instance
fn: member?
fs: member?(key)
fd: Returns true if the given key is present in hsh.
pt: Hash
mt: instance
fn: merge!
fs: merge!(other_hash)
fd: Adds the contents of other_hash to hsh, overwriting entries with duplicate keys with those from other_hash.
pt: Hash
mt: instance
fn: merge
fs: merge(other_hash)
fd: Returns a new hash containing the contents of other_hash and the contents of hsh, overwriting entries in hsh with duplicate keys with those from other_hash.
pt: Hash
mt: instance
fn: new
fs: new(obj)
fd: Returns a new, empty hash. If this hash is subsequently accessed by a key that doesn't correspond to a hash entry, the value returned depends on the style of new used to create the hash. In the first form, the access returns nil. If obj is specified, this single object will be used for all default values. If a block is specified, it will be called with the hash object and the key, and should return the default value. It is the block's responsibility to store the value in the hash if required.
pt: Hash
mt: class
fn: pretty_print
fs: pretty_print(q)
fd: 
pt: Hash
mt: instance
fn: pretty_print_cycle
fs: pretty_print_cycle(q)
fd: 
pt: Hash
mt: instance
fn: rehash
fs: rehash
fd: Rebuilds the hash based on the current hash values for each key. If values of key objects have changed since they were inserted, this method will reindex hsh. If Hash#rehash is called while an iterator is traversing the hash, an IndexError will be raised in the iterator.
pt: Hash
mt: instance
fn: reject!
fs: reject!
fd: Equivalent to Hash#delete_if, but returns nil if no changes were made.
pt: Hash
mt: instance
fn: reject
fs: reject
fd: Same as Hash#delete_if, but works on (and returns) a copy of the hsh. Equivalent to hsh.dup.delete_if.
pt: Hash
mt: instance
fn: replace
fs: replace(other_hash)
fd: Replaces the contents of hsh with the contents of other_hash.
pt: Hash
mt: instance
fn: select
fs: select
fd: Returns a new array consisting of [key,value] pairs for which the block returns true. Also see Hash.values_at.
pt: Hash
mt: instance
fn: shift
fs: shift
fd: Removes a key-value pair from hsh and returns it as the two-item array [ key, value ], or the hash's default value if the hash is empty.
pt: Hash
mt: instance
fn: size
fs: size
fd: Returns the number of key-value pairs in the hash.
pt: Hash
mt: instance
fn: sort
fs: sort
fd: Converts hsh to a nested array of [ key, value ] arrays and sorts it, using Array#sort.
pt: Hash
mt: instance
fn: store
fs: store(key, value)
fd: Element Assignment---Associates the value given by value with the key given by key. key should not have its value changed while it is in use as a key (a String passed as a key will be duplicated and frozen).
pt: Hash
mt: instance
fn: to_a
fs: to_a
fd: Converts hsh to a nested array of [ key, value ] arrays.
pt: Hash
mt: instance
fn: to_hash
fs: to_hash
fd: Returns self.
pt: Hash
mt: instance
fn: to_s
fs: to_s
fd: Converts hsh to a string by converting the hash to an array of [ key, value ] pairs and then converting that array to a string using Array#join with the default separator.
pt: Hash
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Hash
mt: instance
fn: update
fs: update(other_hash)
fd: Adds the contents of other_hash to hsh, overwriting entries with duplicate keys with those from other_hash.
pt: Hash
mt: instance
fn: value?
fs: value?(value)
fd: Returns true if the given value is present for some key in hsh.
pt: Hash
mt: instance
fn: values
fs: values
fd: Returns a new array populated with the values from hsh. See also Hash#keys.
pt: Hash
mt: instance
fn: values_at
fs: values_at(key, ...)
fd: Return an array containing the values associated with the given keys. Also see Hash.select.
pt: Hash
mt: instance
fn: yaml_initialize
fs: yaml_initialize( tag, val )
fd: 
pt: Hash
mt: instance
fn: charset_map
fs: charset_map
fd: Returns the map from canonical name to system dependent name.
pt: Iconv
mt: class
fn: close
fs: close()
fd: Finishes conversion.
pt: Iconv
mt: instance
fn: conv
fs: conv" Iconv.conv(to, from, str)
fd: "Document-method: Iconv::conv"
pt: Iconv
mt: class
fn: failed
fs: failed
fd: Returns substring of the original string passed to Iconv that starts at the character caused the exception.
pt: Iconv::Failure
mt: instance
fn: inspect
fs: inspect
fd: "Returns inspected string like as: #&lt;class: success, failed&gt;"
pt: Iconv::Failure
mt: instance
fn: new
fs: new" Iconv.new(to, from)
fd: Creates new code converter from a coding-system designated with from to another one designated with to.
pt: Iconv::Failure
mt: class
fn: success
fs: success
fd: Returns string(s) translated successfully until the exception occurred.
pt: Iconv::Failure
mt: instance
fn: iconv
fs: iconv" Iconv.iconv(to, from, *strs)
fd: Shorthand for
pt: Iconv
mt: class
fn: iconv
fs: iconv" Iconv.iconv(to, from, *strs)
fd: Shorthand for
pt: Iconv
mt: instance
fn: new
fs: new" Iconv.new(to, from)
fd: Creates new code converter from a coding-system designated with from to another one designated with to.
pt: Iconv
mt: class
fn: open
fs: open" Iconv.open(to, from)
fd: Equivalent to Iconv.new except that when it is called with a block, it yields with the new instance and closes it, and returns the result which returned from the block.
pt: Iconv
mt: class
fn: ceil
fs: ceil
fd: As int is already an Integer, all these methods simply return the receiver.
pt: Integer
mt: instance
fn: chr
fs: chr
fd: Returns a string containing the ASCII character represented by the receiver's value.
pt: Integer
mt: instance
fn: denominator
fs: denominator()
fd: In an integer, the denominator is 1. Therefore, this method returns 1.
pt: Integer
mt: instance
fn: downto
fs: downto(limit)
fd: Iterates block, passing decreasing values from int down to and including limit.
pt: Integer
mt: instance
fn: floor
fs: floor
fd: As int is already an Integer, all these methods simply return the receiver.
pt: Integer
mt: instance
fn: from_prime_division
fs: from_prime_division(pd)
fd: 
pt: Integer
mt: class
fn: gcd
fs: gcd(other)
fd: Returns the greatest common denominator of the two numbers (self and n).
pt: Integer
mt: instance
fn: gcd2
fs: gcd2(int)
fd: 
pt: Integer
mt: instance
fn: gcdlcm
fs: gcdlcm(other)
fd: "Returns the GCD and the LCM (see #gcd and #lcm) of the two arguments (self and other). This is more efficient than calculating them separately."
pt: Integer
mt: instance
fn: induced_from
fs: induced_from(obj)
fd: Convert obj to an Integer.
pt: Integer
mt: class
fn: integer?
fs: integer?
fd: Always returns true.
pt: Integer
mt: instance
fn: lcm
fs: lcm(other)
fd: Returns the lowest common multiple (LCM) of the two arguments (self and other).
pt: Integer
mt: instance
fn: next
fs: next
fd: Returns the Integer equal to int + 1.
pt: Integer
mt: instance
fn: new
fs: new
fd: 
pt: Integer
mt: class
fn: numerator
fs: numerator()
fd: In an integer, the value is the numerator of its rational equivalent. Therefore, this method returns self.
pt: Integer
mt: instance
fn: prime_division
fs: prime_division()
fd: 
pt: Integer
mt: instance
fn: round
fs: round
fd: As int is already an Integer, all these methods simply return the receiver.
pt: Integer
mt: instance
fn: succ
fs: succ
fd: Returns the Integer equal to int + 1.
pt: Integer
mt: instance
fn: times
fs: times
fd: Iterates block int times, passing in values from zero to int - 1.
pt: Integer
mt: instance
fn: to_i
fs: to_i
fd: As int is already an Integer, all these methods simply return the receiver.
pt: Integer
mt: instance
fn: to_int
fs: to_int
fd: As int is already an Integer, all these methods simply return the receiver.
pt: Integer
mt: instance
fn: to_r
fs: to_r()
fd: Returns a Rational representation of this integer.
pt: Integer
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Integer
mt: instance
fn: truncate
fs: truncate
fd: As int is already an Integer, all these methods simply return the receiver.
pt: Integer
mt: instance
fn: upto
fs: upto(limit)
fd: Iterates block, passing in integer values from int up to and including limit.
pt: Integer
mt: instance
fn: binmode
fs: binmode
fd: Puts ios into binary mode. This is useful only in MS-DOS/Windows environments. Once a stream is in binary mode, it cannot be reset to nonbinary mode.
pt: IO
mt: instance
fn: close
fs: close
fd: Closes ios and flushes any pending writes to the operating system. The stream is unavailable for any further data operations; an IOError is raised if such an attempt is made. I/O streams are automatically closed when they are claimed by the garbage collector.
pt: IO
mt: instance
fn: close_read
fs: close_read
fd: Closes the read end of a duplex I/O stream (i.e., one that contains both a read and a write stream, such as a pipe). Will raise an IOError if the stream is not duplexed.
pt: IO
mt: instance
fn: close_write
fs: close_write
fd: Closes the write end of a duplex I/O stream (i.e., one that contains both a read and a write stream, such as a pipe). Will raise an IOError if the stream is not duplexed.
pt: IO
mt: instance
fn: closed?
fs: closed?
fd: Returns true if ios is completely closed (for duplex streams, both reader and writer), false otherwise.
pt: IO
mt: instance
fn: each
fs: each(sep_string=$/)
fd: Executes the block for every line in ios, where lines are separated by sep_string. ios must be opened for reading or an IOError will be raised.
pt: IO
mt: instance
fn: each_byte
fs: each_byte
fd: Calls the given block once for each byte (0..255) in ios, passing the byte as an argument. The stream must be opened for reading or an IOError will be raised.
pt: IO
mt: instance
fn: each_line
fs: each_line(sep_string=$/)
fd: Executes the block for every line in ios, where lines are separated by sep_string. ios must be opened for reading or an IOError will be raised.
pt: IO
mt: instance
fn: eof?
fs: eof?
fd: Returns true if ios is at end of file that means there are no more data to read. The stream must be opened for reading or an IOError will be raised.
pt: IO
mt: instance
fn: eof
fs: eof
fd: Returns true if ios is at end of file that means there are no more data to read. The stream must be opened for reading or an IOError will be raised.
pt: IO
mt: instance
fn: fcntl
fs: fcntl(integer_cmd, arg)
fd: Provides a mechanism for issuing low-level commands to control or query file-oriented I/O streams. Arguments and results are platform dependent. If arg is a number, its value is passed directly. If it is a string, it is interpreted as a binary sequence of bytes (Array#pack might be a useful way to build this string). On Unix platforms, see fcntl(2) for details. Not implemented on all platforms.
pt: IO
mt: instance
fn: fileno
fs: fileno
fd: Returns an integer representing the numeric file descriptor for ios.
pt: IO
mt: instance
fn: flush
fs: flush
fd: Flushes any buffered data within ios to the underlying operating system (note that this is Ruby internal buffering only; the OS may buffer the data as well).
pt: IO
mt: instance
fn: for_fd
fs: for_fd(fd, mode)
fd: Synonym for IO::new.
pt: IO
mt: class
fn: foreach
fs: foreach(name, sep_string=$/)
fd: Executes the block for every line in the named I/O port, where lines are separated by sep_string.
pt: IO
mt: class
fn: fsync
fs: fsync
fd: Immediately writes all buffered data in ios to disk. Returns nil if the underlying operating system does not support fsync(2). Note that fsync differs from using IO#sync=. The latter ensures that data is flushed from Ruby's buffers, but doesn't not guarantee that the underlying operating system actually writes it to disk.
pt: IO
mt: instance
fn: getc
fs: getc
fd: Gets the next 8-bit byte (0..255) from ios. Returns nil if called at end of file.
pt: IO
mt: instance
fn: gets
fs: gets(sep_string=$/)
fd: Reads the next ``line'' from the I/O stream; lines are separated by sep_string. A separator of nil reads the entire contents, and a zero-length separator reads the input a paragraph at a time (two successive newlines in the input separate paragraphs). The stream must be opened for reading or an IOError will be raised. The line read in will be returned and also assigned to $_. Returns nil if called at end of file.
pt: IO
mt: instance
fn: inspect
fs: inspect
fd: Return a string describing this IO object.
pt: IO
mt: instance
fn: ioctl
fs: ioctl(integer_cmd, arg)
fd: Provides a mechanism for issuing low-level commands to control or query I/O devices. Arguments and results are platform dependent. If arg is a number, its value is passed directly. If it is a string, it is interpreted as a binary sequence of bytes. On Unix platforms, see ioctl(2) for details. Not implemented on all platforms.
pt: IO
mt: instance
fn: isatty
fs: isatty
fd: Returns true if ios is associated with a terminal device (tty), false otherwise.
pt: IO
mt: instance
fn: lineno=
fs: lineno=
fd: Manually sets the current line number to the given value. $. is updated only on the next read.
pt: IO
mt: instance
fn: lineno
fs: lineno
fd: Returns the current line number in ios. The stream must be opened for reading. lineno counts the number of times gets is called, rather than the number of newlines encountered. The two values will differ if gets is called with a separator other than newline. See also the $. variable.
pt: IO
mt: instance
fn: new
fs: new(fd, mode_string)
fd: Returns a new IO object (a stream) for the given integer file descriptor and mode string. See also IO#fileno and IO::for_fd.
pt: IO
mt: class
fn: open
fs: open(fd, mode_string="r" )
fd: With no associated block, open is a synonym for IO::new. If the optional code block is given, it will be passed io as an argument, and the IO object will automatically be closed when the block terminates. In this instance, IO::open returns the value of the block.
pt: IO
mt: class
fn: pid
fs: pid
fd: Returns the process ID of a child process associated with ios. This will be set by IO::popen.
pt: IO
mt: instance
fn: pipe
fs: pipe
fd: "Creates a pair of pipe endpoints (connected to each other) and returns them as a two-element array of IO objects: [ read_file, write_file ]. Not available on all platforms."
pt: IO
mt: class
fn: popen
fs: popen(cmd_string, mode="r" )
fd: Runs the specified command string as a subprocess; the subprocess's standard input and output will be connected to the returned IO object. If cmd_string starts with a ``-'', then a new instance of Ruby is started as the subprocess. The default mode for the new file object is ``r'', but mode may be set to any of the modes listed in the description for class IO.
pt: IO
mt: class
fn: pos=
fs: pos=
fd: Seeks to the given position (in bytes) in ios.
pt: IO
mt: instance
fn: pos
fs: pos
fd: Returns the current offset (in bytes) of ios.
pt: IO
mt: instance
fn: print
fs: print()
fd: Writes the given object(s) to ios. The stream must be opened for writing. If the output record separator ($\) is not nil, it will be appended to the output. If no arguments are given, prints $_. Objects that aren't strings will be converted by calling their to_s method. With no argument, prints the contents of the variable $_. Returns nil.
pt: IO
mt: instance
fn: printf
fs: printf(format_string [, obj, ...] )
fd: Formats and writes to ios, converting parameters under control of the format string. See Kernel#sprintf for details.
pt: IO
mt: instance
fn: putc
fs: putc(obj)
fd: If obj is Numeric, write the character whose code is obj, otherwise write the first character of the string representation of obj to ios.
pt: IO
mt: instance
fn: puts
fs: puts(obj, ...)
fd: Writes the given objects to ios as with IO#print. Writes a record separator (typically a newline) after any that do not already end with a newline sequence. If called with an array argument, writes each element on a new line. If called without arguments, outputs a single record separator.
pt: IO
mt: instance
fn: read
fs: read(name, [length [, offset]] )
fd: Opens the file, optionally seeks to the given offset, then returns length bytes (defaulting to the rest of the file). read ensures the file is closed before returning.
pt: IO
mt: class
fn: read
fs: read([length [, buffer]])
fd: Reads at most length bytes from the I/O stream, or to the end of file if length is omitted or is nil. length must be a non-negative integer or nil. If the optional buffer argument is present, it must reference a String, which will receive the data.
pt: IO
mt: instance
fn: read_nonblock
fs: read_nonblock(maxlen)
fd: Reads at most maxlen bytes from ios using read(2) system call after O_NONBLOCK is set for the underlying file descriptor.
pt: IO
mt: instance
fn: readbytes
fs: readbytes(n)
fd: Reads exactly n bytes.
pt: IO
mt: instance
fn: readchar
fs: readchar
fd: Reads a character as with IO#getc, but raises an EOFError on end of file.
pt: IO
mt: instance
fn: readline
fs: readline(sep_string=$/)
fd: Reads a line as with IO#gets, but raises an EOFError on end of file.
pt: IO
mt: instance
fn: readlines
fs: readlines(name, sep_string=$/)
fd: Reads the entire file specified by name as individual lines, and returns those lines in an array. Lines are separated by sep_string.
pt: IO
mt: class
fn: readlines
fs: readlines(sep_string=$/)
fd: Reads all of the lines in ios, and returns them in anArray. Lines are separated by the optional sep_string. If sep_string is nil, the rest of the stream is returned as a single record. The stream must be opened for reading or an IOError will be raised.
pt: IO
mt: instance
fn: readpartial
fs: readpartial(maxlen)
fd: Reads at most maxlen bytes from the I/O stream. It blocks only if ios has no data immediately available. It doesn't block if some data available. If the optional outbuf argument is present, it must reference a String, which will receive the data. It raises EOFError on end of file.
pt: IO
mt: instance
fn: reopen
fs: reopen(other_IO)
fd: Reassociates ios with the I/O stream given in other_IO or to a new stream opened on path. This may dynamically change the actual class of this stream.
pt: IO
mt: instance
fn: rewind
fs: rewind
fd: Positions ios to the beginning of input, resetting lineno to zero.
pt: IO
mt: instance
fn: scanf
fs: scanf(str,&b)
fd: The trick here is doing a match where you grab one <b>line</b> of input at a time. The linebreak may or may not occur at the boundary where the string matches a format specifier. And if it does, some rule about whitespace may or may not be in effect...
pt: IO
mt: instance
fn: seek
fs: seek(amount, whence=SEEK_SET)
fd: "Seeks to a given offset anInteger in the stream according to the value of whence:"
pt: IO
mt: instance
fn: select
fs: select(read_array 
fd: See Kernel#select.
pt: IO
mt: class
fn: stat
fs: stat
fd: Returns status information for ios as an object of type File::Stat.
pt: IO
mt: instance
fn: sync=
fs: sync=
fd: Sets the ``sync mode'' to true or false. When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered internally. Returns the new state. See also IO#fsync.
pt: IO
mt: instance
fn: sync
fs: sync
fd: Returns the current ``sync mode'' of ios. When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered by Ruby internally. See also IO#fsync.
pt: IO
mt: instance
fn: sysopen
fs: sysopen(path, [mode, [perm]])
fd: Opens the given path, returning the underlying file descriptor as a Fixnum.
pt: IO
mt: class
fn: sysread
fs: sysread(integer )
fd: Reads integer bytes from ios using a low-level read and returns them as a string. Do not mix with other methods that read from ios or you may get unpredictable results. Raises SystemCallError on error and EOFError at end of file.
pt: IO
mt: instance
fn: sysseek
fs: sysseek(offset, whence=SEEK_SET)
fd: Seeks to a given offset in the stream according to the value of whence (see IO#seek for values of whence). Returns the new offset into the file.
pt: IO
mt: instance
fn: syswrite
fs: syswrite(string)
fd: Writes the given string to ios using a low-level write. Returns the number of bytes written. Do not mix with other methods that write to ios or you may get unpredictable results. Raises SystemCallError on error.
pt: IO
mt: instance
fn: tell
fs: tell
fd: Returns the current offset (in bytes) of ios.
pt: IO
mt: instance
fn: to_i
fs: to_i()
fd: "Alias for #fileno"
pt: IO
mt: instance
fn: to_io
fs: to_io
fd: Returns ios.
pt: IO
mt: instance
fn: tty?
fs: tty?
fd: Returns true if ios is associated with a terminal device (tty), false otherwise.
pt: IO
mt: instance
fn: ungetc
fs: ungetc(integer)
fd: Pushes back one character (passed as a parameter) onto ios, such that a subsequent buffered read will return it. Only one character may be pushed back before a subsequent read operation (that is, you will be able to read only the last of several characters that have been pushed back). Has no effect with unbuffered reads (such as IO#sysread).
pt: IO
mt: instance
fn: write
fs: write(string)
fd: Writes the given string to ios. The stream must be opened for writing. If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written.
pt: IO
mt: instance
fn: write_nonblock
fs: write_nonblock(string)
fd: Writes the given string to ios using write(2) system call after O_NONBLOCK is set for the underlying file descriptor.
pt: IO
mt: instance
fn: hton
fs: hton()
fd: Returns a network byte ordered string form of the IP address.
pt: IPAddr
mt: instance
fn: include?
fs: include?(other)
fd: Returns true if the given ipaddr is in the range.
pt: IPAddr
mt: instance
fn: inspect
fs: inspect()
fd: "Returns a string containing a human-readable representation of the ipaddr. (&quot;#&lt;IPAddr: family:address/mask&gt;&quot;)"
pt: IPAddr
mt: instance
fn: ip6_arpa
fs: ip6_arpa()
fd: Returns a string for DNS reverse lookup compatible with RFC3172.
pt: IPAddr
mt: instance
fn: ip6_int
fs: ip6_int()
fd: Returns a string for DNS reverse lookup compatible with RFC1886.
pt: IPAddr
mt: instance
fn: ipv4?
fs: ipv4?()
fd: Returns true if the ipaddr is an IPv4 address.
pt: IPAddr
mt: instance
fn: ipv4_compat?
fs: ipv4_compat?()
fd: Returns true if the ipaddr is an IPv4-compatible IPv6 address.
pt: IPAddr
mt: instance
fn: ipv4_compat
fs: ipv4_compat()
fd: Returns a new ipaddr built by converting the native IPv4 address into an IPv4-compatible IPv6 address.
pt: IPAddr
mt: instance
fn: ipv4_mapped?
fs: ipv4_mapped?()
fd: Returns true if the ipaddr is an IPv4-mapped IPv6 address.
pt: IPAddr
mt: instance
fn: ipv4_mapped
fs: ipv4_mapped()
fd: Returns a new ipaddr built by converting the native IPv4 address into an IPv4-mapped IPv6 address.
pt: IPAddr
mt: instance
fn: ipv6?
fs: ipv6?()
fd: Returns true if the ipaddr is an IPv6 address.
pt: IPAddr
mt: instance
fn: mask
fs: mask(prefixlen)
fd: Returns a new ipaddr built by masking IP address with the given prefixlen/netmask. (e.g. 8, 64, &quot;255.255.255.0&quot;, etc.)
pt: IPAddr
mt: instance
fn: native
fs: native()
fd: Returns a new ipaddr built by converting the IPv6 address into a native IPv4 address. If the IP address is not an IPv4-mapped or IPv4-compatible IPv6 address, returns self.
pt: IPAddr
mt: instance
fn: new
fs: new(addr = '::', family = Socket::AF_UNSPEC)
fd: Creates a new ipaddr containing the given human readable form of an IP address. It also accepts `address/prefixlen' and `address/mask'. When prefixlen or mask is specified, it returns a masked ipaddr. IPv6 address may beenclosed with `[' and `]'.
pt: IPAddr
mt: class
fn: new_ntoh
fs: new_ntoh(addr)
fd: Creates a new ipaddr containing the given network byte ordered string form of an IP address.
pt: IPAddr
mt: class
fn: ntop
fs: ntop(addr)
fd: Convert a network byte ordered string form of an IP address into human readable form.
pt: IPAddr
mt: class
fn: reverse
fs: reverse()
fd: Returns a string for DNS reverse lookup. It returns a string in RFC3172 form for an IPv6 address.
pt: IPAddr
mt: instance
fn: to_i
fs: to_i()
fd: Returns the integer representation of the ipaddr.
pt: IPAddr
mt: instance
fn: to_s
fs: to_s()
fd: Returns a string containing the IP address representation.
pt: IPAddr
mt: instance
fn: to_string
fs: to_string()
fd: Returns a string containing the IP address representation in canonical form.
pt: IPAddr
mt: instance
fn: conf
fs: conf()
fd: 
pt: IRB
mt: class
fn: change_workspace
fs: change_workspace(*_main)
fd: 
pt: IRB::Context
mt: instance
fn: debug?
fs: debug?()
fd: 
pt: IRB::Context
mt: instance
fn: debug_level=
fs: debug_level=(value)
fd: 
pt: IRB::Context
mt: instance
fn: eval_history=
fs: eval_history=(no)
fd: 
pt: IRB::Context
mt: instance
fn: evaluate
fs: evaluate(line, line_no)
fd: 
pt: IRB::Context
mt: instance
fn: exit
fs: exit(ret = 0)
fd: 
pt: IRB::Context
mt: instance
fn: file_input?
fs: file_input?()
fd: 
pt: IRB::Context
mt: instance
fn: history_file=
fs: history_file=(hist)
fd: 
pt: IRB::Context
mt: instance
fn: history_file
fs: history_file()
fd: 
pt: IRB::Context
mt: instance
fn: home_workspace
fs: home_workspace()
fd: 
pt: IRB::Context
mt: instance
fn: init_save_history
fs: init_save_history()
fd: 
pt: IRB::Context
mt: instance
fn: inspect?
fs: inspect?()
fd: 
pt: IRB::Context
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: IRB::Context
mt: instance
fn: inspect_mode=
fs: inspect_mode=(opt)
fd: 
pt: IRB::Context
mt: instance
fn: irb_level
fs: irb_level()
fd: 
pt: IRB::Context
mt: instance
fn: main
fs: main()
fd: 
pt: IRB::Context
mt: instance
fn: math_mode=
fs: math_mode=(opt)
fd: 
pt: IRB::Context
mt: instance
fn: new
fs: new(irb, workspace = nil, input_method = nil, output_method = nil)
fd: "Arguments:"
pt: IRB::Context
mt: class
fn: pop_workspace
fs: pop_workspace()
fd: 
pt: IRB::Context
mt: instance
fn: prompt_mode=
fs: prompt_mode=(mode)
fd: 
pt: IRB::Context
mt: instance
fn: prompting?
fs: prompting?()
fd: 
pt: IRB::Context
mt: instance
fn: push_workspace
fs: push_workspace(*_main)
fd: 
pt: IRB::Context
mt: instance
fn: save_history=
fs: save_history=(val)
fd: 
pt: IRB::Context
mt: instance
fn: save_history
fs: save_history()
fd: 
pt: IRB::Context
mt: instance
fn: set_last_value
fs: set_last_value(value)
fd: 
pt: IRB::Context
mt: instance
fn: to_s
fs: to_s()
fd: "Alias for #inspect"
pt: IRB::Context
mt: instance
fn: use_loader=
fs: use_loader=(opt)
fd: 
pt: IRB::Context
mt: instance
fn: use_loader?
fs: use_loader?()
fd: "Alias for #use_loader"
pt: IRB::Context
mt: instance
fn: use_loader
fs: use_loader()
fd: 
pt: IRB::Context
mt: instance
fn: use_readline=
fs: use_readline=(opt)
fd: 
pt: IRB::Context
mt: instance
fn: use_tracer=
fs: use_tracer=(opt)
fd: 
pt: IRB::Context
mt: instance
fn: verbose?
fs: verbose?()
fd: 
pt: IRB::Context
mt: instance
fn: workspaces
fs: workspaces()
fd: 
pt: IRB::Context
mt: instance
fn: def_extend_command
fs: def_extend_command(cmd_name, load_file, *aliases)
fd: 
pt: IRB::ContextExtender
mt: class
fn: install_extend_commands
fs: install_extend_commands()
fd: 
pt: IRB::ContextExtender
mt: class
fn: CurrentContext
fs: CurrentContext()
fd: 
pt: IRB
mt: class
fn: delete_caller
fs: delete_caller()
fd: 
pt: IRB
mt: class
fn: execute
fs: execute(*obj)
fd: 
pt: IRB::ExtendCommand::ChangeWorkspace
mt: instance
fn: execute
fs: execute(*obj)
fd: 
pt: IRB::ExtendCommand::CurrentWorkingWorkspace
mt: instance
fn: execute
fs: execute(key)
fd: 
pt: IRB::ExtendCommand::Foreground
mt: instance
fn: execute
fs: execute(&block)
fd: 
pt: IRB::ExtendCommand::Fork
mt: instance
fn: execute
fs: execute(context, *names)
fd: 
pt: IRB::ExtendCommand::Help
mt: class
fn: execute
fs: execute(*obj)
fd: 
pt: IRB::ExtendCommand::IrbCommand
mt: instance
fn: execute
fs: execute()
fd: 
pt: IRB::ExtendCommand::Jobs
mt: instance
fn: execute
fs: execute(*keys)
fd: 
pt: IRB::ExtendCommand::Kill
mt: instance
fn: execute
fs: execute(file_name, priv = nil)
fd: 
pt: IRB::ExtendCommand::Load
mt: instance
fn: execute
fs: execute(conf, *opts)
fd: 
pt: IRB::ExtendCommand::Nop
mt: class
fn: execute
fs: execute(*opts)
fd: 
pt: IRB::ExtendCommand::Nop
mt: instance
fn: irb
fs: irb()
fd: 
pt: IRB::ExtendCommand::Nop
mt: instance
fn: new
fs: new(conf)
fd: 
pt: IRB::ExtendCommand::Nop
mt: class
fn: execute
fs: execute(*obj)
fd: 
pt: IRB::ExtendCommand::PopWorkspace
mt: instance
fn: execute
fs: execute(*obj)
fd: 
pt: IRB::ExtendCommand::PushWorkspace
mt: instance
fn: execute
fs: execute(file_name)
fd: 
pt: IRB::ExtendCommand::Require
mt: instance
fn: execute
fs: execute(file_name)
fd: 
pt: IRB::ExtendCommand::Source
mt: instance
fn: execute
fs: execute(*obj)
fd: 
pt: IRB::ExtendCommand::Workspaces
mt: instance
fn: def_extend_command
fs: def_extend_command(cmd_name, cmd_class, load_file = nil, *aliases)
fd: aliases = [commans_alias, flag], ...
pt: IRB::ExtendCommandBundle
mt: class
fn: extend_object
fs: extend_object(obj)
fd: 
pt: IRB::ExtendCommandBundle
mt: class
fn: install_alias_method
fs: install_alias_method(to, from, override = NO_OVERRIDE)
fd: override = {NO_OVERRIDE, OVERRIDE_PRIVATE_ONLY, OVERRIDE_ALL}
pt: IRB::ExtendCommandBundle
mt: instance
fn: install_extend_commands
fs: install_extend_commands()
fd: 
pt: IRB::ExtendCommandBundle
mt: class
fn: irb_context
fs: irb_context()
fd: 
pt: IRB::ExtendCommandBundle
mt: instance
fn: irb_exit
fs: irb_exit(ret = 0)
fd: 
pt: IRB::ExtendCommandBundle
mt: instance
fn: irb_load
fs: irb_load(*opts, &b)
fd: 
pt: IRB::ExtendCommandBundle
mt: instance
fn: irb_original_method_name
fs: irb_original_method_name(method_name)
fd: 
pt: IRB::ExtendCommandBundle
mt: class
fn: irb_require
fs: irb_require(*opts, &b)
fd: 
pt: IRB::ExtendCommandBundle
mt: instance
fn: eof?
fs: eof?()
fd: 
pt: IRB::FileInputMethod
mt: instance
fn: gets
fs: gets()
fd: 
pt: IRB::FileInputMethod
mt: instance
fn: new
fs: new(file)
fd: 
pt: IRB::FileInputMethod
mt: class
fn: bottom
fs: bottom(n = 0)
fd: singleton functions
pt: IRB::Frame
mt: class
fn: bottom
fs: bottom(n = 0)
fd: 
pt: IRB::Frame
mt: instance
fn: new
fs: new()
fd: 
pt: IRB::Frame
mt: class
fn: sender
fs: sender()
fd: 
pt: IRB::Frame
mt: class
fn: top
fs: top(n = 0)
fd: 
pt: IRB::Frame
mt: class
fn: top
fs: top(n = 0)
fd: 
pt: IRB::Frame
mt: instance
fn: trace_func
fs: trace_func(event, file, line, id, binding)
fd: 
pt: IRB::Frame
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: IRB::History
mt: instance
fn: new
fs: new(size = 16)
fd: 
pt: IRB::History
mt: class
fn: push
fs: push(no, val)
fd: 
pt: IRB::History
mt: instance
fn: size
fs: size(size)
fd: 
pt: IRB::History
mt: instance
fn: create_finalizer
fs: create_finalizer()
fd: 
pt: IRB::HistorySavingAbility
mt: class
fn: extended
fs: extended(obj)
fd: 
pt: IRB::HistorySavingAbility
mt: class
fn: load_history
fs: load_history()
fd: 
pt: IRB::HistorySavingAbility
mt: instance
fn: init_config
fs: init_config(ap_path)
fd: "@CONF default setting"
pt: IRB
mt: class
fn: init_error
fs: init_error()
fd: 
pt: IRB
mt: class
fn: initialize_tracer
fs: initialize_tracer()
fd: initialize tracing function
pt: IRB
mt: class
fn: select_message
fs: select_message(receiver, message, candidates)
fd: 
pt: IRB::InputCompletor
mt: class
fn: gets
fs: gets()
fd: 
pt: IRB::InputMethod
mt: instance
fn: new
fs: new(file = STDIN_FILE_NAME)
fd: 
pt: IRB::InputMethod
mt: class
fn: readable_atfer_eof?
fs: readable_atfer_eof?()
fd: 
pt: IRB::InputMethod
mt: instance
fn: eval_input
fs: eval_input()
fd: 
pt: IRB::Irb
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: IRB::Irb
mt: instance
fn: new
fs: new(workspace = nil, input_method = nil, output_method = nil)
fd: 
pt: IRB::Irb
mt: class
fn: output_value
fs: output_value()
fd: 
pt: IRB::Irb
mt: instance
fn: prompt
fs: prompt(prompt, ltype, indent, line_no)
fd: 
pt: IRB::Irb
mt: instance
fn: signal_handle
fs: signal_handle()
fd: 
pt: IRB::Irb
mt: instance
fn: signal_status
fs: signal_status(status)
fd: 
pt: IRB::Irb
mt: instance
fn: suspend_context
fs: suspend_context(context)
fd: 
pt: IRB::Irb
mt: instance
fn: suspend_input_method
fs: suspend_input_method(input_method)
fd: 
pt: IRB::Irb
mt: instance
fn: suspend_name
fs: suspend_name(path = nil, name = nil)
fd: 
pt: IRB::Irb
mt: instance
fn: suspend_workspace
fs: suspend_workspace(workspace)
fd: 
pt: IRB::Irb
mt: instance
fn: irb
fs: irb(file = nil, *main)
fd: invoke multi-irb
pt: IRB
mt: class
fn: irb_abort
fs: irb_abort(irb, exception = Abort)
fd: 
pt: IRB
mt: class
fn: irb_exit
fs: irb_exit(irb, ret)
fd: 
pt: IRB
mt: class
fn: irb_load
fs: irb_load(fn, priv = nil)
fd: 
pt: IRB::IrbLoader
mt: instance
fn: load_file
fs: load_file(path, priv = nil)
fd: 
pt: IRB::IrbLoader
mt: instance
fn: old
fs: old()
fd: 
pt: IRB::IrbLoader
mt: instance
fn: search_file_from_ruby_path
fs: search_file_from_ruby_path(fn)
fd: 
pt: IRB::IrbLoader
mt: instance
fn: source_file
fs: source_file(path)
fd: 
pt: IRB::IrbLoader
mt: instance
fn: delete
fs: delete(key)
fd: 
pt: IRB::JobManager
mt: instance
fn: insert
fs: insert(irb)
fd: 
pt: IRB::JobManager
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: IRB::JobManager
mt: instance
fn: irb
fs: irb(key)
fd: 
pt: IRB::JobManager
mt: instance
fn: kill
fs: kill(*keys)
fd: 
pt: IRB::JobManager
mt: instance
fn: main_irb
fs: main_irb()
fd: 
pt: IRB::JobManager
mt: instance
fn: main_thread
fs: main_thread()
fd: 
pt: IRB::JobManager
mt: instance
fn: n_jobs
fs: n_jobs()
fd: 
pt: IRB::JobManager
mt: instance
fn: new
fs: new()
fd: 
pt: IRB::JobManager
mt: class
fn: search
fs: search(key)
fd: 
pt: IRB::JobManager
mt: instance
fn: switch
fs: switch(key)
fd: 
pt: IRB::JobManager
mt: instance
fn: thread
fs: thread(key)
fd: 
pt: IRB::JobManager
mt: instance
fn: JobManager
fs: JobManager()
fd: 
pt: IRB
mt: class
fn: load_modules
fs: load_modules()
fd: loading modules
pt: IRB
mt: class
fn: find
fs: find(file , paths = $:)
fd: 
pt: IRB::Locale
mt: instance
fn: format
fs: format(*opts)
fd: 
pt: IRB::Locale
mt: instance
fn: gets
fs: gets(*rs)
fd: 
pt: IRB::Locale
mt: instance
fn: load
fs: load(file, priv=nil)
fd: 
pt: IRB::Locale
mt: instance
fn: new
fs: new(locale = nil)
fd: 
pt: IRB::Locale
mt: class
fn: print
fs: print(*opts)
fd: 
pt: IRB::Locale
mt: instance
fn: printf
fs: printf(*opts)
fd: 
pt: IRB::Locale
mt: instance
fn: puts
fs: puts(*opts)
fd: 
pt: IRB::Locale
mt: instance
fn: readline
fs: readline(*rs)
fd: 
pt: IRB::Locale
mt: instance
fn: require
fs: require(file, priv = nil)
fd: 
pt: IRB::Locale
mt: instance
fn: String
fs: String(mes)
fd: 
pt: IRB::Locale
mt: instance
fn: def_post_proc
fs: def_post_proc(base_method, extend_method)
fd: 
pt: IRB::MethodExtender
mt: instance
fn: def_pre_proc
fs: def_pre_proc(base_method, extend_method)
fd: 
pt: IRB::MethodExtender
mt: instance
fn: new_alias_name
fs: new_alias_name(name, prefix = "__alias_of__", postfix = "__")
fd: "return #{prefix}#{name}#{postfix}&lt;num&gt;"
pt: IRB::MethodExtender
mt: instance
fn: exec_if
fs: exec_if()
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: instance
fn: new
fs: new(prefix, base_notifier)
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: class
fn: notify?
fs: notify?()
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: instance
fn: pp
fs: pp(*objs)
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: instance
fn: ppx
fs: ppx(prefix, *objs)
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: instance
fn: print
fs: print(*opts)
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: instance
fn: printf
fs: printf(format, *opts)
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: instance
fn: printn
fs: printn(*opts)
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: instance
fn: puts
fs: puts(*objs)
fd: 
pt: IRB::Notifier::AbstructNotifier
mt: instance
fn: def_notifier
fs: def_notifier(level, prefix = "")
fd: 
pt: IRB::Notifier::CompositeNotifier
mt: instance
fn: level=
fs: level=(value)
fd: "Alias for #level_notifier="
pt: IRB::Notifier::CompositeNotifier
mt: instance
fn: level_notifier=
fs: level_notifier=(value)
fd: 
pt: IRB::Notifier::CompositeNotifier
mt: instance
fn: new
fs: new(prefix, base_notifier)
fd: 
pt: IRB::Notifier::CompositeNotifier
mt: class
fn: def_notifier
fs: def_notifier(prefix = "", output_method = StdioOutputMethod.new)
fd: 
pt: IRB::Notifier
mt: instance
fn: new
fs: new(base, level, prefix)
fd: 
pt: IRB::Notifier::LeveledNotifier
mt: class
fn: notify?
fs: notify?()
fd: 
pt: IRB::Notifier::LeveledNotifier
mt: instance
fn: new
fs: new()
fd: 
pt: IRB::Notifier::NoMsgNotifier
mt: class
fn: notify?
fs: notify?()
fd: 
pt: IRB::Notifier::NoMsgNotifier
mt: instance
fn: foo
fs: foo(format)
fd: 
pt: IRB::OutputMethod
mt: instance
fn: parse_printf_format
fs: parse_printf_format(format, opts)
fd: "% &lt;\xA5\xD5\xA5\xE9\xA5\xB0&gt; [#0- +] &lt;\xBA\xC7\xBE\xAE\xA5\xD5\xA5\xA3\xA1\xBC\xA5\xEB\xA5\xC9\xC9\xFD&gt; (*|*[1-9][0-9]*\\$|[1-9][0-9]*) &lt;\xC0\xBA\xC5\xD9&gt;.(*|*[1-9][0-9]*\\$|[1-9][0-9]*|)? #&lt;\xC4\xB9\xA4\xB5\xBD\xA4\xC0\xB5\xCA\xB8\xBB\xFA&gt;(hh|h|l|ll|L|q|j|z|t) &lt;\xCA\xD1\xB4\xB9\xBD\xA4\xC0\xB5\xCA\xB8\xBB\xFA&gt;[diouxXeEfgGcsb%]"
pt: IRB::OutputMethod
mt: instance
fn: pp
fs: pp(*objs)
fd: 
pt: IRB::OutputMethod
mt: instance
fn: ppx
fs: ppx(prefix, *objs)
fd: 
pt: IRB::OutputMethod
mt: instance
fn: print
fs: print(*opts)
fd: 
pt: IRB::OutputMethod
mt: instance
fn: printf
fs: printf(format, *opts)
fd: extend printf
pt: IRB::OutputMethod
mt: instance
fn: printn
fs: printn(*opts)
fd: 
pt: IRB::OutputMethod
mt: instance
fn: puts
fs: puts(*objs)
fd: 
pt: IRB::OutputMethod
mt: instance
fn: parse_opts
fs: parse_opts()
fd: option analyzing
pt: IRB
mt: class
fn: print_usage
fs: print_usage()
fd: 
pt: IRB
mt: class
fn: rc_file
fs: rc_file(ext = IRBRC_EXT)
fd: 
pt: IRB
mt: class
fn: rc_file_generators
fs: rc_file_generators"()
fd: enumerate possible rc-file base name generators
pt: IRB
mt: class
fn: eof?
fs: eof?()
fd: 
pt: IRB::ReadlineInputMethod
mt: instance
fn: gets
fs: gets()
fd: 
pt: IRB::ReadlineInputMethod
mt: instance
fn: line
fs: line(line_no)
fd: 
pt: IRB::ReadlineInputMethod
mt: instance
fn: new
fs: new()
fd: 
pt: IRB::ReadlineInputMethod
mt: class
fn: readable_atfer_eof?
fs: readable_atfer_eof?()
fd: 
pt: IRB::ReadlineInputMethod
mt: instance
fn: run_config
fs: run_config()
fd: running config
pt: IRB
mt: class
fn: setup
fs: setup(ap_path)
fd: initialize config
pt: IRB
mt: class
fn: create
fs: create(token, preproc = nil, postproc = nil)
fd: 
pt: IRB::SLex
mt: instance
fn: def_rule
fs: def_rule(token, preproc = nil, postproc = nil, &block)
fd: 
pt: IRB::SLex
mt: instance
fn: def_rules
fs: def_rules(*tokens, &block)
fd: 
pt: IRB::SLex
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: IRB::SLex
mt: instance
fn: match
fs: match(token)
fd: 
pt: IRB::SLex
mt: instance
fn: new
fs: new()
fd: 
pt: IRB::SLex
mt: class
fn: create_subnode
fs: create_subnode(chrs, preproc = nil, postproc = nil)
fd: 
pt: IRB::SLex::Node
mt: instance
fn: match
fs: match(chrs, op = "")
fd: "chrs: String"
pt: IRB::SLex::Node
mt: instance
fn: match_io
fs: match_io(io, op = "")
fd: 
pt: IRB::SLex::Node
mt: instance
fn: new
fs: new(preproc = nil, postproc = nil)
fd: if postproc is nil, this node is an abstract node. if postproc is non-nil, this node is a real node.
pt: IRB::SLex::Node
mt: class
fn: search
fs: search(chrs, opt = nil)
fd: 
pt: IRB::SLex::Node
mt: instance
fn: postproc
fs: postproc(token)
fd: "\e$BMW%A%'%C%/\e(B?"
pt: IRB::SLex
mt: instance
fn: preproc
fs: preproc(token, proc)
fd: 
pt: IRB::SLex
mt: instance
fn: search
fs: search(token)
fd: 
pt: IRB::SLex
mt: instance
fn: start
fs: start(ap_path = nil)
fd: initialize IRB and start TOP_LEVEL irb
pt: IRB
mt: class
fn: eof?
fs: eof?()
fd: 
pt: IRB::StdioInputMethod
mt: instance
fn: gets
fs: gets()
fd: 
pt: IRB::StdioInputMethod
mt: instance
fn: line
fs: line(line_no)
fd: 
pt: IRB::StdioInputMethod
mt: instance
fn: new
fs: new()
fd: 
pt: IRB::StdioInputMethod
mt: class
fn: readable_atfer_eof?
fs: readable_atfer_eof?()
fd: 
pt: IRB::StdioInputMethod
mt: instance
fn: print
fs: print(*opts)
fd: 
pt: IRB::StdioOutputMethod
mt: instance
fn: version
fs: version()
fd: IRB version method
pt: IRB
mt: class
fn: evaluate
fs: evaluate(context, statements, file = __FILE__, line = __LINE__)
fd: 
pt: IRB::WorkSpace
mt: instance
fn: filter_backtrace
fs: filter_backtrace(bt)
fd: error message manipulator
pt: IRB::WorkSpace
mt: instance
fn: new
fs: new(*main)
fd: create new workspace. set self to main if specified, otherwise inherit main from TOPLEVEL_BINDING.
pt: IRB::WorkSpace
mt: class
fn: guess
fs: guess(str)
fd: Guess input encoding by NKF.guess2
pt: Kconv
mt: instance
fn: guess_old
fs: guess_old(str)
fd: Guess input encoding by NKF.guess1
pt: Kconv
mt: instance
fn: iseuc
fs: iseuc(str)
fd: Returns whether input encoding is EUC-JP or not.
pt: Kconv
mt: instance
fn: issjis
fs: issjis(str)
fd: Returns whether input encoding is Shift_JIS or not.
pt: Kconv
mt: instance
fn: isutf8
fs: isutf8(str)
fd: Returns whether input encoding is UTF-8 or not.
pt: Kconv
mt: instance
fn: kconv
fs: kconv(str, out_code, in_code = Kconv::AUTO)
fd: Convert str to out_code. out_code and in_code are given as constants of Kconv.
pt: Kconv
mt: instance
fn: toeuc
fs: toeuc(str)
fd: Convert str to EUC-JP
pt: Kconv
mt: instance
fn: tojis
fs: tojis(str)
fd: Convert str to ISO-2022-JP
pt: Kconv
mt: instance
fn: tosjis
fs: tosjis(str)
fd: Convert str to Shift_JIS
pt: Kconv
mt: instance
fn: toutf16
fs: toutf16(str)
fd: Convert str to UTF-16
pt: Kconv
mt: instance
fn: toutf8
fs: toutf8(str)
fd: Convert str to UTF-8
pt: Kconv
mt: instance
fn: abort
fs: abort
fd: Terminate execution immediately, effectively by calling Kernel.exit(1). If msg is given, it is written to STDERR prior to terminating.
pt: Kernel
mt: instance
fn: Array
fs: Array  Array(arg)
fd: Returns arg as an Array. First tries to call arg.to_ary, then arg.to_a. If both fail, creates a single element array containing arg (unless arg is nil).
pt: Kernel
mt: instance
fn: at_exit
fs: at_exit
fd: Converts block to a Proc object (and therefore binds it at the point of call) and registers it for execution when the program exits. If multiple handlers are registered, they are executed in reverse order of registration.
pt: Kernel
mt: instance
fn: autoload?
fs: autoload?  autoload(module, filename)
fd: Registers filename to be loaded (using Kernel::require) the first time that module (which may be a String or a symbol) is accessed.
pt: Kernel
mt: instance
fn: autoload
fs: autoload  autoload(module, filename)
fd: Registers filename to be loaded (using Kernel::require) the first time that module (which may be a String or a symbol) is accessed.
pt: Kernel
mt: instance
fn: binding
fs: binding
fd: Returns a Binding object, describing the variable and method bindings at the point of call. This object can be used when calling eval to execute the evaluated command in this environment. Also see the description of class Binding.
pt: Kernel
mt: instance
fn: block_given?
fs: block_given?
fd: Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated.
pt: Kernel
mt: instance
fn: callcc
fs: callcc
fd: Generates a Continuation object, which it passes to the associated block. Performing a cont.call will cause the callcc to return (as will falling through the end of the block). The value returned by the callcc is the value of the block, or the value passed to cont.call. See class Continuation for more details. Also see Kernel::throw for an alternative mechanism for unwinding a call stack.
pt: Kernel
mt: instance
fn: caller
fs: caller  caller(start=1)
fd: "Returns the current execution stack---an array containing strings in the form ``file:line'' or ``file:line: in `method'''. The optional start parameter determines the number of initial stack entries to omit from the result."
pt: Kernel
mt: instance
fn: catch
fs: catch  catch(symbol)
fd: catch executes its block. If a throw is executed, Ruby searches up its stack for a catch block with a tag corresponding to the throw's symbol. If found, that block is terminated, and catch returns the value given to throw. If throw is not called, the block terminates normally, and the value of catch is the value of the last expression evaluated. catch expressions may be nested, and the throw call need not be in lexical scope.
pt: Kernel
mt: instance
fn: chomp!
fs: chomp!  chomp!             => $_ or nil
  chomp!(string)
fd: Equivalent to $_.chomp!(string). See String#chomp!
pt: Kernel
mt: instance
fn: chomp
fs: chomp  chomp            => $_
  chomp(string)
fd: Equivalent to $_ = $_.chomp(string). See String#chomp.
pt: Kernel
mt: instance
fn: chop!
fs: chop!
fd: Equivalent to $_.chop!.
pt: Kernel
mt: instance
fn: chop
fs: chop
fd: Equivalent to ($_.dup).chop!, except nil is never returned. See String#chop!.
pt: Kernel
mt: instance
fn: eval
fs: eval  eval(string [, binding [, filename [,lineno]]])
fd: Evaluates the Ruby expression(s) in string. If binding is given, the evaluation is performed in its context. The binding may be a Binding object or a Proc object. If the optional filename and lineno parameters are present, they will be used when reporting syntax errors.
pt: Kernel
mt: instance
fn: exec
fs: exec  exec(command [, arg, ...])
fd: Replaces the current process by running the given external command. If exec is given a single argument, that argument is taken as a line that is subject to shell expansion before being executed. If multiple arguments are given, the second and subsequent arguments are passed as parameters to command with no shell expansion. If the first argument is a two-element array, the first element is the command to be executed, and the second argument is used as the argv[0] value, which may show up in process listings. In MSDOS environments, the command is executed in a subshell; otherwise, one of the exec(2) system calls is used, so the running command may inherit some of the environment of the original program (including open file descriptors).
pt: Kernel
mt: instance
fn: exit!
fs: exit!(fixnum=-1)
fd: Exits the process immediately. No exit handlers are run. fixnum is returned to the underlying system as the exit status.
pt: Kernel
mt: instance
fn: exit
fs: exit  exit(integer=0)
fd: Initiates the termination of the Ruby script by raising the SystemExit exception. This exception may be caught. The optional parameter is used to return a status code to the invoking environment.
pt: Kernel
mt: instance
fn: fail
fs: fail  raise
  raise(string)
fd: With no arguments, raises the exception in $! or raises a RuntimeError if $! is nil. With a single String argument, raises a RuntimeError with the string as a message. Otherwise, the first parameter should be the name of an Exception class (or an object that returns an Exception object when sent an exception message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the rescue clause of begin...end blocks.
pt: Kernel
mt: instance
fn: Float
fs: Float  Float(arg)
fd: Returns arg converted to a float. Numeric types are converted directly, the rest are converted using arg.to_f. As of Ruby 1.8, converting nil generates a TypeError.
pt: Kernel
mt: instance
fn: fork
fs: fork
fd: Creates a subprocess. If a block is specified, that block is run in the subprocess, and the subprocess terminates with a status of zero. Otherwise, the fork call returns twice, once in the parent, returning the process ID of the child, and once in the child, returning nil. The child process can exit using Kernel.exit! to avoid running any at_exit functions. The parent process should use Process.wait to collect the termination statuses of its children or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes.
pt: Kernel
mt: instance
fn: format
fs: format  format(format_string [, arguments...] )
fd: "Returns the string resulting from applying format_string to any additional arguments. Within the format string, any characters other than format sequences are copied to the result. A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character. The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. The field type characters are listed in the table at the end of this section. The flag characters are:"
pt: Kernel
mt: instance
fn: getc
fs: getc()
fd: obsolete
pt: Kernel
mt: instance
fn: gets
fs: gets  gets(separator=$/)
fd: Returns (and assigns to $_) the next line from the list of files in ARGV (or $*), or from standard input if no files are present on the command line. Returns nil at end of file. The optional argument specifies the record separator. The separator is included with the contents of each record. A separator of nil reads the entire contents, and a zero-length separator reads the input one paragraph at a time, where paragraphs are divided by two consecutive newlines. If multiple filenames are present in ARGV, +gets(nil)+ will read the contents one file at a time.
pt: Kernel
mt: instance
fn: global_variables
fs: global_variables
fd: Returns an array of the names of global variables.
pt: Kernel
mt: instance
fn: gsub!
fs: gsub!  gsub!(pattern, replacement)
fd: Equivalent to Kernel::gsub, except nil is returned if $_ is not modified.
pt: Kernel
mt: instance
fn: gsub
fs: gsub  gsub(pattern, replacement)
fd: Equivalent to $_.gsub..., except that $_ receives the modified result.
pt: Kernel
mt: instance
fn: Integer
fs: Integer  Integer(arg)
fd: Converts arg to a Fixnum or Bignum. Numeric types are converted directly (with floating point numbers being truncated). If arg is a String, leading radix indicators (0, 0b, and 0x) are honored. Others are converted using to_int and to_i. This behavior is different from that of String#to_i.
pt: Kernel
mt: instance
fn: iterator?
fs: iterator?
fd: Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated.
pt: Kernel
mt: instance
fn: lambda
fs: lambda
fd: Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed when called.
pt: Kernel
mt: instance
fn: load
fs: load  load(filename, wrap=false)
fd: Loads and executes the Ruby program in the file filename. If the filename does not resolve to an absolute path, the file is searched for in the library directories listed in $:. If the optional wrap parameter is true, the loaded script will be executed under an anonymous module, protecting the calling program's global namespace. In no circumstance will any local variables in the loaded file be propagated to the loading environment.
pt: Kernel
mt: instance
fn: local_variables
fs: local_variables
fd: Returns the names of the current local variables.
pt: Kernel
mt: instance
fn: loop
fs: loop
fd: Repeatedly executes the block.
pt: Kernel
mt: instance
fn: method_missing
fs: method_missing(symbol [, *args] )
fd: Invoked by Ruby when obj is sent a message it cannot handle. symbol is the symbol for the method called, and args are any arguments that were passed to it. By default, the interpreter raises an error when this method is called. However, it is possible to override the method to provide more dynamic behavior. The example below creates a class Roman, which responds to methods with names consisting of roman numerals, returning the corresponding integer values.
pt: Kernel
mt: instance
fn: open
fs: open  open(path [, mode [, perm]] )
fd: Creates an IO object connected to the given stream, file, or subprocess.
pt: Kernel
mt: instance
fn: p
fs: p  p(obj, ...)
fd: For each object, directly writes obj.inspect followed by the current output record separator to the program's standard output.
pt: Kernel
mt: instance
fn: pretty_inspect
fs: pretty_inspect()
fd: returns a pretty printed object as a string.
pt: Kernel
mt: instance
fn: print
fs: print  print(obj, ...)
fd: Prints each object in turn to $stdout. If the output field separator ($,) is not nil, its contents will appear between each field. If the output record separator ($\) is not nil, it will be appended to the output. If no arguments are given, prints $_. Objects that aren't strings will be converted by calling their to_s method.
pt: Kernel
mt: instance
fn: printf
fs: printf  printf(io, string [, obj ... ] )
fd: "Equivalent to:"
pt: Kernel
mt: instance
fn: proc
fs: proc
fd: Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed when called.
pt: Kernel
mt: instance
fn: putc
fs: putc  putc(int)
fd: "Equivalent to:"
pt: Kernel
mt: instance
fn: puts
fs: puts  puts(obj, ...)
fd: Equivalent to
pt: Kernel
mt: instance
fn: raise
fs: raise  raise
  raise(string)
fd: With no arguments, raises the exception in $! or raises a RuntimeError if $! is nil. With a single String argument, raises a RuntimeError with the string as a message. Otherwise, the first parameter should be the name of an Exception class (or an object that returns an Exception object when sent an exception message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the rescue clause of begin...end blocks.
pt: Kernel
mt: instance
fn: rand
fs: rand  rand(max=0)
fd: Converts max to an integer using max1 = max.to_i.abs. If the result is zero, returns a pseudorandom floating point number greater than or equal to 0.0 and less than 1.0. Otherwise, returns a pseudorandom integer greater than or equal to zero and less than max1. Kernel::srand may be used to ensure repeatable sequences of random numbers between different runs of the program. Ruby currently uses a modified Mersenne Twister with a period of 2**19937-1.
pt: Kernel
mt: instance
fn: readline
fs: readline  readline(separator=$/)
fd: Equivalent to Kernel::gets, except readline raises EOFError at end of file.
pt: Kernel
mt: instance
fn: readlines
fs: readlines  readlines(separator=$/)
fd: Returns an array containing the lines returned by calling Kernel.gets(separator) until the end of file.
pt: Kernel
mt: instance
fn: require
fs: require  require(string)
fd: Ruby tries to load the library named string, returning true if successful. If the filename does not resolve to an absolute path, it will be searched for in the directories listed in $:. If the file has the extension ``.rb'', it is loaded as a source file; if the extension is ``.so'', ``.o'', or ``.dll'', or whatever the default shared library extension is on the current platform, Ruby loads the shared library as a Ruby extension. Otherwise, Ruby tries adding ``.rb'', ``.so'', and so on to the name. The name of the loaded feature is added to the array in $&quot;. A feature will not be loaded if it's name already appears in $&quot;. However, the file name is not converted to an absolute path, so that ``require 'a';require './a''' will load a.rb twice.
pt: Kernel
mt: instance
fn: scan
fs: scan  scan(pattern)
fd: Equivalent to calling $_.scan. See String#scan.
pt: Kernel
mt: instance
fn: select
fs: select(read_array 
fd: See Kernel#select.
pt: Kernel
mt: instance
fn: set_trace_func
fs: set_trace_func  set_trace_func(proc)
fd: "Establishes proc as the handler for tracing, or disables tracing if the parameter is nil. proc takes up to six parameters: an event name, a filename, a line number, an object id, a binding, and the name of a class. proc is invoked whenever an event occurs. Events are: c-call (call a C-language routine), c-return (return from a C-language routine), call (call a Ruby method), class (start a class or module definition), end (finish a class or module definition), line (execute code on a new line), raise (raise an exception), and return (return from a Ruby method). Tracing is disabled within the context of proc."
pt: Kernel
mt: instance
fn: sleep
fs: sleep  sleep([duration])
fd: Suspends the current thread for duration seconds (which may be any number, including a Float with fractional seconds). Returns the actual number of seconds slept (rounded), which may be less than that asked for if another thread calls Thread#run. Zero arguments causes sleep to sleep forever.
pt: Kernel
mt: instance
fn: split
fs: split  split([pattern [, limit]])
fd: Equivalent to $_.split(pattern, limit). See String#split.
pt: Kernel
mt: instance
fn: sprintf
fs: sprintf  format(format_string [, arguments...] )
fd: "Returns the string resulting from applying format_string to any additional arguments. Within the format string, any characters other than format sequences are copied to the result. A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character. The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. The field type characters are listed in the table at the end of this section. The flag characters are:"
pt: Kernel
mt: instance
fn: srand
fs: srand  srand(number=0)
fd: Seeds the pseudorandom number generator to the value of number.to_i.abs. If number is omitted, seeds the generator using a combination of the time, the process id, and a sequence number. (This is also the behavior if Kernel::rand is called without previously calling srand, but without the sequence.) By setting the seed to a known value, scripts can be made deterministic during testing. The previous seed value is returned. Also see Kernel::rand.
pt: Kernel
mt: instance
fn: String
fs: String  String(arg)
fd: Converts arg to a String by calling its to_s method.
pt: Kernel
mt: instance
fn: sub!
fs: sub!  sub!(pattern, replacement)
fd: Equivalent to $_.sub!(args).
pt: Kernel
mt: instance
fn: sub
fs: sub  sub(pattern, replacement)
fd: Equivalent to $_.sub(args), except that $_ will be updated if substitution occurs.
pt: Kernel
mt: instance
fn: syscall
fs: syscall  syscall(fixnum [, args...])
fd: Calls the operating system function identified by fixnum, passing in the arguments, which must be either String objects, or Integer objects that ultimately fit within a native long. Up to nine parameters may be passed (14 on the Atari-ST). The function identified by fixnum is system dependent. On some Unix systems, the numbers may be obtained from a header file called syscall.h.
pt: Kernel
mt: instance
fn: system
fs: system  system(cmd [, arg, ...])
fd: Executes cmd in a subshell, returning true if the command was found and ran successfully, false otherwise. An error status is available in $?. The arguments are processed in the same way as for Kernel::exec.
pt: Kernel
mt: instance
fn: test
fs: test  test(int_cmd, file1 [, file2] )
fd: " Uses the integer aCmd to perform various tests on\n file1 (first table below) or on file1 and\n file2 (second table).\n\n File tests on a single file:\n\n   Test   Returns   Meaning\n    ?A  | Time    | Last access time for file1\n    ?b  | boolean | True if file1 is a block device\n    ?c  | boolean | True if file1 is a character device\n    ?C  | Time    | Last change time for file1\n    ?d  | boolean | True if file1 exists and is a directory\n    ?e  | boolean | True if file1 exists\n    ?f  | boolean | True if file1 exists and is a regular file\n    ?g  | boolean | True if file1 has the \\CF{setgid} bit\n        |         | set (false under NT)\n    ?G  | boolean | True if file1 exists and has a group\n        |         | ownership equal to the caller's group\n    ?k  | boolean | True if file1 exists and has the sticky bit set\n    ?l  | boolean | True if file1 exists and is a symbolic link\n    ?M  | Time    | Last modification time for file1\n    ?o  | boolean | True if file1 exists and is owned by\n        |         | the caller's effective uid\n    ?O  | boolean | True if file1 exists and is owned by\n        |         | the caller's real uid\n    ?p  | boolean | True if file1 exists and is a fifo\n    ?r  | boolean | True if file1 is readable by the effective\n        |         | uid/gid of the caller\n    ?R  | boolean | True if file is readable by the real\n        |         | uid/gid of the caller\n    ?s  | int/nil | If file1 has nonzero size, return the size,\n        |         | otherwise return nil\n    ?S  | boolean | True if file1 exists and is a socket\n    ?u  | boolean | True if file1 has the setuid bit set\n    ?w  | boolean | True if file1 exists and is writable by\n        |         | the effective uid/gid\n    ?W  | boolean | True if file1 exists and is writable by\n        |         | the real uid/gid\n    ?x  | boolean | True if file1 exists and is executable by\n        |         | the effective uid/gid\n    ?X  | boolean | True if file1 exists and is executable by\n        |         | the real uid/gid\n    ?z  | boolean | True if file1 exists and has a zero length\n"
pt: Kernel
mt: instance
fn: throw
fs: throw  throw(symbol [, obj])
fd: Transfers control to the end of the active catch block waiting for symbol. Raises NameError if there is no catch block for the symbol. The optional second parameter supplies a return value for the catch block, which otherwise defaults to nil. For examples, see Kernel::catch.
pt: Kernel
mt: instance
fn: trace_var
fs: trace_var  trace_var(symbol, cmd )
fd: Controls tracing of assignments to global variables. The parameter +symbol_ identifies the variable (as either a string name or a symbol identifier). cmd (which may be a string or a Proc object) or block is executed whenever the variable is assigned. The block or Proc object receives the variable's new value as a parameter. Also see Kernel::untrace_var.
pt: Kernel
mt: instance
fn: trap
fs: trap( signal, proc )
fd: Specifies the handling of signals. The first parameter is a signal name (a string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a signal number. The characters ``SIG'' may be omitted from the signal name. The command or block specifies code to be run when the signal is raised. If the command is the string ``IGNORE'' or ``SIG_IGN'', the signal will be ignored. If the command is ``DEFAULT'' or ``SIG_DFL'', the operating system's default handler will be invoked. If the command is ``EXIT'', the script will be terminated by the signal. Otherwise, the given command or block will be run. The special signal name ``EXIT'' or signal number zero will be invoked just prior to program termination. trap returns the previous handler for the given signal.
pt: Kernel
mt: instance
fn: untrace_var
fs: untrace_var  untrace_var(symbol [, cmd] )
fd: Removes tracing for the specified command on the given global variable and returns nil. If no command is specified, removes all tracing for that variable and returns an array containing the commands actually removed.
pt: Kernel
mt: instance
fn: URI
fs: URI(uri_str)
fd: alias for URI.parse.
pt: Kernel
mt: instance
fn: warn
fs: warn(msg)
fd: 
pt: Kernel
mt: instance
fn: accept
fs: accept(t, pat = /.*/nm, &block)
fd: See OptionParser.accept.
pt: List
mt: instance
fn: append
fs: append(*args)
fd: "Appends switch at the tail of the list, and associates short, long and negated long options. Arguments are:"
pt: List
mt: instance
fn: complete
fs: complete(id, opt, icase = false, *pat, &block)
fd: Searches list id for opt and the optional patterns for completion pat. If icase is true, the search is case insensitive. The result is returned or yielded if a block is given. If it isn't found, nil is returned.
pt: List
mt: instance
fn: each_option
fs: each_option(&block)
fd: Iterates over each option, passing the option to the block.
pt: List
mt: instance
fn: new
fs: new()
fd: Just initializes all instance variables.
pt: List
mt: class
fn: prepend
fs: prepend(*args)
fd: "Inserts switch at the head of the list, and associates short, long and negated long options. Arguments are:"
pt: List
mt: instance
fn: reject
fs: reject(t)
fd: See OptionParser.reject.
pt: List
mt: instance
fn: search
fs: search(id, key)
fd: Searches key in id list. The result is returned or yielded if a block is given. If it isn't found, nil is returned.
pt: List
mt: instance
fn: summarize
fs: summarize(*args, &block)
fd: Creates the summary table, passing each line to the block (without newline). The arguments args are passed along to the summarize method which is called on every option.
pt: List
mt: instance
fn: exit_value
fs: exit_value()
fd: "call_seq:"
pt: LocalJumpError
mt: instance
fn: reason
fs: reason
fd: "The reason this block was terminated: :break, :redo, :retry, :next, :return, or :noreason."
pt: LocalJumpError
mt: instance
fn: add
fs: add(severity, message = nil, progname = nil, &block)
fd: "  Logger#add(severity, message = nil, progname = nil) { ... }\n"
pt: Logger
mt: instance
fn: level=
fs: level=(level)
fd: Set the logging threshold, just like Logger#level=.
pt: Logger::Application
mt: instance
fn: log=
fs: log=(logdev)
fd: 
pt: Logger::Application
mt: instance
fn: log
fs: log(severity, message = nil, &block)
fd: See Logger#add. This application's appname is used.
pt: Logger::Application
mt: instance
fn: new
fs: new(appname = nil)
fd: "  Application.new(appname = '')\n"
pt: Logger::Application
mt: class
fn: set_log
fs: set_log(logdev, shift_age = 0, shift_size = 1024000)
fd: Sets the log device for this application. See the class Logger for an explanation of the arguments.
pt: Logger::Application
mt: instance
fn: start
fs: start()
fd: Start the application. Return the status code.
pt: Logger::Application
mt: instance
fn: close
fs: close()
fd: Close the logging device.
pt: Logger
mt: instance
fn: datetime_format=
fs: datetime_format=(datetime_format)
fd: Logging date-time format (string passed to strftime).
pt: Logger
mt: instance
fn: datetime_format
fs: datetime_format()
fd: 
pt: Logger
mt: instance
fn: debug?
fs: debug?()
fd: Returns true iff the current severity level allows for the printing of DEBUG messages.
pt: Logger
mt: instance
fn: debug
fs: debug(progname = nil, &block)
fd: Log a DEBUG message.
pt: Logger
mt: instance
fn: error?
fs: error?()
fd: Returns true iff the current severity level allows for the printing of ERROR messages.
pt: Logger
mt: instance
fn: error
fs: error(progname = nil, &block)
fd: Log an ERROR message.
pt: Logger
mt: instance
fn: fatal?
fs: fatal?()
fd: Returns true iff the current severity level allows for the printing of FATAL messages.
pt: Logger
mt: instance
fn: fatal
fs: fatal(progname = nil, &block)
fd: Log a FATAL message.
pt: Logger
mt: instance
fn: call
fs: call(severity, time, progname, msg)
fd: 
pt: Logger::Formatter
mt: instance
fn: new
fs: new()
fd: 
pt: Logger::Formatter
mt: class
fn: info?
fs: info?()
fd: Returns true iff the current severity level allows for the printing of INFO messages.
pt: Logger
mt: instance
fn: info
fs: info(progname = nil, &block)
fd: Log an INFO message.
pt: Logger
mt: instance
fn: log
fs: log(severity, message = nil, progname = nil, &block)
fd: "Alias for #add"
pt: Logger
mt: instance
fn: close
fs: close()
fd: 
pt: Logger::LogDevice
mt: instance
fn: new
fs: new(log = nil, opt = {})
fd: 
pt: Logger::LogDevice
mt: class
fn: write
fs: write(message)
fd: 
pt: Logger::LogDevice
mt: instance
fn: new
fs: new(logdev, shift_age = 0, shift_size = 1048576)
fd: "  Logger.new(name, shift_age = 7, shift_size = 1048576)\n  Logger.new(name, shift_age = 'weekly')\n"
pt: Logger
mt: class
fn: unknown
fs: unknown(progname = nil, &block)
fd: Log an UNKNOWN message. This will be printed no matter what the logger level.
pt: Logger
mt: instance
fn: warn?
fs: warn?()
fd: Returns true iff the current severity level allows for the printing of WARN messages.
pt: Logger
mt: instance
fn: warn
fs: warn(progname = nil, &block)
fd: Log a WARN message.
pt: Logger
mt: instance
fn: logfile
fs: logfile(file)
fd: 
pt: Logging
mt: class
fn: message
fs: message(*s)
fd: 
pt: Logging
mt: class
fn: open
fs: open()
fd: 
pt: Logging
mt: class
fn: postpone
fs: postpone()
fd: 
pt: Logging
mt: class
fn: body
fs: body()
fd: Return the message body as an Array of lines
pt: Mail
mt: instance
fn: header
fs: header()
fd: Return the headers as a Hash.
pt: Mail
mt: instance
fn: new
fs: new(f)
fd: Create a new Mail where f is either a stream which responds to gets(), or a path to a file. If f is a path it will be opened.
pt: Mail
mt: class
fn: dump
fs: dump  dump( obj [, anIO] , limit=--1 )
fd: Serializes obj and all descendent objects. If anIO is specified, the serialized data will be written to it, otherwise the data will be returned as a String. If limit is specified, the traversal of subobjects will be limited to that depth. If limit is negative, no checking of depth will be performed.
pt: Marshal
mt: class
fn: load
fs: load  load( source [, proc] )
fd: Returns the result of converting the serialized data in source into a Ruby object (possibly with associated subordinate objects). source may be either an instance of IO or an object that responds to to_str. If proc is specified, it will be passed each object as it is deserialized.
pt: Marshal
mt: class
fn: restore
fs: restore  load( source [, proc] )
fd: Returns the result of converting the serialized data in source into a Ruby object (possibly with associated subordinate objects). source may be either an instance of IO or an object that responds to to_str. If proc is specified, it will be passed each object as it is deserialized.
pt: Marshal
mt: class
fn: begin
fs: begin(n)
fd: Returns the offset of the start of the nth element of the match array in the string.
pt: MatchData
mt: instance
fn: captures
fs: captures
fd: Returns the array of captures; equivalent to mtch.to_a[1..-1].
pt: MatchData
mt: instance
fn: end
fs: end(n)
fd: Returns the offset of the character immediately following the end of the nth element of the match array in the string.
pt: MatchData
mt: instance
fn: inspect
fs: inspect
fd: Returns a string representing obj. The default to_s prints the object's class and an encoding of the object id. As a special case, the top-level object that is the initial execution context of Ruby programs returns ``main.''
pt: MatchData
mt: instance
fn: length
fs: length
fd: Returns the number of elements in the match array.
pt: MatchData
mt: instance
fn: new
fs: new
fd: 
pt: MatchData
mt: class
fn: offset
fs: offset(n)
fd: Returns a two-element array containing the beginning and ending offsets of the nth match.
pt: MatchData
mt: instance
fn: post_match
fs: post_match
fd: Returns the portion of the original string after the current match. Equivalent to the special variable $'.
pt: MatchData
mt: instance
fn: pre_match
fs: pre_match
fd: Returns the portion of the original string before the current match. Equivalent to the special variable $`.
pt: MatchData
mt: instance
fn: pretty_print
fs: pretty_print(q)
fd: 
pt: MatchData
mt: instance
fn: select
fs: select([index]*)
fd: Uses each index to access the matching values, returning an array of the corresponding matches.
pt: MatchData
mt: instance
fn: size
fs: size
fd: Returns the number of elements in the match array.
pt: MatchData
mt: instance
fn: string
fs: string
fd: Returns a frozen copy of the string passed in to match.
pt: MatchData
mt: instance
fn: to_a
fs: to_a
fd: Returns the array of matches.
pt: MatchData
mt: instance
fn: to_s
fs: to_s
fd: Returns the entire matched string.
pt: MatchData
mt: instance
fn: values_at
fs: values_at  mtch.select([index]*)
fd: Uses each index to access the matching values, returning an array of the corresponding matches.
pt: MatchData
mt: instance
fn: acos
fs: acos(x)
fd: Computes the arc cosine of x. Returns 0..PI.
pt: Math
mt: class
fn: acosh
fs: acosh(x)
fd: Computes the inverse hyperbolic cosine of x.
pt: Math
mt: class
fn: asin
fs: asin(x)
fd: Computes the arc sine of x. Returns 0..PI.
pt: Math
mt: class
fn: asinh
fs: asinh(x)
fd: Computes the inverse hyperbolic sine of x.
pt: Math
mt: class
fn: atan
fs: atan(x)
fd: Computes the arc tangent of x. Returns -{PI/2} .. {PI/2}.
pt: Math
mt: class
fn: atan2
fs: atan2(y, x)
fd: Computes the arc tangent given y and x. Returns -PI..PI.
pt: Math
mt: class
fn: atanh
fs: atanh(x)
fd: Computes the inverse hyperbolic tangent of x.
pt: Math
mt: class
fn: cos
fs: cos(x)
fd: Computes the cosine of x (expressed in radians). Returns -1..1.
pt: Math
mt: class
fn: cosh
fs: cosh(x)
fd: Computes the hyperbolic cosine of x (expressed in radians).
pt: Math
mt: class
fn: erf
fs: erf(x)
fd: Calculates the error function of x.
pt: Math
mt: class
fn: erfc
fs: erfc(x)
fd: Calculates the complementary error function of x.
pt: Math
mt: class
fn: exp
fs: exp(x)
fd: Returns e**x.
pt: Math
mt: class
fn: frexp
fs: frexp(numeric)
fd: Returns a two-element array containing the normalized fraction (a Float) and exponent (a Fixnum) of numeric.
pt: Math
mt: class
fn: hypot
fs: hypot(x, y)
fd: Returns sqrt(x**2 + y**2), the hypotenuse of a right-angled triangle with sides x and y.
pt: Math
mt: class
fn: ldexp
fs: ldexp(flt, int)
fd: Returns the value of flt*(2**int).
pt: Math
mt: class
fn: log
fs: log(numeric)
fd: Returns the natural logarithm of numeric.
pt: Math
mt: class
fn: log10
fs: log10(numeric)
fd: Returns the base 10 logarithm of numeric.
pt: Math
mt: class
fn: new
fs: new
fd: 
pt: Math
mt: class
fn: rsqrt
fs: rsqrt(a)
fd: 
pt: Math
mt: instance
fn: sin
fs: sin(x)
fd: Computes the sine of x (expressed in radians). Returns -1..1.
pt: Math
mt: class
fn: sinh
fs: sinh(x)
fd: Computes the hyperbolic sine of x (expressed in radians).
pt: Math
mt: class
fn: sqrt
fs: sqrt(numeric)
fd: Returns the non-negative square root of numeric.
pt: Math
mt: class
fn: tan
fs: tan(x)
fd: Returns the tangent of x (expressed in radians).
pt: Math
mt: class
fn: tanh
fs: tanh()
fd: Computes the hyperbolic tangent of x (expressed in radians).
pt: Math
mt: class
fn: clone
fs: clone()
fd: Returns a clone of the matrix, so that the contents of each do not reference identical objects.
pt: Matrix
mt: instance
fn: coerce
fs: coerce(other)
fd: "FIXME: describe #coerce."
pt: Matrix
mt: instance
fn: collect
fs: collect( {|e| ...}
fd: Returns a matrix that is the result of iteration of the given block over all elements of the matrix.
pt: Matrix
mt: instance
fn: column
fs: column(j)
fd: Returns column vector number j of the matrix as a Vector (starting at 0 like an array). When a block is given, the elements of that vector are iterated.
pt: Matrix
mt: instance
fn: column_size
fs: column_size()
fd: Returns the number of columns. Note that it is possible to construct a matrix with uneven columns (e.g. Matrix[ [1,2,3], [4,5] ]), but this is mathematically unsound. This method uses the first row to determine the result.
pt: Matrix
mt: instance
fn: column_vector
fs: column_vector(column)
fd: Creates a single-column matrix where the values of that column are as given in column.
pt: Matrix
mt: class
fn: column_vectors
fs: column_vectors()
fd: Returns an array of the column vectors of the matrix. See Vector.
pt: Matrix
mt: instance
fn: columns
fs: columns(columns)
fd: Creates a matrix using columns as an array of column vectors.
pt: Matrix
mt: class
fn: compare_by_row_vectors
fs: compare_by_row_vectors(rows)
fd: Not really intended for general consumption.
pt: Matrix
mt: instance
fn: det
fs: det()
fd: "Alias for #determinant"
pt: Matrix
mt: instance
fn: determinant
fs: determinant()
fd: Returns the determinant of the matrix. If the matrix is not square, the result is 0.
pt: Matrix
mt: instance
fn: diagonal
fs: diagonal(*values)
fd: Creates a matrix where the diagonal elements are composed of values.
pt: Matrix
mt: class
fn: eql?
fs: eql?(other)
fd: "Alias for #=="
pt: Matrix
mt: instance
fn: hash
fs: hash()
fd: Returns a hash-code for the matrix.
pt: Matrix
mt: instance
fn: identity
fs: identity(n)
fd: Creates an n by n identity matrix.
pt: Matrix
mt: class
fn: inspect
fs: inspect()
fd: Overrides Object#inspect
pt: Matrix
mt: instance
fn: inv
fs: inv()
fd: "Alias for #inverse"
pt: Matrix
mt: instance
fn: inverse
fs: inverse()
fd: Returns the inverse of the matrix.
pt: Matrix
mt: instance
fn: inverse_from
fs: inverse_from(src)
fd: Not for public consumption?
pt: Matrix
mt: instance
fn: map
fs: map(
fd: "Alias for #collect"
pt: Matrix
mt: instance
fn: minor
fs: minor(*param)
fd: "Returns a section of the matrix. The parameters are either:"
pt: Matrix
mt: instance
fn: new
fs: new(init_method, *argv)
fd: This method is used by the other methods that create matrices, and is of no use to general users.
pt: Matrix
mt: class
fn: rank
fs: rank()
fd: Returns the rank of the matrix. Beware that using Float values, with their usual lack of precision, can affect the value returned by this method. Use Rational values instead if this is important to you.
pt: Matrix
mt: instance
fn: regular?
fs: regular?()
fd: Returns true if this is a regular matrix.
pt: Matrix
mt: instance
fn: row
fs: row(i)
fd: Returns row vector number i of the matrix as a Vector (starting at 0 like an array). When a block is given, the elements of that vector are iterated.
pt: Matrix
mt: instance
fn: row_size
fs: row_size()
fd: Returns the number of rows.
pt: Matrix
mt: instance
fn: row_vector
fs: row_vector(row)
fd: Creates a single-row matrix where the values of that row are as given in row.
pt: Matrix
mt: class
fn: row_vectors
fs: row_vectors()
fd: Returns an array of the row vectors of the matrix. See Vector.
pt: Matrix
mt: instance
fn: rows
fs: rows(rows, copy = true)
fd: Creates a matrix where rows is an array of arrays, each of which is a row to the matrix. If the optional argument copy is false, use the given arrays as the internal structure of the matrix without copying.
pt: Matrix
mt: class
fn: scalar
fs: scalar(n, value)
fd: Creates an n by n diagonal matrix where each diagonal element is value.
pt: Matrix
mt: class
fn: singular?
fs: singular?()
fd: Returns true is this is a singular (i.e. non-regular) matrix.
pt: Matrix
mt: instance
fn: square?
fs: square?()
fd: Returns true is this is a square matrix. See note in column_size about this being unreliable, though.
pt: Matrix
mt: instance
fn: t
fs: t()
fd: "Alias for #transpose"
pt: Matrix
mt: instance
fn: to_a
fs: to_a()
fd: Returns an array of arrays that describe the rows of the matrix.
pt: Matrix
mt: instance
fn: to_s
fs: to_s()
fd: Overrides Object#to_s
pt: Matrix
mt: instance
fn: tr
fs: tr()
fd: "Alias for #trace"
pt: Matrix
mt: instance
fn: trace
fs: trace()
fd: Returns the trace (sum of diagonal elements) of the matrix.
pt: Matrix
mt: instance
fn: transpose
fs: transpose()
fd: Returns the transpose of the matrix.
pt: Matrix
mt: instance
fn: zero
fs: zero(n)
fd: Creates an n by n zero matrix.
pt: Matrix
mt: class
fn: arity
fs: arity
fd: Returns an indication of the number of arguments accepted by a method. Returns a nonnegative integer for methods that take a fixed number of arguments. For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. For methods written in C, returns -1 if the call takes a variable number of arguments.
pt: Method
mt: instance
fn: call
fs: call(args, ...)
fd: Invokes the meth with the specified arguments, returning the method's return value.
pt: Method
mt: instance
fn: clone
fs: clone()
fd: "MISSING: documentation"
pt: Method
mt: instance
fn: inspect
fs: inspect
fd: Show the name of the underlying method.
pt: Method
mt: instance
fn: new
fs: new
fd: 
pt: Method
mt: class
fn: to_proc
fs: to_proc
fd: Returns a Proc object corresponding to this method.
pt: Method
mt: instance
fn: to_s
fs: to_s
fd: Show the name of the underlying method.
pt: Method
mt: instance
fn: unbind
fs: unbind
fd: Dissociates meth from it's current receiver. The resulting UnboundMethod can subsequently be bound to a new object of the same class (see UnboundMethod).
pt: Method
mt: instance
fn: alias_method
fs: alias_method  alias_method(new_name, old_name)
fd: Makes new_name a new copy of the method old_name. This can be used to retain access to methods that are overridden.
pt: Module
mt: instance
fn: ancestors
fs: ancestors
fd: Returns a list of modules included in mod (including mod itself).
pt: Module
mt: instance
fn: append_features
fs: append_features  append_features(mod)
fd: When this module is included in another, Ruby calls append_features in this module, passing it the receiving module in mod. Ruby's default implementation is to add the constants, methods, and module variables of this module to mod if this module has not already been added to mod or one of its ancestors. See also Module#include.
pt: Module
mt: instance
fn: attr
fs: attr  attr(symbol, writable=false)
fd: Defines a named attribute for this module, where the name is symbol.id2name, creating an instance variable (@name) and a corresponding access method to read it. If the optional writable argument is true, also creates a method called name= to set the attribute.
pt: Module
mt: instance
fn: attr_accessor
fs: attr_accessor  attr_accessor(symbol, ...)
fd: Equivalent to calling ``attrsymbol, true'' on each symbol in turn.
pt: Module
mt: instance
fn: attr_reader
fs: attr_reader  attr_reader(symbol, ...)
fd: Creates instance variables and corresponding methods that return the value of each instance variable. Equivalent to calling ``attr:name'' on each name in turn.
pt: Module
mt: instance
fn: attr_writer
fs: attr_writer  attr_writer(symbol, ...)
fd: Creates an accessor method to allow assignment to the attribute aSymbol.id2name.
pt: Module
mt: instance
fn: autoload?
fs: autoload?(name)
fd: Returns filename to be loaded if name is registered as autoload in the namespace of mod.
pt: Module
mt: instance
fn: autoload
fs: autoload(name, filename)
fd: Registers filename to be loaded (using Kernel::require) the first time that name (which may be a String or a symbol) is accessed in the namespace of mod.
pt: Module
mt: instance
fn: class_eval
fs: class_eval(string [, filename [, lineno]])
fd: Evaluates the string or block in the context of mod. This can be used to add methods to a class. module_eval returns the result of evaluating its argument. The optional filename and lineno parameters set the text for error messages.
pt: Module
mt: instance
fn: class_variable_defined?
fs: class_variable_defined?(symbol)
fd: Returns true if the given class variable is defined in obj.
pt: Module
mt: instance
fn: class_variable_get
fs: class_variable_get(symbol)
fd: Returns the value of the given class variable (or throws a NameError exception). The @@ part of the variable name should be included for regular class variables
pt: Module
mt: instance
fn: class_variable_set
fs: class_variable_set(symbol, obj)
fd: Sets the class variable names by symbol to object.
pt: Module
mt: instance
fn: class_variables
fs: class_variables
fd: Returns an array of the names of class variables in mod and the ancestors of mod.
pt: Module
mt: instance
fn: const_defined?
fs: const_defined?(sym)
fd: Returns true if a constant with the given name is defined by mod.
pt: Module
mt: instance
fn: const_get
fs: const_get(sym)
fd: Returns the value of the named constant in mod.
pt: Module
mt: instance
fn: const_missing
fs: const_missing(sym)
fd: "Invoked when a reference is made to an undefined constant in mod. It is passed a symbol for the undefined constant, and returns a value to be used for that constant. The following code is a (very bad) example: if reference is made to an undefined constant, it attempts to load a file whose name is the lowercase version of the constant (thus class Fred is assumed to be in file fred.rb). If found, it returns the value of the loaded class. It therefore implements a perverse kind of autoload facility."
pt: Module
mt: instance
fn: const_set
fs: const_set(sym, obj)
fd: Sets the named constant to the given object, returning that object. Creates a new constant if no constant with the given name previously existed.
pt: Module
mt: instance
fn: constants
fs: constants
fd: Returns an array of the names of all constants defined in the system. This list includes the names of all modules and classes.
pt: Module
mt: class
fn: constants
fs: constants
fd: Returns an array of the names of the constants accessible in mod. This includes the names of constants in any included modules (example at start of section).
pt: Module
mt: instance
fn: define_method
fs: define_method  define_method(symbol, method)
fd: Defines an instance method in the receiver. The method parameter can be a Proc or Method object. If a block is specified, it is used as the method body. This block is evaluated using instance_eval, a point that is tricky to demonstrate because define_method is private. (This is why we resort to the send hack in this example.)
pt: Module
mt: instance
fn: extend_object
fs: extend_object  extend_object(obj)
fd: Extends the specified object by adding this module's constants and methods (which are added as singleton methods). This is the callback method used by Object#extend.
pt: Module
mt: instance
fn: extended
fs: extended(p1)
fd: Not documented
pt: Module
mt: instance
fn: freeze
fs: freeze
fd: Prevents further modifications to mod.
pt: Module
mt: instance
fn: include?
fs: include?(module)
fd: Returns true if module is included in mod or one of mod's ancestors.
pt: Module
mt: instance
fn: include
fs: include  include(module, ...)
fd: Invokes Module.append_features on each parameter in turn.
pt: Module
mt: instance
fn: included
fs: included  included( othermod )
fd: Callback invoked whenever the receiver is included in another module or class. This should be used in preference to Module.append_features if your code wants to perform some action when a module is included in another.
pt: Module
mt: instance
fn: included_modules
fs: included_modules
fd: Returns the list of modules included in mod.
pt: Module
mt: instance
fn: instance_method
fs: instance_method(symbol)
fd: Returns an UnboundMethod representing the given instance method in mod.
pt: Module
mt: instance
fn: instance_methods
fs: instance_methods(include_super=true)
fd: Returns an array containing the names of public instance methods in the receiver. For a module, these are the public methods; for a class, they are the instance (not singleton) methods. With no argument, or with an argument that is false, the instance methods in mod are returned, otherwise the methods in mod and mod's superclasses are returned.
pt: Module
mt: instance
fn: method_added
fs: method_added(p1)
fd: Not documented
pt: Module
mt: instance
fn: method_defined?
fs: method_defined?(symbol)
fd: Returns true if the named method is defined by mod (or its included modules and, if mod is a class, its ancestors). Public and protected methods are matched.
pt: Module
mt: instance
fn: method_removed
fs: method_removed(p1)
fd: Not documented
pt: Module
mt: instance
fn: method_undefined
fs: method_undefined(p1)
fd: Not documented
pt: Module
mt: instance
fn: module_eval
fs: module_eval  mod.class_eval(string [, filename [, lineno]])
fd: Evaluates the string or block in the context of mod. This can be used to add methods to a class. module_eval returns the result of evaluating its argument. The optional filename and lineno parameters set the text for error messages.
pt: Module
mt: instance
fn: module_function
fs: module_function  module_function(symbol, ...)
fd: Creates module functions for the named methods. These functions may be called with the module as a receiver, and also become available as instance methods to classes that mix in the module. Module functions are copies of the original, and so may be changed independently. The instance-method versions are made private. If used with no arguments, subsequently defined methods become module functions.
pt: Module
mt: instance
fn: name
fs: name
fd: Returns the name of the module mod.
pt: Module
mt: instance
fn: nesting
fs: nesting
fd: Returns the list of Modules nested at the point of call.
pt: Module
mt: class
fn: new
fs: new
fd: Creates a new anonymous module. If a block is given, it is passed the module object, and the block is evaluated in the context of this module using module_eval.
pt: Module
mt: class
fn: private
fs: private  private                 => self
  private(symbol, ...)
fd: With no arguments, sets the default visibility for subsequently defined methods to private. With arguments, sets the named methods to have private visibility.
pt: Module
mt: instance
fn: private_class_method
fs: private_class_method(symbol, ...)
fd: Makes existing class methods private. Often used to hide the default constructor new.
pt: Module
mt: instance
fn: private_instance_methods
fs: private_instance_methods(include_super=true)
fd: Returns a list of the private instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included.
pt: Module
mt: instance
fn: private_method_defined?
fs: private_method_defined?(symbol)
fd: Returns true if the named private method is defined by _ mod_ (or its included modules and, if mod is a class, its ancestors).
pt: Module
mt: instance
fn: protected
fs: protected  protected                => self
  protected(symbol, ...)
fd: With no arguments, sets the default visibility for subsequently defined methods to protected. With arguments, sets the named methods to have protected visibility.
pt: Module
mt: instance
fn: protected_instance_methods
fs: protected_instance_methods(include_super=true)
fd: Returns a list of the protected instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included.
pt: Module
mt: instance
fn: protected_method_defined?
fs: protected_method_defined?(symbol)
fd: Returns true if the named protected method is defined by mod (or its included modules and, if mod is a class, its ancestors).
pt: Module
mt: instance
fn: public
fs: public  public                 => self
  public(symbol, ...)
fd: With no arguments, sets the default visibility for subsequently defined methods to public. With arguments, sets the named methods to have public visibility.
pt: Module
mt: instance
fn: public_class_method
fs: public_class_method(symbol, ...)
fd: Makes a list of existing class methods public.
pt: Module
mt: instance
fn: public_instance_methods
fs: public_instance_methods(include_super=true)
fd: Returns a list of the public instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included.
pt: Module
mt: instance
fn: public_method_defined?
fs: public_method_defined?(symbol)
fd: Returns true if the named public method is defined by mod (or its included modules and, if mod is a class, its ancestors).
pt: Module
mt: instance
fn: remove_class_variable
fs: remove_class_variable  remove_class_variable(sym)
fd: Removes the definition of the sym, returning that constant's value.
pt: Module
mt: instance
fn: remove_const
fs: remove_const  remove_const(sym)
fd: Removes the definition of the given constant, returning that constant's value. Predefined classes and singleton objects (such as true) cannot be removed.
pt: Module
mt: instance
fn: remove_method
fs: remove_method  remove_method(symbol)
fd: Removes the method identified by symbol from the current class. For an example, see Module.undef_method.
pt: Module
mt: instance
fn: to_s
fs: to_s
fd: Return a string representing this module or class. For basic classes and modules, this is the name. For singletons, we show information on the thing we're attached to as well.
pt: Module
mt: instance
fn: undef_method
fs: undef_method  undef_method(symbol)
fd: Prevents the current class from responding to calls to the named method. Contrast this with remove_method, which deletes the method from the particular class; Ruby will still search superclasses and mixed-in modules for a possible receiver.
pt: Module
mt: instance
fn: broadcast
fs: broadcast()
fd: Wake up all the waiters.
pt: MonitorMixin::ConditionVariable
mt: instance
fn: count_waiters
fs: count_waiters()
fd: 
pt: MonitorMixin::ConditionVariable
mt: instance
fn: new
fs: new(monitor)
fd: 
pt: MonitorMixin::ConditionVariable
mt: class
fn: signal
fs: signal()
fd: Wake up and run the next waiter
pt: MonitorMixin::ConditionVariable
mt: instance
fn: wait
fs: wait(timeout = nil)
fd: "Create a new timer with the argument timeout, and add the current thread to the list of waiters. Then the thread is stopped. It will be resumed when a corresponding #signal occurs."
pt: MonitorMixin::ConditionVariable
mt: instance
fn: wait_until
fs: wait_until()
fd: "call #wait until the supplied block returns true."
pt: MonitorMixin::ConditionVariable
mt: instance
fn: wait_while
fs: wait_while()
fd: "call #wait while the supplied block returns true."
pt: MonitorMixin::ConditionVariable
mt: instance
fn: extend_object
fs: extend_object(obj)
fd: 
pt: MonitorMixin
mt: class
fn: mon_enter
fs: mon_enter()
fd: Enters exclusive section.
pt: MonitorMixin
mt: instance
fn: mon_exit
fs: mon_exit()
fd: Leaves exclusive section.
pt: MonitorMixin
mt: instance
fn: mon_synchronize
fs: mon_synchronize()
fd: Enters exclusive section and executes the block. Leaves the exclusive section automatically when the block exits. See example under MonitorMixin.
pt: MonitorMixin
mt: instance
fn: mon_try_enter
fs: mon_try_enter()
fd: Attempts to enter exclusive section. Returns false if lock fails.
pt: MonitorMixin
mt: instance
fn: new
fs: new(*args)
fd: 
pt: MonitorMixin
mt: class
fn: new_cond
fs: new_cond()
fd: "FIXME: This isn't documented in Nutshell."
pt: MonitorMixin
mt: instance
fn: synchronize
fs: synchronize()
fd: "Alias for #mon_synchronize"
pt: MonitorMixin
mt: instance
fn: try_mon_enter
fs: try_mon_enter()
fd: "Alias for #mon_try_enter"
pt: MonitorMixin
mt: instance
fn: exclusive_unlock
fs: exclusive_unlock()
fd: If the mutex is locked, unlocks the mutex, wakes one waiting thread, and yields in a critical section.
pt: Mutex
mt: instance
fn: lock
fs: lock()
fd: Attempts to grab the lock and waits if it isn't available.
pt: Mutex
mt: instance
fn: locked?
fs: locked?()
fd: Returns true if this lock is currently held by some thread.
pt: Mutex
mt: instance
fn: new
fs: new()
fd: Creates a new Mutex
pt: Mutex
mt: class
fn: synchronize
fs: synchronize()
fd: Obtains a lock, runs the block, and releases the lock when the block completes. See the example under Mutex.
pt: Mutex
mt: instance
fn: try_lock
fs: try_lock()
fd: Attempts to obtain the lock and returns immediately. Returns true if the lock was granted.
pt: Mutex
mt: instance
fn: unlock
fs: unlock()
fd: Releases the lock. Returns nil if ref wasn't locked.
pt: Mutex
mt: instance
fn: append_features
fs: append_features(cl)
fd: 
pt: Mutex_m
mt: class
fn: define_aliases
fs: define_aliases(cl)
fd: 
pt: Mutex_m
mt: class
fn: extend_object
fs: extend_object(obj)
fd: 
pt: Mutex_m
mt: class
fn: mu_extended
fs: mu_extended()
fd: 
pt: Mutex_m
mt: instance
fn: mu_lock
fs: mu_lock()
fd: 
pt: Mutex_m
mt: instance
fn: mu_locked?
fs: mu_locked?()
fd: 
pt: Mutex_m
mt: instance
fn: mu_synchronize
fs: mu_synchronize()
fd: locking
pt: Mutex_m
mt: instance
fn: mu_try_lock
fs: mu_try_lock()
fd: 
pt: Mutex_m
mt: instance
fn: mu_unlock
fs: mu_unlock()
fd: 
pt: Mutex_m
mt: instance
fn: new
fs: new(*args)
fd: 
pt: Mutex_m
mt: class
fn: full_class_name
fs: full_class_name()
fd: Return the full class name (with '::' between the components) or &quot;&quot; if there's no class name
pt: NameDescriptor
mt: instance
fn: new
fs: new(arg)
fd: arg may be
pt: NameDescriptor
mt: class
fn: name
fs: name
fd: Return the name associated with this NameError exception.
pt: NameError
mt: instance
fn: new
fs: new(msg [, name])
fd: Construct a new NameError exception. If given the name parameter may subsequently be examined using the NameError.name method.
pt: NameError
mt: class
fn: to_s
fs: to_s
fd: Produce a nicely-formated string representing the NameError.
pt: NameError
mt: instance
fn: apop?
fs: apop?()
fd: Always returns true.
pt: Net::APOP
mt: instance
fn: abort
fs: abort()
fd: Aborts the previous command (ABOR command).
pt: Net::FTP
mt: instance
fn: acct
fs: acct(account)
fd: "Sends the ACCT command. TODO: more info."
pt: Net::FTP
mt: instance
fn: chdir
fs: chdir(dirname)
fd: Changes the (remote) directory.
pt: Net::FTP
mt: instance
fn: close
fs: close()
fd: "Closes the connection. Further operations are impossible until you open a new connection with #connect."
pt: Net::FTP
mt: instance
fn: closed?
fs: closed?()
fd: Returns true iff the connection is closed.
pt: Net::FTP
mt: instance
fn: connect
fs: connect(host, port = FTP_PORT)
fd: Establishes an FTP connection to host, optionally overriding the default port. If the environment variable SOCKS_SERVER is set, sets up the connection through a SOCKS proxy. Raises an exception (typically Errno::ECONNREFUSED) if the connection cannot be established.
pt: Net::FTP
mt: instance
fn: delete
fs: delete(filename)
fd: Deletes a file on the server.
pt: Net::FTP
mt: instance
fn: dir
fs: dir(*args)
fd: "Alias for #list"
pt: Net::FTP
mt: instance
fn: get
fs: get(remotefile, localfile = File.basename(remotefile)
fd: "Retrieves remotefile in whatever mode the session is set (text or binary). See #gettextfile and #getbinaryfile."
pt: Net::FTP
mt: instance
fn: getbinaryfile
fs: getbinaryfile(remotefile, localfile = File.basename(remotefile)
fd: Retrieves remotefile in binary mode, storing the result in localfile. If a block is supplied, it is passed the retrieved data in blocksize chunks.
pt: Net::FTP
mt: instance
fn: getdir
fs: getdir()
fd: "Alias for #pwd"
pt: Net::FTP
mt: instance
fn: gettextfile
fs: gettextfile(remotefile, localfile = File.basename(remotefile)
fd: Retrieves remotefile in ASCII (text) mode, storing the result in localfile. If a block is supplied, it is passed the retrieved data one line at a time.
pt: Net::FTP
mt: instance
fn: help
fs: help(arg = nil)
fd: Issues the HELP command.
pt: Net::FTP
mt: instance
fn: list
fs: list(*args)
fd: Returns an array of file information in the directory (the output is like `ls -l`). If a block is given, it iterates through the listing.
pt: Net::FTP
mt: instance
fn: login
fs: login(user = "anonymous", passwd = nil, acct = nil)
fd: Logs in to the remote host. The session must have been previously connected. If user is the string &quot;anonymous&quot; and the password is nil, a password of user@host is synthesized. If the acct parameter is not nil, an FTP ACCT command is sent following the successful login. Raises an exception on error (typically Net::FTPPermError).
pt: Net::FTP
mt: instance
fn: ls
fs: ls(*args)
fd: "Alias for #list"
pt: Net::FTP
mt: instance
fn: mdtm
fs: mdtm(filename)
fd: "Issues the MDTM command. TODO: more info."
pt: Net::FTP
mt: instance
fn: mkdir
fs: mkdir(dirname)
fd: Creates a remote directory.
pt: Net::FTP
mt: instance
fn: mtime
fs: mtime(filename, local = false)
fd: Returns the last modification time of the (remote) file. If local is true, it is returned as a local time, otherwise it's a UTC time.
pt: Net::FTP
mt: instance
fn: new
fs: new(host = nil, user = nil, passwd = nil, acct = nil)
fd: "Creates and returns a new FTP object. If a host is given, a connection is made. Additionally, if the user is given, the given user name, password, and (optionally) account are used to log in. See #login."
pt: Net::FTP
mt: class
fn: nlst
fs: nlst(dir = nil)
fd: Returns an array of filenames in the remote directory.
pt: Net::FTP
mt: instance
fn: noop
fs: noop()
fd: Issues a NOOP command.
pt: Net::FTP
mt: instance
fn: open
fs: open(host, user = nil, passwd = nil, acct = nil)
fd: A synonym for FTP.new, but with a mandatory host parameter.
pt: Net::FTP
mt: class
fn: put
fs: put(localfile, remotefile = File.basename(localfile)
fd: "Transfers localfile to the server in whatever mode the session is set (text or binary). See #puttextfile and #putbinaryfile."
pt: Net::FTP
mt: instance
fn: putbinaryfile
fs: putbinaryfile(localfile, remotefile = File.basename(localfile)
fd: Transfers localfile to the server in binary mode, storing the result in remotefile. If a block is supplied, calls it, passing in the transmitted data in blocksize chunks.
pt: Net::FTP
mt: instance
fn: puttextfile
fs: puttextfile(localfile, remotefile = File.basename(localfile)
fd: Transfers localfile to the server in ASCII (text) mode, storing the result in remotefile. If callback or an associated block is supplied, calls it, passing in the transmitted data one line at a time.
pt: Net::FTP
mt: instance
fn: pwd
fs: pwd()
fd: Returns the current remote directory.
pt: Net::FTP
mt: instance
fn: quit
fs: quit()
fd: Exits the FTP session.
pt: Net::FTP
mt: instance
fn: rename
fs: rename(fromname, toname)
fd: Renames a file on the server.
pt: Net::FTP
mt: instance
fn: retrbinary
fs: retrbinary(cmd, blocksize, rest_offset = nil)
fd: Puts the connection into binary (image) mode, issues the given command, and fetches the data returned, passing it to the associated block in chunks of blocksize characters. Note that cmd is a server command (such as &quot;RETR myfile&quot;).
pt: Net::FTP
mt: instance
fn: retrlines
fs: retrlines(cmd)
fd: Puts the connection into ASCII (text) mode, issues the given command, and passes the resulting data, one line at a time, to the associated block. If no block is given, prints the lines. Note that cmd is a server command (such as &quot;RETR myfile&quot;).
pt: Net::FTP
mt: instance
fn: return_code=
fs: return_code=(s)
fd: Obsolete
pt: Net::FTP
mt: instance
fn: return_code
fs: return_code()
fd: Obsolete
pt: Net::FTP
mt: instance
fn: rmdir
fs: rmdir(dirname)
fd: Removes a remote directory.
pt: Net::FTP
mt: instance
fn: sendcmd
fs: sendcmd(cmd)
fd: Sends a command and returns the response.
pt: Net::FTP
mt: instance
fn: set_socket
fs: set_socket(sock, get_greeting = true)
fd: WRITEME or make private
pt: Net::FTP
mt: instance
fn: site
fs: site(arg)
fd: Issues a SITE command.
pt: Net::FTP
mt: instance
fn: size
fs: size(filename)
fd: Returns the size of the given (remote) filename.
pt: Net::FTP
mt: instance
fn: status
fs: status()
fd: Returns the status (STAT command).
pt: Net::FTP
mt: instance
fn: storbinary
fs: storbinary(cmd, file, blocksize, rest_offset = nil)
fd: Puts the connection into binary (image) mode, issues the given server-side command (such as &quot;STOR myfile&quot;), and sends the contents of the file named file to the server. If the optional block is given, it also passes it the data, in chunks of blocksize characters.
pt: Net::FTP
mt: instance
fn: storlines
fs: storlines(cmd, file)
fd: Puts the connection into ASCII (text) mode, issues the given server-side command (such as &quot;STOR myfile&quot;), and sends the contents of the file named file to the server, one line at a time. If the optional block is given, it also passes it the lines.
pt: Net::FTP
mt: instance
fn: system
fs: system()
fd: Returns system information.
pt: Net::FTP
mt: instance
fn: voidcmd
fs: voidcmd(cmd)
fd: Sends a command and expect a response beginning with '2'.
pt: Net::FTP
mt: instance
fn: active?
fs: active?()
fd: "Alias for #started?"
pt: Net::HTTP
mt: instance
fn: copy
fs: copy(path, initheader = nil)
fd: Sends a COPY request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: default_port
fs: default_port()
fd: The default port to use for HTTP requests; defaults to 80.
pt: Net::HTTP
mt: class
fn: delete
fs: delete(path, initheader = {'Depth' => 'Infinity'})
fd: Sends a DELETE request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: finish
fs: finish()
fd: Finishes HTTP session and closes TCP connection. Raises IOError if not started.
pt: Net::HTTP
mt: instance
fn: get
fs: get(uri_or_host, path = nil, port = nil)
fd: "Send a GET request to the target and return the response as a string. The target can either be specified as (uri), or as (host, path, port = 80); so:"
pt: Net::HTTP
mt: class
fn: get
fs: get(path, initheader = nil, dest = nil)
fd: Gets data from path on the connected-to host. header must be a Hash like { 'Accept' =&gt; '*/*', ... }.
pt: Net::HTTP
mt: instance
fn: get2
fs: get2(path, initheader = nil)
fd: "Alias for #request_get"
pt: Net::HTTP
mt: instance
fn: get_print
fs: get_print(uri_or_host, path = nil, port = nil)
fd: "Get body from target and output it to +$stdout+. The target can either be specified as (uri), or as (host, path, port = 80); so:"
pt: Net::HTTP
mt: class
fn: get_response
fs: get_response(uri_or_host, path = nil, port = nil, &block)
fd: "Send a GET request to the target and return the response as a Net::HTTPResponse object. The target can either be specified as (uri), or as (host, path, port = 80); so:"
pt: Net::HTTP
mt: class
fn: head
fs: head(path, initheader = nil)
fd: Gets only the header from path on the connected-to host. header is a Hash like { 'Accept' =&gt; '*/*', ... }.
pt: Net::HTTP
mt: instance
fn: head2
fs: head2(path, initheader = nil, &block)
fd: "Alias for #request_head"
pt: Net::HTTP
mt: instance
fn: http_default_port
fs: http_default_port()
fd: The default port to use for HTTP requests; defaults to 80.
pt: Net::HTTP
mt: class
fn: https_default_port
fs: https_default_port()
fd: The default port to use for HTTPS requests; defaults to 443.
pt: Net::HTTP
mt: class
fn: inspect
fs: inspect()
fd: 
pt: Net::HTTP
mt: instance
fn: lock
fs: lock(path, body, initheader = nil)
fd: Sends a LOCK request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: mkcol
fs: mkcol(path, body = nil, initheader = nil)
fd: Sends a MKCOL request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: move
fs: move(path, initheader = nil)
fd: Sends a MOVE request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: new
fs: new(address, port = nil)
fd: Creates a new Net::HTTP object for the specified address. This method does not open the TCP connection.
pt: Net::HTTP
mt: class
fn: options
fs: options(path, initheader = nil)
fd: Sends a OPTIONS request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: peer_cert
fs: peer_cert()
fd: 
pt: Net::HTTP
mt: instance
fn: post
fs: post(path, data, initheader = nil, dest = nil)
fd: Posts data (must be a String) to path. header must be a Hash like { 'Accept' =&gt; '*/*', ... }.
pt: Net::HTTP
mt: instance
fn: post2
fs: post2(path, data, initheader = nil)
fd: "Alias for #request_post"
pt: Net::HTTP
mt: instance
fn: post_form
fs: post_form(url, params)
fd: "Posts HTML form data to the URL. Form data must be represented as a Hash of String to String, e.g:"
pt: Net::HTTP
mt: class
fn: propfind
fs: propfind(path, body = nil, initheader = {'Depth' => '0'})
fd: Sends a PROPFIND request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: proppatch
fs: proppatch(path, body, initheader = nil)
fd: Sends a PROPPATCH request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: proxy?
fs: proxy?()
fd: True if self is a HTTP proxy class.
pt: Net::HTTP
mt: instance
fn: Proxy
fs: Proxy(p_addr, p_port = nil, p_user = nil, p_pass = nil)
fd: Creates an HTTP proxy class. Arguments are address/port of proxy host and username/password if authorization on proxy server is required. You can replace the HTTP class with created proxy class.
pt: Net::HTTP
mt: class
fn: proxy_address
fs: proxy_address()
fd: Address of proxy host. If self does not use a proxy, nil.
pt: Net::HTTP
mt: instance
fn: proxy_class?
fs: proxy_class?()
fd: returns true if self is a class which was created by HTTP::Proxy.
pt: Net::HTTP
mt: class
fn: proxy_pass
fs: proxy_pass()
fd: User password for accessing proxy. If self does not use a proxy, nil.
pt: Net::HTTP
mt: instance
fn: proxy_port
fs: proxy_port()
fd: Port number of proxy host. If self does not use a proxy, nil.
pt: Net::HTTP
mt: instance
fn: proxy_user
fs: proxy_user()
fd: User name for accessing proxy. If self does not use a proxy, nil.
pt: Net::HTTP
mt: instance
fn: proxyaddr
fs: proxyaddr()
fd: "Alias for #proxy_address"
pt: Net::HTTP
mt: instance
fn: proxyport
fs: proxyport()
fd: "Alias for #proxy_port"
pt: Net::HTTP
mt: instance
fn: read_timeout=
fs: read_timeout=(sec)
fd: Setter for the read_timeout attribute.
pt: Net::HTTP
mt: instance
fn: request
fs: request(req, body = nil)
fd: Sends an HTTPRequest object REQUEST to the HTTP server. This method also sends DATA string if REQUEST is a post/put request. Giving DATA for get/head request causes ArgumentError.
pt: Net::HTTP
mt: instance
fn: request_get
fs: request_get(path, initheader = nil)
fd: Sends a GET request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: request_head
fs: request_head(path, initheader = nil, &block)
fd: Sends a HEAD request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: request_post
fs: request_post(path, data, initheader = nil)
fd: Sends a POST request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: send_request
fs: send_request(name, path, data = nil, header = nil)
fd: Sends an HTTP request to the HTTP server. This method also sends DATA string if DATA is given.
pt: Net::HTTP
mt: instance
fn: set_debug_output
fs: set_debug_output(output)
fd: <b>WARNING</b> This method causes serious security hole. Never use this method in production code.
pt: Net::HTTP
mt: instance
fn: ssl_context_accessor
fs: ssl_context_accessor(name)
fd: 
pt: Net::HTTP
mt: class
fn: ssl_timeout=
fs: ssl_timeout=(sec)
fd: 
pt: Net::HTTP
mt: instance
fn: ssl_timeout
fs: ssl_timeout()
fd: 
pt: Net::HTTP
mt: instance
fn: start
fs: start(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)
fd: creates a new Net::HTTP object and opens its TCP connection and HTTP session. If the optional block is given, the newly created Net::HTTP object is passed to it and closed when the block finishes. In this case, the return value of this method is the return value of the block. If no block is given, the return value of this method is the newly created Net::HTTP object itself, and the caller is responsible for closing it upon completion.
pt: Net::HTTP
mt: class
fn: start
fs: start( {|http| ...}
fd: Opens TCP connection and HTTP session.
pt: Net::HTTP
mt: instance
fn: started?
fs: started?()
fd: returns true if the HTTP session is started.
pt: Net::HTTP
mt: instance
fn: timeout=
fs: timeout=(sec)
fd: "Alias for #ssl_timeout="
pt: Net::HTTP
mt: instance
fn: trace
fs: trace(path, initheader = nil)
fd: Sends a TRACE request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: unlock
fs: unlock(path, body, initheader = nil)
fd: Sends a UNLOCK request to the path and gets a response, as an HTTPResponse object.
pt: Net::HTTP
mt: instance
fn: use_ssl=
fs: use_ssl=(flag)
fd: Turn on/off SSL. This flag must be set before starting session. If you change use_ssl value after session started, a Net::HTTP object raises IOError.
pt: Net::HTTP
mt: instance
fn: use_ssl?
fs: use_ssl?()
fd: 
pt: Net::HTTP
mt: instance
fn: use_ssl
fs: use_ssl()
fd: "Alias for #use_ssl?"
pt: Net::HTTP
mt: instance
fn: version_1_1?
fs: version_1_1?()
fd: true if net/http is in version 1.1 compatible mode. Defaults to true.
pt: Net::HTTP
mt: class
fn: version_1_1
fs: version_1_1()
fd: Turns on net/http 1.1 (ruby 1.6) features. Defaults to OFF in ruby 1.8.
pt: Net::HTTP
mt: class
fn: version_1_2?
fs: version_1_2?()
fd: true if net/http is in version 1.2 mode. Defaults to true.
pt: Net::HTTP
mt: class
fn: version_1_2
fs: version_1_2()
fd: Turns on net/http 1.2 (ruby 1.8) features. Defaults to ON in ruby 1.8.
pt: Net::HTTP
mt: class
fn: body=
fs: body=(str)
fd: 
pt: Net::HTTPGenericRequest
mt: instance
fn: body_exist?
fs: body_exist?()
fd: 
pt: Net::HTTPGenericRequest
mt: instance
fn: body_stream=
fs: body_stream=(input)
fd: 
pt: Net::HTTPGenericRequest
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: Net::HTTPGenericRequest
mt: instance
fn: new
fs: new(m, reqbody, resbody, path, initheader = nil)
fd: 
pt: Net::HTTPGenericRequest
mt: class
fn: request_body_permitted?
fs: request_body_permitted?()
fd: 
pt: Net::HTTPGenericRequest
mt: instance
fn: response_body_permitted?
fs: response_body_permitted?()
fd: 
pt: Net::HTTPGenericRequest
mt: instance
fn: add_field
fs: add_field(key, val)
fd: "[Ruby 1.8.3] Adds header field instead of replace. Second argument val must be a String. See also #[]=, #[] and #get_fields."
pt: Net::HTTPHeader
mt: instance
fn: basic_auth
fs: basic_auth(account, password)
fd: "Set the Authorization: header for &quot;Basic&quot; authorization."
pt: Net::HTTPHeader
mt: instance
fn: canonical_each
fs: canonical_each()
fd: "Alias for #each_capitalized"
pt: Net::HTTPHeader
mt: instance
fn: chunked?
fs: chunked?()
fd: Returns &quot;true&quot; if the &quot;transfer-encoding&quot; header is present and set to &quot;chunked&quot;. This is an HTTP/1.1 feature, allowing the the content to be sent in &quot;chunks&quot; without at the outset stating the entire content length.
pt: Net::HTTPHeader
mt: instance
fn: content_length=
fs: content_length=(len)
fd: 
pt: Net::HTTPHeader
mt: instance
fn: content_length
fs: content_length()
fd: "Returns an Integer object which represents the Content-Length: header field or nil if that field is not provided."
pt: Net::HTTPHeader
mt: instance
fn: content_range
fs: content_range()
fd: "Returns a Range object which represents Content-Range: header field. This indicates, for a partial entity body, where this fragment fits inside the full entity body, as range of byte offsets."
pt: Net::HTTPHeader
mt: instance
fn: content_type=
fs: content_type=(type, params = {})
fd: "Alias for #set_content_type"
pt: Net::HTTPHeader
mt: instance
fn: content_type
fs: content_type()
fd: "Returns a content type string such as &quot;text/html&quot;. This method returns nil if Content-Type: header field does not exist."
pt: Net::HTTPHeader
mt: instance
fn: delete
fs: delete(key)
fd: Removes a header field.
pt: Net::HTTPHeader
mt: instance
fn: each
fs: each(
fd: "Alias for #each_header"
pt: Net::HTTPHeader
mt: instance
fn: each_capitalized
fs: each_capitalized()
fd: "As for #each_header, except the keys are provided in capitalized form."
pt: Net::HTTPHeader
mt: instance
fn: each_capitalized_name
fs: each_capitalized_name()
fd: Iterates for each capitalized header names.
pt: Net::HTTPHeader
mt: instance
fn: each_header
fs: each_header( {|+key+, +value+| ...}
fd: Iterates for each header names and values.
pt: Net::HTTPHeader
mt: instance
fn: each_key
fs: each_key()
fd: "Alias for #each_name"
pt: Net::HTTPHeader
mt: instance
fn: each_name
fs: each_name()
fd: Iterates for each header names.
pt: Net::HTTPHeader
mt: instance
fn: each_value
fs: each_value( {|+value+| ...}
fd: Iterates for each header values.
pt: Net::HTTPHeader
mt: instance
fn: fetch
fs: fetch(key, *args)
fd: Returns the header field corresponding to the case-insensitive key. Returns the default value args, or the result of the block, or nil, if there's no header field named key. See Hash#fetch
pt: Net::HTTPHeader
mt: instance
fn: form_data=
fs: form_data=(params, sep = '&')
fd: "Alias for #set_form_data"
pt: Net::HTTPHeader
mt: instance
fn: get_fields
fs: get_fields(key)
fd: "[Ruby 1.8.3] Returns an array of header field strings corresponding to the case-insensitive key. This method allows you to get duplicated header fields without any processing. See also #[]."
pt: Net::HTTPHeader
mt: instance
fn: initialize_http_header
fs: initialize_http_header(initheader)
fd: 
pt: Net::HTTPHeader
mt: instance
fn: key?
fs: key?(key)
fd: true if key header exists.
pt: Net::HTTPHeader
mt: instance
fn: main_type
fs: main_type()
fd: "Returns a content type string such as &quot;text&quot;. This method returns nil if Content-Type: header field does not exist."
pt: Net::HTTPHeader
mt: instance
fn: proxy_basic_auth
fs: proxy_basic_auth(account, password)
fd: "Set Proxy-Authorization: header for &quot;Basic&quot; authorization."
pt: Net::HTTPHeader
mt: instance
fn: range=
fs: range=(r, e = nil)
fd: "Alias for #set_range"
pt: Net::HTTPHeader
mt: instance
fn: range
fs: range()
fd: "Returns an Array of Range objects which represents Range: header field, or nil if there is no such header."
pt: Net::HTTPHeader
mt: instance
fn: range_length
fs: range_length()
fd: "The length of the range represented in Content-Range: header."
pt: Net::HTTPHeader
mt: instance
fn: set_content_type
fs: set_content_type(type, params = {})
fd: "Set Content-Type: header field by type and params. type must be a String, params must be a Hash."
pt: Net::HTTPHeader
mt: instance
fn: set_form_data
fs: set_form_data(params, sep = '&')
fd: Set header fields and a body from HTML form data. params should be a Hash containing HTML form data. Optional argument sep means data record separator.
pt: Net::HTTPHeader
mt: instance
fn: set_range
fs: set_range(r, e = nil)
fd: "Set Range: header from Range (arg r) or beginning index and length from it (arg idx&amp;len)."
pt: Net::HTTPHeader
mt: instance
fn: sub_type
fs: sub_type()
fd: "Returns a content type string such as &quot;html&quot;. This method returns nil if Content-Type: header field does not exist or sub-type is not given (e.g. &quot;Content-Type: text&quot;)."
pt: Net::HTTPHeader
mt: instance
fn: to_hash
fs: to_hash()
fd: Returns a Hash consist of header names and values.
pt: Net::HTTPHeader
mt: instance
fn: type_params
fs: type_params()
fd: Returns content type parameters as a Hash as like {&quot;charset&quot; =&gt; &quot;iso-2022-jp&quot;}.
pt: Net::HTTPHeader
mt: instance
fn: new
fs: new(path, initheader = nil)
fd: Creates HTTP request object.
pt: Net::HTTPRequest
mt: class
fn: body
fs: body()
fd: Returns the entity body.
pt: Net::HTTPResponse
mt: instance
fn: body_permitted?
fs: body_permitted?()
fd: true if the response has body.
pt: Net::HTTPResponse
mt: class
fn: entity
fs: entity()
fd: "Alias for #body"
pt: Net::HTTPResponse
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: Net::HTTPResponse
mt: instance
fn: read_body
fs: read_body(dest = nil, &block)
fd: Gets entity body. If the block given, yields it to block. The body is provided in fragments, as it is read in from the socket.
pt: Net::HTTPResponse
mt: instance
fn: to_ary
fs: to_ary()
fd: For backward compatibility. To allow Net::HTTP 1.1 style assignment e.g.
pt: Net::HTTPResponse
mt: instance
fn: value
fs: value()
fd: Raises HTTP error if the response is not 2xx.
pt: Net::HTTPResponse
mt: instance
fn: add_authenticator
fs: add_authenticator(auth_type, authenticator)
fd: Adds an authenticator for Net::IMAP#authenticate. auth_type is the type of authentication this authenticator supports (for instance, &quot;LOGIN&quot;). The authenticator is an object which defines a process() method to handle authentication with the server. See Net::IMAP::LoginAuthenticator and Net::IMAP::CramMD5Authenticator for examples.
pt: Net::IMAP
mt: class
fn: add_response_handler
fs: add_response_handler(handler = Proc.new)
fd: Adds a response handler. For example, to detect when the server sends us a new EXISTS response (which normally indicates new messages being added to the mail box), you could add the following handler after selecting the mailbox.
pt: Net::IMAP
mt: instance
fn: append
fs: append(mailbox, message, flags = nil, date_time = nil)
fd: "Sends a APPEND command to append the message to the end of the mailbox. The optional flags argument is an array of flags to initially passing to the new message. The optional date_time argument specifies the creation time to assign to the new message; it defaults to the current time. For example:"
pt: Net::IMAP
mt: instance
fn: authenticate
fs: authenticate(auth_type, *args)
fd: "Sends an AUTHENTICATE command to authenticate the client. The auth_type parameter is a string that represents the authentication mechanism to be used. Currently Net::IMAP supports authentication mechanisms:"
pt: Net::IMAP
mt: instance
fn: media_subtype
fs: media_subtype()
fd: "Obsolete: use subtype instead. Calling this will generate a warning message to stderr, then return the value of subtype."
pt: Net::IMAP::BodyTypeBasic
mt: instance
fn: multipart?
fs: multipart?()
fd: 
pt: Net::IMAP::BodyTypeBasic
mt: instance
fn: media_subtype
fs: media_subtype()
fd: "Obsolete: use subtype instead. Calling this will generate a warning message to stderr, then return the value of subtype."
pt: Net::IMAP::BodyTypeMessage
mt: instance
fn: multipart?
fs: multipart?()
fd: 
pt: Net::IMAP::BodyTypeMessage
mt: instance
fn: media_subtype
fs: media_subtype()
fd: "Obsolete: use subtype instead. Calling this will generate a warning message to stderr, then return the value of subtype."
pt: Net::IMAP::BodyTypeMultipart
mt: instance
fn: multipart?
fs: multipart?()
fd: 
pt: Net::IMAP::BodyTypeMultipart
mt: instance
fn: media_subtype
fs: media_subtype()
fd: "Obsolete: use subtype instead. Calling this will generate a warning message to stderr, then return the value of subtype."
pt: Net::IMAP::BodyTypeText
mt: instance
fn: multipart?
fs: multipart?()
fd: 
pt: Net::IMAP::BodyTypeText
mt: instance
fn: capability
fs: capability()
fd: Sends a CAPABILITY command, and returns an array of capabilities that the server supports. Each capability is a string. See [IMAP] for a list of possible capabilities.
pt: Net::IMAP
mt: instance
fn: check
fs: check()
fd: Sends a CHECK command to request a checkpoint of the currently selected mailbox. This performs implementation-specific housekeeping, for instance, reconciling the mailbox's in-memory and on-disk state.
pt: Net::IMAP
mt: instance
fn: close
fs: close()
fd: Sends a CLOSE command to close the currently selected mailbox. The CLOSE command permanently removes from the mailbox all messages that have the \Deleted flag set.
pt: Net::IMAP
mt: instance
fn: copy
fs: copy(set, mailbox)
fd: Sends a COPY command to copy the specified message(s) to the end of the specified destination mailbox. The set parameter is a number or an array of numbers or a Range object. The number is a message sequence number.
pt: Net::IMAP
mt: instance
fn: new
fs: new(user, password)
fd: 
pt: Net::IMAP::CramMD5Authenticator
mt: class
fn: process
fs: process(challenge)
fd: 
pt: Net::IMAP::CramMD5Authenticator
mt: instance
fn: create
fs: create(mailbox)
fd: Sends a CREATE command to create a new mailbox.
pt: Net::IMAP
mt: instance
fn: debug=
fs: debug=(val)
fd: Sets the debug mode.
pt: Net::IMAP
mt: class
fn: debug
fs: debug()
fd: Returns the debug mode.
pt: Net::IMAP
mt: class
fn: decode_utf7
fs: decode_utf7(s)
fd: Decode a string from modified UTF-7 format to UTF-8.
pt: Net::IMAP
mt: class
fn: delete
fs: delete(mailbox)
fd: Sends a DELETE command to remove the mailbox.
pt: Net::IMAP
mt: instance
fn: disconnect
fs: disconnect()
fd: Disconnects from the server.
pt: Net::IMAP
mt: instance
fn: disconnected?
fs: disconnected?()
fd: Returns true if disconnected from the server.
pt: Net::IMAP
mt: instance
fn: encode_utf7
fs: encode_utf7(s)
fd: Encode a string from UTF-8 format to modified UTF-7.
pt: Net::IMAP
mt: class
fn: examine
fs: examine(mailbox)
fd: "Sends a EXAMINE command to select a mailbox so that messages in the mailbox can be accessed. Behaves the same as #select(), except that the selected mailbox is identified as read-only."
pt: Net::IMAP
mt: instance
fn: expunge
fs: expunge()
fd: Sends a EXPUNGE command to permanently remove from the currently selected mailbox all messages that have the \Deleted flag set.
pt: Net::IMAP
mt: instance
fn: fetch
fs: fetch(set, attr)
fd: "Sends a FETCH command to retrieve data associated with a message in the mailbox. The set parameter is a number or an array of numbers or a Range object. The number is a message sequence number. attr is a list of attributes to fetch; see the documentation for Net::IMAP::FetchData for a list of valid attributes. The return value is an array of Net::IMAP::FetchData. For example:"
pt: Net::IMAP
mt: instance
fn: getacl
fs: getacl(mailbox)
fd: Send the GETACL command along with specified mailbox. If this mailbox exists, an array containing objects of Net::IMAP::MailboxACLItem will be returned.
pt: Net::IMAP
mt: instance
fn: getquota
fs: getquota(mailbox)
fd: Sends the GETQUOTA command along with specified mailbox. If this mailbox exists, then an array containing a Net::IMAP::MailboxQuota object is returned. This command generally is only available to server admin.
pt: Net::IMAP
mt: instance
fn: getquotaroot
fs: getquotaroot(mailbox)
fd: Sends the GETQUOTAROOT command along with specified mailbox. This command is generally available to both admin and user. If mailbox exists, returns an array containing objects of Net::IMAP::MailboxQuotaRoot and Net::IMAP::MailboxQuota.
pt: Net::IMAP
mt: instance
fn: list
fs: list(refname, mailbox)
fd: "Sends a LIST command, and returns a subset of names from the complete set of all names available to the client. refname provides a context (for instance, a base directory in a directory-based mailbox hierarchy). mailbox specifies a mailbox or (via wildcards) mailboxes under that context. Two wildcards may be used in mailbox: '*', which matches all characters <b>including</b> the hierarchy delimiter (for instance, '/' on a UNIX-hosted directory-based mailbox hierarchy); and '%', which matches all characters <b>except</b> the hierarchy delimiter."
pt: Net::IMAP
mt: instance
fn: login
fs: login(user, password)
fd: "Sends a LOGIN command to identify the client and carries the plaintext password authenticating this user. Note that, unlike calling #authenticate() with an auth_type of &quot;LOGIN&quot;, #login() does <b>not</b> use the login authenticator."
pt: Net::IMAP
mt: instance
fn: new
fs: new(user, password)
fd: 
pt: Net::IMAP::LoginAuthenticator
mt: class
fn: process
fs: process(data)
fd: 
pt: Net::IMAP::LoginAuthenticator
mt: instance
fn: logout
fs: logout()
fd: Sends a LOGOUT command to inform the server that the client is done with the connection.
pt: Net::IMAP
mt: instance
fn: lsub
fs: lsub(refname, mailbox)
fd: "Sends a LSUB command, and returns a subset of names from the set of names that the user has declared as being &quot;active&quot; or &quot;subscribed&quot;. refname and mailbox are interpreted as for #list(). The return value is an array of +Net::IMAP::MailboxList+."
pt: Net::IMAP
mt: instance
fn: new
fs: new(host, port = PORT, usessl = false, certs = nil, verify = false)
fd: Creates a new Net::IMAP object and connects it to the specified port (143 by default) on the named host. If usessl is true, then an attempt will be made to use SSL (now TLS) to connect to the server. For this to work OpenSSL [OSSL] and the Ruby OpenSSL [RSSL] extensions need to be installed. The certs parameter indicates the path or file containing the CA cert of the server, and the verify parameter is for the OpenSSL verification callback.
pt: Net::IMAP
mt: class
fn: noop
fs: noop()
fd: Sends a NOOP command to the server. It does nothing.
pt: Net::IMAP
mt: instance
fn: remove_response_handler
fs: remove_response_handler(handler)
fd: Removes the response handler.
pt: Net::IMAP
mt: instance
fn: rename
fs: rename(mailbox, newname)
fd: Sends a RENAME command to change the name of the mailbox to newname.
pt: Net::IMAP
mt: instance
fn: search
fs: search(keys, charset = nil)
fd: Sends a SEARCH command to search the mailbox for messages that match the given searching criteria, and returns message sequence numbers. keys can either be a string holding the entire search string, or a single-dimension array of search keywords and arguments. The following are some common search criteria; see [IMAP] section 6.4.4 for a full list.
pt: Net::IMAP
mt: instance
fn: select
fs: select(mailbox)
fd: Sends a SELECT command to select a mailbox so that messages in the mailbox can be accessed.
pt: Net::IMAP
mt: instance
fn: setacl
fs: setacl(mailbox, user, rights)
fd: Sends the SETACL command along with mailbox, user and the rights that user is to have on that mailbox. If rights is nil, then that user will be stripped of any rights to that mailbox. The IMAP ACL commands are described in [RFC-2086].
pt: Net::IMAP
mt: instance
fn: setquota
fs: setquota(mailbox, quota)
fd: Sends a SETQUOTA command along with the specified mailbox and quota. If quota is nil, then quota will be unset for that mailbox. Typically one needs to be logged in as server admin for this to work. The IMAP quota commands are described in [RFC-2087].
pt: Net::IMAP
mt: instance
fn: sort
fs: sort(sort_keys, search_keys, charset)
fd: "Sends a SORT command to sort messages in the mailbox. Returns an array of message sequence numbers. For example:"
pt: Net::IMAP
mt: instance
fn: status
fs: status(mailbox, attr)
fd: "Sends a STATUS command, and returns the status of the indicated mailbox. attr is a list of one or more attributes that we are request the status of. Supported attributes include:"
pt: Net::IMAP
mt: instance
fn: store
fs: store(set, attr, flags)
fd: "Sends a STORE command to alter data associated with messages in the mailbox, in particular their flags. The set parameter is a number or an array of numbers or a Range object. Each number is a message sequence number. attr is the name of a data item to store: 'FLAGS' means to replace the message's flag list with the provided one; '+FLAGS' means to add the provided flags; and '-FLAGS' means to remove them. flags is a list of flags."
pt: Net::IMAP
mt: instance
fn: subscribe
fs: subscribe(mailbox)
fd: "Sends a SUBSCRIBE command to add the specified mailbox name to the server's set of &quot;active&quot; or &quot;subscribed&quot; mailboxes as returned by #lsub()."
pt: Net::IMAP
mt: instance
fn: thread
fs: thread(algorithm, search_keys, charset)
fd: "As for #search(), but returns message sequence numbers in threaded format, as a Net::IMAP::ThreadMember tree. The supported algorithms are:"
pt: Net::IMAP
mt: instance
fn: uid_copy
fs: uid_copy(set, mailbox)
fd: "As for #copy(), but set contains unique identifiers."
pt: Net::IMAP
mt: instance
fn: uid_fetch
fs: uid_fetch(set, attr)
fd: "As for #fetch(), but set contains unique identifiers."
pt: Net::IMAP
mt: instance
fn: uid_search
fs: uid_search(keys, charset = nil)
fd: "As for #search(), but returns unique identifiers."
pt: Net::IMAP
mt: instance
fn: uid_sort
fs: uid_sort(sort_keys, search_keys, charset)
fd: "As for #sort(), but returns an array of unique identifiers."
pt: Net::IMAP
mt: instance
fn: uid_store
fs: uid_store(set, attr, flags)
fd: "As for #store(), but set contains unique identifiers."
pt: Net::IMAP
mt: instance
fn: uid_thread
fs: uid_thread(algorithm, search_keys, charset)
fd: "As for #thread(), but returns unique identifiers instead of message sequence numbers."
pt: Net::IMAP
mt: instance
fn: unsubscribe
fs: unsubscribe(mailbox)
fd: Sends a UNSUBSCRIBE command to remove the specified mailbox name from the server's set of &quot;active&quot; or &quot;subscribed&quot; mailboxes.
pt: Net::IMAP
mt: instance
fn: active?
fs: active?()
fd: "Alias for #started?"
pt: Net::POP3
mt: instance
fn: apop?
fs: apop?()
fd: Does this instance use APOP authentication?
pt: Net::POP3
mt: instance
fn: APOP
fs: APOP( isapop )
fd: "Returns the APOP class if isapop is true; otherwise, returns the POP class. For example:"
pt: Net::POP3
mt: class
fn: auth_only
fs: auth_only( address, port = nil, account = nil, password = nil, isapop = false )
fd: Opens a POP3 session, attempts authentication, and quits.
pt: Net::POP3
mt: class
fn: auth_only
fs: auth_only( account, password )
fd: Starts a pop3 session, attempts authentication, and quits. This method must not be called while POP3 session is opened. This method raises POPAuthenticationError if authentication fails.
pt: Net::POP3
mt: instance
fn: default_port
fs: default_port()
fd: The default port for POP3 connections, port 110
pt: Net::POP3
mt: class
fn: delete_all
fs: delete_all( address, port = nil, account = nil, password = nil, isapop = false, &block )
fd: Starts a POP3 session and deletes all messages on the server. If a block is given, each POPMail object is yielded to it before being deleted.
pt: Net::POP3
mt: class
fn: delete_all
fs: delete_all( {|message| ...}
fd: Deletes all messages on the server.
pt: Net::POP3
mt: instance
fn: each
fs: each( )
fd: "Alias for #each_mail"
pt: Net::POP3
mt: instance
fn: each_mail
fs: each_mail( )
fd: "Yields each message to the passed-in block in turn. Equivalent to:"
pt: Net::POP3
mt: instance
fn: finish
fs: finish()
fd: Finishes a POP3 session and closes TCP connection.
pt: Net::POP3
mt: instance
fn: foreach
fs: foreach( address, port = nil, account = nil, password = nil, isapop = false )
fd: "Starts a POP3 session and iterates over each POPMail object, yielding it to the block. This method is equivalent to:"
pt: Net::POP3
mt: class
fn: inspect
fs: inspect()
fd: Provide human-readable stringification of class state.
pt: Net::POP3
mt: instance
fn: mails
fs: mails()
fd: Returns an array of Net::POPMail objects, representing all the messages on the server. This array is renewed when the session restarts; otherwise, it is fetched from the server the first time this method is called (directly or indirectly) and cached.
pt: Net::POP3
mt: instance
fn: n_bytes
fs: n_bytes()
fd: Returns the total size in bytes of all the messages on the POP server.
pt: Net::POP3
mt: instance
fn: n_mails
fs: n_mails()
fd: Returns the number of messages on the POP server.
pt: Net::POP3
mt: instance
fn: new
fs: new( addr, port = nil, isapop = false )
fd: Creates a new POP3 object.
pt: Net::POP3
mt: class
fn: read_timeout=
fs: read_timeout=( sec )
fd: Set the read timeout.
pt: Net::POP3
mt: instance
fn: reset
fs: reset()
fd: Resets the session. This clears all &quot;deleted&quot; marks from messages.
pt: Net::POP3
mt: instance
fn: set_debug_output
fs: set_debug_output( arg )
fd: "<b>WARNING</b>: This method causes a serious security hole. Use this method only for debugging."
pt: Net::POP3
mt: instance
fn: start
fs: start( address, port = nil, account = nil, password = nil, isapop = false )
fd: Creates a new POP3 object and open the connection. Equivalent to
pt: Net::POP3
mt: class
fn: start
fs: start( account, password )
fd: Starts a POP3 session.
pt: Net::POP3
mt: instance
fn: started?
fs: started?()
fd: true if the POP3 session has started.
pt: Net::POP3
mt: instance
fn: all
fs: all( dest = '' )
fd: "Alias for #pop"
pt: Net::POPMail
mt: instance
fn: delete!
fs: delete!()
fd: "Alias for #delete"
pt: Net::POPMail
mt: instance
fn: delete
fs: delete()
fd: Marks a message for deletion on the server. Deletion does not actually occur until the end of the session; deletion may be cancelled for all marked messages by calling POP3#reset().
pt: Net::POPMail
mt: instance
fn: deleted?
fs: deleted?()
fd: True if the mail has been deleted.
pt: Net::POPMail
mt: instance
fn: header
fs: header( dest = '' )
fd: Fetches the message header.
pt: Net::POPMail
mt: instance
fn: inspect
fs: inspect()
fd: Provide human-readable stringification of class state.
pt: Net::POPMail
mt: instance
fn: mail
fs: mail( dest = '' )
fd: "Alias for #pop"
pt: Net::POPMail
mt: instance
fn: pop
fs: pop( dest = '' )
fd: This method fetches the message. If called with a block, the message is yielded to the block one chunk at a time. If called without a block, the message is returned as a String. The optional dest argument will be prepended to the returned String; this argument is essentially obsolete.
pt: Net::POPMail
mt: instance
fn: top
fs: top( lines, dest = '' )
fd: Fetches the message header and lines lines of body.
pt: Net::POPMail
mt: instance
fn: uidl
fs: uidl()
fd: "Alias for #unique_id"
pt: Net::POPMail
mt: instance
fn: unique_id
fs: unique_id()
fd: Returns the unique-id of the message. Normally the unique-id is a hash string of the message.
pt: Net::POPMail
mt: instance
fn: default_port
fs: default_port()
fd: The default SMTP port, port 25.
pt: Net::SMTP
mt: class
fn: esmtp=
fs: esmtp=( bool )
fd: "Set whether to use ESMTP or not. This should be done before calling #start. Note that if #start is called in ESMTP mode, and the connection fails due to a ProtocolError, the SMTP object will automatically switch to plain SMTP mode and retry (but not vice versa)."
pt: Net::SMTP
mt: instance
fn: esmtp?
fs: esmtp?()
fd: true if the SMTP object uses ESMTP (which it does by default).
pt: Net::SMTP
mt: instance
fn: esmtp
fs: esmtp()
fd: "Alias for #esmtp?"
pt: Net::SMTP
mt: instance
fn: finish
fs: finish()
fd: Finishes the SMTP session and closes TCP connection. Raises IOError if not started.
pt: Net::SMTP
mt: instance
fn: inspect
fs: inspect()
fd: Provide human-readable stringification of class state.
pt: Net::SMTP
mt: instance
fn: new
fs: new( address, port = nil )
fd: Creates a new Net::SMTP object.
pt: Net::SMTP
mt: class
fn: open_message_stream
fs: open_message_stream( from_addr, *to_addrs )
fd: "Opens a message writer stream and gives it to the block. The stream is valid only in the block, and has these methods:"
pt: Net::SMTP
mt: instance
fn: read_timeout=
fs: read_timeout=( sec )
fd: Set the number of seconds to wait until timing-out a read(2) call.
pt: Net::SMTP
mt: instance
fn: ready
fs: ready( from_addr, *to_addrs )
fd: "Alias for #open_message_stream"
pt: Net::SMTP
mt: instance
fn: send_mail
fs: send_mail( msgstr, from_addr, *to_addrs )
fd: "Alias for #send_message"
pt: Net::SMTP
mt: instance
fn: send_message
fs: send_message( msgstr, from_addr, *to_addrs )
fd: Sends msgstr as a message. Single CR (&quot;\r&quot;) and LF (&quot;\n&quot;) found in the msgstr, are converted into the CR LF pair. You cannot send a binary message with this method. msgstr should include both the message headers and body.
pt: Net::SMTP
mt: instance
fn: sendmail
fs: sendmail( msgstr, from_addr, *to_addrs )
fd: "Alias for #send_message"
pt: Net::SMTP
mt: instance
fn: set_debug_output
fs: set_debug_output( arg )
fd: "WARNING: This method causes serious security holes. Use this method for only debugging."
pt: Net::SMTP
mt: instance
fn: start
fs: start( address, port = nil, helo = 'localhost.localdomain', user = nil, secret = nil, authtype = nil)
fd: Creates a new Net::SMTP object and connects to the server.
pt: Net::SMTP
mt: class
fn: start
fs: start( helo = 'localhost.localdomain', user = nil, secret = nil, authtype = nil )
fd: Opens a TCP connection and starts the SMTP session.
pt: Net::SMTP
mt: instance
fn: started?
fs: started?()
fd: true if the SMTP session has been started.
pt: Net::SMTP
mt: instance
fn: binmode=
fs: binmode=(mode)
fd: Turn newline conversion on (false) or off (true).
pt: Net::Telnet
mt: instance
fn: binmode
fs: binmode(mode = nil)
fd: Turn newline conversion on (mode == false) or off (mode == true), or return the current value (mode is not specified).
pt: Net::Telnet
mt: instance
fn: cmd
fs: cmd(options)
fd: Send a command to the host.
pt: Net::Telnet
mt: instance
fn: login
fs: login(options, password = nil)
fd: Login to the host with a given username and password.
pt: Net::Telnet
mt: instance
fn: new
fs: new(options)
fd: Creates a new Net::Telnet object.
pt: Net::Telnet
mt: class
fn: preprocess
fs: preprocess(string)
fd: Preprocess received data from the host.
pt: Net::Telnet
mt: instance
fn: print
fs: print(string)
fd: Sends a string to the host.
pt: Net::Telnet
mt: instance
fn: puts
fs: puts(string)
fd: Sends a string to the host.
pt: Net::Telnet
mt: instance
fn: telnetmode=
fs: telnetmode=(mode)
fd: Turn telnet command interpretation on (true) or off (false). It should be on for true telnet sessions, off if using Net::Telnet to connect to a non-telnet service such as SMTP.
pt: Net::Telnet
mt: instance
fn: telnetmode
fs: telnetmode(mode = nil)
fd: Set telnet command interpretation on (mode == true) or off (mode == false), or return the current value (mode not provided). It should be on for true telnet sessions, off if using Net::Telnet to connect to a non-telnet service such as SMTP.
pt: Net::Telnet
mt: instance
fn: waitfor
fs: waitfor(options)
fd: Read data from the host until a certain sequence is matched.
pt: Net::Telnet
mt: instance
fn: write
fs: write(string)
fd: Write string to the host.
pt: Net::Telnet
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: Net::WriteAdapter
mt: instance
fn: new
fs: new(socket, method)
fd: 
pt: Net::WriteAdapter
mt: class
fn: print
fs: print(str)
fd: "Alias for #write"
pt: Net::WriteAdapter
mt: instance
fn: printf
fs: printf(*args)
fd: 
pt: Net::WriteAdapter
mt: instance
fn: puts
fs: puts(str = '')
fd: 
pt: Net::WriteAdapter
mt: instance
fn: write
fs: write(str)
fd: 
pt: Net::WriteAdapter
mt: instance
fn: inspect
fs: inspect
fd: Always returns the string &quot;nil&quot;.
pt: NilClass
mt: instance
fn: new
fs: new
fd: 
pt: NilClass
mt: class
fn: nil?
fs: nil?()
fd: "call_seq:"
pt: NilClass
mt: instance
fn: to_a
fs: to_a
fd: Always returns an empty array.
pt: NilClass
mt: instance
fn: to_f
fs: to_f
fd: Always returns zero.
pt: NilClass
mt: instance
fn: to_i
fs: to_i
fd: Always returns zero.
pt: NilClass
mt: instance
fn: to_s
fs: to_s
fd: Always returns the empty string.
pt: NilClass
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: NilClass
mt: instance
fn: guess1
fs: guess1(str)
fd: Returns guessed encoding of str as integer.
pt: NKF
mt: class
fn: guess2
fs: guess2(str)
fd: Returns guessed encoding of str as integer by nkf routine.
pt: NKF
mt: class
fn: nkf
fs: nkf(opt, str)
fd: Convert str and return converted result. Conversion details are specified by opt as String.
pt: NKF
mt: class
fn: args
fs: args
fd: Return the arguments passed in as the third parameter to the constructor.
pt: NoMethodError
mt: instance
fn: new
fs: new(msg, name [, args])
fd: Construct a NoMethodError exception for a method of the given name called with the given arguments. The name may be accessed using the #name method on the resulting object, and the arguments using the #args method.
pt: NoMethodError
mt: class
fn: abs
fs: abs
fd: Returns the absolute value of num.
pt: Numeric
mt: instance
fn: angle
fs: angle()
fd: "Alias for #arg"
pt: Numeric
mt: instance
fn: arg
fs: arg()
fd: See Complex#arg.
pt: Numeric
mt: instance
fn: ceil
fs: ceil
fd: Returns the smallest Integer greater than or equal to num. Class Numeric achieves this by converting itself to a Float then invoking Float#ceil.
pt: Numeric
mt: instance
fn: coerce
fs: coerce(numeric)
fd: "If aNumeric is the same type as num, returns an array containing aNumeric and num. Otherwise, returns an array with both aNumeric and num represented as Float objects. This coercion mechanism is used by Ruby to handle mixed-type numeric operations: it is intended to find a compatible common type between the two operands of the operator."
pt: Numeric
mt: instance
fn: conj
fs: conj()
fd: "Alias for #conjugate"
pt: Numeric
mt: instance
fn: conjugate
fs: conjugate()
fd: "See Complex#conjugate (short answer: returns self)."
pt: Numeric
mt: instance
fn: div
fs: div(numeric)
fd: Uses / to perform division, then converts the result to an integer. Numeric does not define the / operator; this is left to subclasses.
pt: Numeric
mt: instance
fn: divmod
fs: divmod( aNumeric )
fd: Returns an array containing the quotient and modulus obtained by dividing num by aNumeric. If q, r = x.divmod(y), then
pt: Numeric
mt: instance
fn: eql?
fs: eql?(numeric)
fd: Returns true if num and numeric are the same type and have equal values.
pt: Numeric
mt: instance
fn: floor
fs: floor
fd: Returns the largest integer less than or equal to num. Numeric implements this by converting anInteger to a Float and invoking Float#floor.
pt: Numeric
mt: instance
fn: im
fs: im()
fd: Returns a Complex number (0,self).
pt: Numeric
mt: instance
fn: imag
fs: imag()
fd: "Alias for #image"
pt: Numeric
mt: instance
fn: image
fs: image()
fd: The imaginary part of a complex number, i.e. 0.
pt: Numeric
mt: instance
fn: integer?
fs: integer?
fd: Returns true if num is an Integer (including Fixnum and Bignum).
pt: Numeric
mt: instance
fn: modulo
fs: modulo(numeric)
fd: Equivalent to num.divmod(aNumeric)[1].
pt: Numeric
mt: instance
fn: nonzero?
fs: nonzero?
fd: "Returns num if num is not zero, nil otherwise. This behavior is useful when chaining comparisons:"
pt: Numeric
mt: instance
fn: polar
fs: polar()
fd: See Complex#polar.
pt: Numeric
mt: instance
fn: quo
fs: quo(numeric)
fd: Equivalent to Numeric#/, but overridden in subclasses.
pt: Numeric
mt: instance
fn: real
fs: real()
fd: The real part of a complex number, i.e. self.
pt: Numeric
mt: instance
fn: remainder
fs: remainder(numeric)
fd: If num and numeric have different signs, returns mod-numeric; otherwise, returns mod. In both cases mod is the value num.modulo(numeric). The differences between remainder and modulo (%) are shown in the table under Numeric#divmod.
pt: Numeric
mt: instance
fn: round
fs: round
fd: Rounds num to the nearest integer. Numeric implements this by converting itself to a Float and invoking Float#round.
pt: Numeric
mt: instance
fn: singleton_method_added
fs: singleton_method_added(p1)
fd: Trap attempts to add methods to Numeric objects. Always raises a TypeError
pt: Numeric
mt: instance
fn: step
fs: step(limit, step )
fd: Invokes block with the sequence of numbers starting at num, incremented by step on each call. The loop finishes when the value to be passed to the block is greater than limit (if step is positive) or less than limit (if step is negative). If all the arguments are integers, the loop operates using an integer counter. If any of the arguments are floating point numbers, all are converted to floats, and the loop is executed floor(n + n*epsilon)+ 1 times, where n = (limit - num)/step. Otherwise, the loop starts at num, uses either the &lt; or &gt; operator to compare the counter against limit, and increments itself using the + operator.
pt: Numeric
mt: instance
fn: to_int
fs: to_int
fd: Invokes the child class's to_i method to convert num to an integer.
pt: Numeric
mt: instance
fn: truncate
fs: truncate
fd: Returns num truncated to an integer. Numeric implements this by converting its value to a float and invoking Float#truncate.
pt: Numeric
mt: instance
fn: zero?
fs: zero?
fd: Returns true if num has a zero value.
pt: Numeric
mt: instance
fn: class
fs: class
fd: Returns the class of obj, now preferred over Object#type, as an object's type in Ruby is only loosely tied to that object's class. This method must always be called with an explicit receiver, as class is also a reserved word in Ruby.
pt: Object
mt: instance
fn: clone
fs: clone
fd: Produces a shallow copy of obj---the instance variables of obj are copied, but not the objects they reference. Copies the frozen and tainted state of obj. See also the discussion under Object#dup.
pt: Object
mt: instance
fn: dclone
fs: dclone()
fd: 
pt: Object
mt: instance
fn: display
fs: display(port=$>)
fd: "Prints obj on the given port (default $&gt;). Equivalent to:"
pt: Object
mt: instance
fn: dup
fs: dup
fd: Produces a shallow copy of obj---the instance variables of obj are copied, but not the objects they reference. dup copies the tainted state of obj. See also the discussion under Object#clone. In general, clone and dup may have different semantics in descendent classes. While clone is used to duplicate an object, including its internal state, dup typically uses the class of the descendent object to create the new instance.
pt: Object
mt: instance
fn: enum_for
fs: enum_for(method = :each, *args)
fd: Returns Enumerable::Enumerator.new(self, method, *args).
pt: Object
mt: instance
fn: eql?
fs: eql?(other)
fd: Equality---At the Object level, == returns true only if obj and other are the same object. Typically, this method is overridden in descendent classes to provide class-specific meaning.
pt: Object
mt: instance
fn: equal?
fs: equal?(other)
fd: Equality---At the Object level, == returns true only if obj and other are the same object. Typically, this method is overridden in descendent classes to provide class-specific meaning.
pt: Object
mt: instance
fn: extend
fs: extend(module, ...)
fd: Adds to obj the instance methods from each module given as a parameter.
pt: Object
mt: instance
fn: freeze
fs: freeze
fd: Prevents further modifications to obj. A TypeError will be raised if modification is attempted. There is no way to unfreeze a frozen object. See also Object#frozen?.
pt: Object
mt: instance
fn: frozen?
fs: frozen?
fd: Returns the freeze status of obj.
pt: Object
mt: instance
fn: hash
fs: hash
fd: Generates a Fixnum hash value for this object. This function must have the property that a.eql?(b) implies a.hash == b.hash. The hash value is used by class Hash. Any hash value that exceeds the capacity of a Fixnum will be truncated before being used.
pt: Object
mt: instance
fn: id
fs: id
fd: Soon-to-be deprecated version of Object#object_id.
pt: Object
mt: instance
fn: inspect
fs: inspect
fd: Returns a string containing a human-readable representation of obj. If not overridden, uses the to_s method to generate the string.
pt: Object
mt: instance
fn: instance_eval
fs: instance_eval(string [, filename [, lineno]] )
fd: Evaluates a string containing Ruby source code, or the given block, within the context of the receiver (obj). In order to set the context, the variable self is set to obj while the code is executing, giving the code access to obj's instance variables. In the version of instance_eval that takes a String, the optional second and third parameters supply a filename and starting line number that are used when reporting compilation errors.
pt: Object
mt: instance
fn: instance_of?
fs: instance_of?(class)
fd: Returns true if obj is an instance of the given class. See also Object#kind_of?.
pt: Object
mt: instance
fn: instance_variable_defined?
fs: instance_variable_defined?(symbol)
fd: Returns true if the given instance variable is defined in obj.
pt: Object
mt: instance
fn: instance_variable_get
fs: instance_variable_get(symbol)
fd: Returns the value of the given instance variable, or nil if the instance variable is not set. The @ part of the variable name should be included for regular instance variables. Throws a NameError exception if the supplied symbol is not valid as an instance variable name.
pt: Object
mt: instance
fn: instance_variable_set
fs: instance_variable_set(symbol, obj)
fd: Sets the instance variable names by symbol to object, thereby frustrating the efforts of the class's author to attempt to provide proper encapsulation. The variable did not have to exist prior to this call.
pt: Object
mt: instance
fn: instance_variables
fs: instance_variables
fd: Returns an array of instance variable names for the receiver. Note that simply defining an accessor does not create the corresponding instance variable.
pt: Object
mt: instance
fn: is_a?
fs: is_a?(class)
fd: Returns true if class is the class of obj, or if class is one of the superclasses of obj or modules included in obj.
pt: Object
mt: instance
fn: kind_of?
fs: kind_of?(class)
fd: Returns true if class is the class of obj, or if class is one of the superclasses of obj or modules included in obj.
pt: Object
mt: instance
fn: method
fs: method(sym)
fd: Looks up the named method as a receiver in obj, returning a Method object (or raising NameError). The Method object acts as a closure in obj's object instance, so instance variables and the value of self remain available.
pt: Object
mt: instance
fn: methods
fs: methods
fd: Returns a list of the names of methods publicly accessible in obj. This will include all the methods accessible in obj's ancestors.
pt: Object
mt: instance
fn: new
fs: new()
fd: Not documented
pt: Object
mt: class
fn: nil?
fs: nil?()
fd: "call_seq:"
pt: Object
mt: instance
fn: object_id
fs: object_id
fd: Returns an integer identifier for obj. The same number will be returned on all calls to id for a given object, and no two active objects will share an id. Object#object_id is a different concept from the :name notation, which returns the symbol id of name. Replaces the deprecated Object#id.
pt: Object
mt: instance
fn: private_methods
fs: private_methods(all=true)
fd: Returns the list of private methods accessible to obj. If the all parameter is set to false, only those methods in the receiver will be listed.
pt: Object
mt: instance
fn: protected_methods
fs: protected_methods(all=true)
fd: Returns the list of protected methods accessible to obj. If the all parameter is set to false, only those methods in the receiver will be listed.
pt: Object
mt: instance
fn: public_methods
fs: public_methods(all=true)
fd: Returns the list of public methods accessible to obj. If the all parameter is set to false, only those methods in the receiver will be listed.
pt: Object
mt: instance
fn: remove_instance_variable
fs: remove_instance_variable(symbol)
fd: Removes the named instance variable from obj, returning that variable's value.
pt: Object
mt: instance
fn: respond_to?
fs: respond_to?(symbol, include_private=false)
fd: Returns true&gt; if obj responds to the given method. Private methods are included in the search only if the optional second parameter evaluates to true.
pt: Object
mt: instance
fn: send
fs: send(symbol [, args...])
fd: Invokes the method identified by symbol, passing it any arguments specified. You can use __send__ if the name send clashes with an existing method in obj.
pt: Object
mt: instance
fn: singleton_method_added
fs: singleton_method_added  singleton_method_added(symbol)
fd: Invoked as a callback whenever a singleton method is added to the receiver.
pt: Object
mt: instance
fn: singleton_method_removed
fs: singleton_method_removed  singleton_method_removed(symbol)
fd: Invoked as a callback whenever a singleton method is removed from the receiver.
pt: Object
mt: instance
fn: singleton_method_undefined
fs: singleton_method_undefined  singleton_method_undefined(symbol)
fd: Invoked as a callback whenever a singleton method is undefined in the receiver.
pt: Object
mt: instance
fn: singleton_methods
fs: singleton_methods(all=true)
fd: Returns an array of the names of singleton methods for obj. If the optional all parameter is true, the list will include methods in modules included in obj.
pt: Object
mt: instance
fn: taint
fs: taint
fd: Marks obj as tainted---if the $SAFE level is set appropriately, many method calls which might alter the running programs environment will refuse to accept tainted strings.
pt: Object
mt: instance
fn: tainted?
fs: tainted?
fd: Returns true if the object is tainted.
pt: Object
mt: instance
fn: to_a
fs: to_a
fd: Returns an array representation of obj. For objects of class Object and others that don't explicitly override the method, the return value is an array containing self. However, this latter behavior will soon be obsolete.
pt: Object
mt: instance
fn: to_enum
fs: to_enum(method = :each, *args)
fd: Returns Enumerable::Enumerator.new(self, method, *args).
pt: Object
mt: instance
fn: to_s
fs: to_s
fd: Returns a string representing obj. The default to_s prints the object's class and an encoding of the object id. As a special case, the top-level object that is the initial execution context of Ruby programs returns ``main.''
pt: Object
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Object
mt: instance
fn: to_yaml_properties
fs: to_yaml_properties()
fd: 
pt: Object
mt: instance
fn: to_yaml_style
fs: to_yaml_style()
fd: 
pt: Object
mt: instance
fn: type
fs: type
fd: Deprecated synonym for Object#class.
pt: Object
mt: instance
fn: untaint
fs: untaint
fd: Removes the taint from obj.
pt: Object
mt: instance
fn: add_finalizer
fs: add_finalizer(p1)
fd: deprecated
pt: ObjectSpace
mt: class
fn: call_finalizer
fs: call_finalizer(p1)
fd: deprecated
pt: ObjectSpace
mt: class
fn: define_finalizer
fs: define_finalizer(obj, aProc=proc()
fd: Adds aProc as a finalizer, to be called after obj was destroyed.
pt: ObjectSpace
mt: class
fn: each_object
fs: each_object([module])
fd: Calls the block once for each living, nonimmediate object in this Ruby process. If module is specified, calls the block for only those classes or modules that match (or are a subclass of) module. Returns the number of objects found. Immediate objects (Fixnums, Symbols true, false, and nil) are never returned. In the example below, each_object returns both the numbers we defined and several constants defined in the Math module.
pt: ObjectSpace
mt: class
fn: finalizers
fs: finalizers()
fd: deprecated
pt: ObjectSpace
mt: class
fn: garbage_collect
fs: garbage_collect
fd: Initiates garbage collection, unless manually disabled.
pt: ObjectSpace
mt: class
fn: remove_finalizer
fs: remove_finalizer(p1)
fd: deprecated
pt: ObjectSpace
mt: class
fn: undefine_finalizer
fs: undefine_finalizer(obj)
fd: Removes all finalizers for obj.
pt: ObjectSpace
mt: class
fn: add_observer
fs: add_observer(observer)
fd: Add observer as an observer on this object. observer will now receive notifications.
pt: Observable
mt: instance
fn: changed?
fs: changed?()
fd: Query the changed state of this object.
pt: Observable
mt: instance
fn: changed
fs: changed(state=true)
fd: Set the changed state of this object. Notifications will be sent only if the changed state is true.
pt: Observable
mt: instance
fn: count_observers
fs: count_observers()
fd: Return the number of observers associated with this object.
pt: Observable
mt: instance
fn: delete_observer
fs: delete_observer(observer)
fd: Delete observer as an observer on this object. It will no longer receive notifications.
pt: Observable
mt: instance
fn: delete_observers
fs: delete_observers()
fd: Delete all observers associated with this object.
pt: Observable
mt: instance
fn: notify_observers
fs: notify_observers(*arg)
fd: If this object's changed state is true, invoke the update method in each currently associated observer in turn, passing it the given arguments. The changed state is then set to false.
pt: Observable
mt: instance
fn: popen3
fs: popen3(*cmd)
fd: "Open stdin, stdout, and stderr streams and start external executable. Non-block form:"
pt: Open3
mt: instance
fn: delete_field
fs: delete_field(name)
fd: Remove the named field from the object.
pt: OpenStruct
mt: instance
fn: initialize_copy
fs: initialize_copy(orig)
fd: Duplicate an OpenStruct object members.
pt: OpenStruct
mt: instance
fn: inspect
fs: inspect()
fd: Returns a string containing a detailed summary of the keys and values.
pt: OpenStruct
mt: instance
fn: marshal_dump
fs: marshal_dump()
fd: 
pt: OpenStruct
mt: instance
fn: marshal_load
fs: marshal_load(x)
fd: 
pt: OpenStruct
mt: instance
fn: new
fs: new(hash=nil)
fd: Create a new OpenStruct object. The optional hash, if given, will generate attributes and values. For example.
pt: OpenStruct
mt: class
fn: new_ostruct_member
fs: new_ostruct_member(name)
fd: 
pt: OpenStruct
mt: instance
fn: to_s
fs: to_s()
fd: "Alias for #inspect"
pt: OpenStruct
mt: instance
fn: new
fs: new(message, io)
fd: 
pt: OpenURI::HTTPError
mt: class
fn: charset
fs: charset()
fd: returns a charset parameter in Content-Type field. It is downcased for canonicalization.
pt: OpenURI::Meta
mt: instance
fn: content_encoding
fs: content_encoding()
fd: returns a list of encodings in Content-Encoding field as an Array of String. The encodings are downcased for canonicalization.
pt: OpenURI::Meta
mt: instance
fn: content_type
fs: content_type()
fd: returns &quot;type/subtype&quot; which is MIME Content-Type. It is downcased for canonicalization. Content-Type parameters are stripped.
pt: OpenURI::Meta
mt: instance
fn: last_modified
fs: last_modified()
fd: returns a Time which represents Last-Modified field.
pt: OpenURI::Meta
mt: instance
fn: open
fs: open(*rest, &block)
fd: OpenURI::OpenRead#open provides `open' for URI::HTTP and URI::FTP.
pt: OpenURI::OpenRead
mt: instance
fn: read
fs: read(options={})
fd: OpenURI::OpenRead#read([options]) reads a content referenced by self and returns the content as string. The string is extended with OpenURI::Meta. The argument `options' is same as OpenURI::OpenRead#open.
pt: OpenURI::OpenRead
mt: instance
fn: complete
fs: complete(key, icase = false, pat = nil)
fd: 
pt: OptionParser::Completion
mt: instance
fn: convert
fs: convert(opt = nil, val = nil, *)
fd: 
pt: OptionParser::Completion
mt: instance
fn: incompatible_argument_styles
fs: incompatible_argument_styles(*)
fd: 
pt: OptionParser::NoArgument
mt: class
fn: parse
fs: parse(arg, argv)
fd: Raises an exception if any arguments given.
pt: OptionParser::NoArgument
mt: instance
fn: pattern
fs: pattern()
fd: 
pt: OptionParser::NoArgument
mt: class
fn: parse
fs: parse(arg, argv, &error)
fd: Parses argument if given, or uses default value.
pt: OptionParser::OptionalArgument
mt: instance
fn: parse
fs: parse(arg, argv, &error)
fd: Returns nil if argument is not present or begins with '-'.
pt: OptionParser::PlacedArgument
mt: instance
fn: parse
fs: parse(arg, argv)
fd: Raises an exception if argument is not present.
pt: OptionParser::RequiredArgument
mt: instance
fn: guess
fs: guess(arg)
fd: Guesses argument style from arg. Returns corresponding OptionParser::Switch class (OptionalArgument, etc.).
pt: OptionParser::Switch
mt: class
fn: incompatible_argument_styles
fs: incompatible_argument_styles(arg, t)
fd: 
pt: OptionParser::Switch
mt: class
fn: new
fs: new(pattern = nil, conv = nil, short = nil, long = nil, arg = nil, desc = ([] if short or long)
fd: 
pt: OptionParser::Switch
mt: class
fn: pattern
fs: pattern()
fd: 
pt: OptionParser::Switch
mt: class
fn: summarize
fs: summarize(sdone = [], ldone = [], width = 1, max = width - 1, indent = "")
fd: Produces the summary text. Each line of the summary is yielded to the block (without newline).
pt: OptionParser::Switch
mt: instance
fn: switch_name
fs: switch_name()
fd: Main name of the switch.
pt: OptionParser
mt: instance
fn: error
fs: error(msg)
fd: Show an error and exit
pt: Options::OptionList
mt: class
fn: help_output
fs: help_output()
fd: 
pt: Options::OptionList
mt: class
fn: options
fs: options()
fd: 
pt: Options::OptionList
mt: class
fn: strip_output
fs: strip_output(text)
fd: 
pt: Options::OptionList
mt: class
fn: usage
fs: usage(generator_names)
fd: Show usage and exit
pt: Options::OptionList
mt: class
fn: parse
fs: parse(argv, generators)
fd: Parse command line options. We're passed a hash containing output generators, keyed by the generator name
pt: Options
mt: instance
fn: title=
fs: title=(string)
fd: Set the title, but only if not already set. This means that a title set from the command line trumps one set in a source file
pt: Options
mt: instance
fn: title
fs: title()
fd: 
pt: Options
mt: instance
fn: parsedate
fs: parsedate(str, comp=false)
fd: "Parse a string representation of a date into values. For example:"
pt: ParseDate
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: ParseError
mt: instance
fn: message
fs: message()
fd: Default stringizing method to emit standard error message.
pt: ParseError
mt: instance
fn: new
fs: new(*args)
fd: 
pt: ParseError
mt: class
fn: reason
fs: reason()
fd: Returns error reason. Override this for I18N.
pt: ParseError
mt: instance
fn: recover
fs: recover(argv)
fd: Pushes back erred argument(s) to argv.
pt: ParseError
mt: instance
fn: set_option
fs: set_option(opt, eq)
fd: 
pt: ParseError
mt: instance
fn: to_s
fs: to_s()
fd: "Alias for #message"
pt: ParseError
mt: instance
fn: absolute?
fs: absolute?()
fd: Predicate method for testing whether a path is absolute. It returns true if the pathname begins with a slash.
pt: Pathname
mt: instance
fn: ascend
fs: ascend()
fd: Iterates over and yields a new Pathname object for each element in the given path in ascending order.
pt: Pathname
mt: instance
fn: atime
fs: atime()
fd: See File.atime. Returns last access time.
pt: Pathname
mt: instance
fn: basename
fs: basename(*args)
fd: See File.basename. Returns the last component of the path.
pt: Pathname
mt: instance
fn: blockdev?
fs: blockdev?()
fd: See FileTest.blockdev?.
pt: Pathname
mt: instance
fn: chardev?
fs: chardev?()
fd: See FileTest.chardev?.
pt: Pathname
mt: instance
fn: chdir
fs: chdir(&block)
fd: Pathname#chdir is <b>obsoleted</b> at 1.8.1.
pt: Pathname
mt: instance
fn: children
fs: children(with_directory=true)
fd: Returns the children of the directory (files and subdirectories, not recursive) as an array of Pathname objects. By default, the returned pathnames will have enough information to access the files. If you set with_directory to false, then the returned pathnames will contain the filename only.
pt: Pathname
mt: instance
fn: chmod
fs: chmod(mode)
fd: See File.chmod. Changes permissions.
pt: Pathname
mt: instance
fn: chown
fs: chown(owner, group)
fd: See File.chown. Change owner and group of file.
pt: Pathname
mt: instance
fn: chroot
fs: chroot()
fd: Pathname#chroot is <b>obsoleted</b> at 1.8.1.
pt: Pathname
mt: instance
fn: cleanpath
fs: cleanpath(consider_symlink=false)
fd: Returns clean pathname of self with consecutive slashes and useless dots removed. The filesystem is not accessed.
pt: Pathname
mt: instance
fn: ctime
fs: ctime()
fd: See File.ctime. Returns last (directory entry, not file) change time.
pt: Pathname
mt: instance
fn: delete
fs: delete()
fd: "Alias for #unlink"
pt: Pathname
mt: instance
fn: descend
fs: descend()
fd: Iterates over and yields a new Pathname object for each element in the given path in descending order.
pt: Pathname
mt: instance
fn: dir_foreach
fs: dir_foreach(*args, &block)
fd: Pathname#dir_foreach is <b>obsoleted</b> at 1.8.1.
pt: Pathname
mt: instance
fn: directory?
fs: directory?()
fd: See FileTest.directory?.
pt: Pathname
mt: instance
fn: dirname
fs: dirname()
fd: See File.dirname. Returns all but the last component of the path.
pt: Pathname
mt: instance
fn: each_entry
fs: each_entry()
fd: Iterates over the entries (files and subdirectories) in the directory. It yields a Pathname object for each entry.
pt: Pathname
mt: instance
fn: each_filename
fs: each_filename( {|filename| ...}
fd: Iterates over each component of the path.
pt: Pathname
mt: instance
fn: each_line
fs: each_line(*args)
fd: "#each_line iterates over the line in the file. It yields a String object for each line."
pt: Pathname
mt: instance
fn: entries
fs: entries()
fd: Return the entries (files and subdirectories) in the directory, each as a Pathname object.
pt: Pathname
mt: instance
fn: eql?
fs: eql?(other)
fd: "Alias for #=="
pt: Pathname
mt: instance
fn: executable?
fs: executable?()
fd: See FileTest.executable?.
pt: Pathname
mt: instance
fn: executable_real?
fs: executable_real?()
fd: See FileTest.executable_real?.
pt: Pathname
mt: instance
fn: exist?
fs: exist?()
fd: See FileTest.exist?.
pt: Pathname
mt: instance
fn: expand_path
fs: expand_path(*args)
fd: See File.expand_path.
pt: Pathname
mt: instance
fn: extname
fs: extname()
fd: See File.extname. Returns the file's extension.
pt: Pathname
mt: instance
fn: file?
fs: file?()
fd: See FileTest.file?.
pt: Pathname
mt: instance
fn: find
fs: find()
fd: Pathname#find is an iterator to traverse a directory tree in a depth first manner. It yields a Pathname for each file under &quot;this&quot; directory.
pt: Pathname
mt: instance
fn: fnmatch?
fs: fnmatch?(pattern, *args)
fd: "See File.fnmatch? (same as #fnmatch)."
pt: Pathname
mt: instance
fn: fnmatch
fs: fnmatch(pattern, *args)
fd: See File.fnmatch. Return true if the receiver matches the given pattern.
pt: Pathname
mt: instance
fn: foreach
fs: foreach(*args, &block)
fd: "This method is <b>obsoleted</b> at 1.8.1. Use #each_line or #each_entry."
pt: Pathname
mt: instance
fn: foreachline
fs: foreachline(*args, &block)
fd: "Pathname#foreachline is <b>obsoleted</b> at 1.8.1. Use #each_line."
pt: Pathname
mt: instance
fn: freeze
fs: freeze()
fd: 
pt: Pathname
mt: instance
fn: ftype
fs: ftype()
fd: See File.ftype. Returns &quot;type&quot; of file (&quot;file&quot;, &quot;directory&quot;, etc).
pt: Pathname
mt: instance
fn: getwd
fs: getwd()
fd: See Dir.getwd. Returns the current working directory as a Pathname.
pt: Pathname
mt: class
fn: glob
fs: glob(*args)
fd: See Dir.glob. Returns or yields Pathname objects.
pt: Pathname
mt: class
fn: grpowned?
fs: grpowned?()
fd: See FileTest.grpowned?.
pt: Pathname
mt: instance
fn: join
fs: join(*args)
fd: Pathname#join joins pathnames.
pt: Pathname
mt: instance
fn: lchmod
fs: lchmod(mode)
fd: See File.lchmod.
pt: Pathname
mt: instance
fn: lchown
fs: lchown(owner, group)
fd: See File.lchown.
pt: Pathname
mt: instance
fn: link
fs: link(old)
fd: Pathname#link is confusing and <b>obsoleted</b> because the receiver/argument order is inverted to corresponding system call.
pt: Pathname
mt: instance
fn: lstat
fs: lstat()
fd: See File.lstat.
pt: Pathname
mt: instance
fn: make_link
fs: make_link(old)
fd: See File.link. Creates a hard link.
pt: Pathname
mt: instance
fn: make_symlink
fs: make_symlink(old)
fd: See File.symlink. Creates a symbolic link.
pt: Pathname
mt: instance
fn: mkdir
fs: mkdir(*args)
fd: See Dir.mkdir. Create the referenced directory.
pt: Pathname
mt: instance
fn: mkpath
fs: mkpath()
fd: See FileUtils.mkpath. Creates a full path, including any intermediate directories that don't yet exist.
pt: Pathname
mt: instance
fn: mountpoint?
fs: mountpoint?()
fd: "#mountpoint? returns true if self points to a mountpoint."
pt: Pathname
mt: instance
fn: mtime
fs: mtime()
fd: See File.mtime. Returns last modification time.
pt: Pathname
mt: instance
fn: new
fs: new(path)
fd: Create a Pathname object from the given String (or String-like object). If path contains a NUL character (\0), an ArgumentError is raised.
pt: Pathname
mt: class
fn: open
fs: open(*args)
fd: See File.open. Opens the file for reading or writing.
pt: Pathname
mt: instance
fn: opendir
fs: opendir()
fd: See Dir.open.
pt: Pathname
mt: instance
fn: owned?
fs: owned?()
fd: See FileTest.owned?.
pt: Pathname
mt: instance
fn: parent
fs: parent()
fd: "#parent returns the parent directory."
pt: Pathname
mt: instance
fn: pipe?
fs: pipe?()
fd: See FileTest.pipe?.
pt: Pathname
mt: instance
fn: read
fs: read(*args)
fd: See IO.read. Returns all the bytes from the file, or the first N if specified.
pt: Pathname
mt: instance
fn: readable?
fs: readable?()
fd: See FileTest.readable?.
pt: Pathname
mt: instance
fn: readable_real?
fs: readable_real?()
fd: See FileTest.readable_real?.
pt: Pathname
mt: instance
fn: readlines
fs: readlines(*args)
fd: See IO.readlines. Returns all the lines from the file.
pt: Pathname
mt: instance
fn: readlink
fs: readlink()
fd: See File.readlink. Read symbolic link.
pt: Pathname
mt: instance
fn: realpath
fs: realpath()
fd: Returns a real (absolute) pathname of self in the actual filesystem. The real pathname doesn't contain symlinks or useless dots.
pt: Pathname
mt: instance
fn: relative?
fs: relative?()
fd: "The opposite of #absolute?"
pt: Pathname
mt: instance
fn: relative_path_from
fs: relative_path_from(base_directory)
fd: "#relative_path_from returns a relative path from the argument to the receiver. If self is absolute, the argument must be absolute too. If self is relative, the argument must be relative too."
pt: Pathname
mt: instance
fn: rename
fs: rename(to)
fd: See File.rename. Rename the file.
pt: Pathname
mt: instance
fn: rmdir
fs: rmdir()
fd: See Dir.rmdir. Remove the referenced directory.
pt: Pathname
mt: instance
fn: rmtree
fs: rmtree()
fd: See FileUtils.rm_r. Deletes a directory and all beneath it.
pt: Pathname
mt: instance
fn: root?
fs: root?()
fd: "#root? is a predicate for root directories. I.e. it returns true if the pathname consists of consecutive slashes."
pt: Pathname
mt: instance
fn: setgid?
fs: setgid?()
fd: See FileTest.setgid?.
pt: Pathname
mt: instance
fn: setuid?
fs: setuid?()
fd: See FileTest.setuid?.
pt: Pathname
mt: instance
fn: size?
fs: size?()
fd: See FileTest.size?.
pt: Pathname
mt: instance
fn: size
fs: size()
fd: See FileTest.size.
pt: Pathname
mt: instance
fn: socket?
fs: socket?()
fd: See FileTest.socket?.
pt: Pathname
mt: instance
fn: split
fs: split()
fd: "See File.split. Returns the #dirname and the #basename in an Array."
pt: Pathname
mt: instance
fn: stat
fs: stat()
fd: See File.stat. Returns a File::Stat object.
pt: Pathname
mt: instance
fn: sticky?
fs: sticky?()
fd: See FileTest.sticky?.
pt: Pathname
mt: instance
fn: sub
fs: sub(pattern, *rest, &block)
fd: Return a pathname which is substituted by String#sub.
pt: Pathname
mt: instance
fn: symlink?
fs: symlink?()
fd: See FileTest.symlink?.
pt: Pathname
mt: instance
fn: symlink
fs: symlink(old)
fd: Pathname#symlink is confusing and <b>obsoleted</b> because the receiver/argument order is inverted to corresponding system call.
pt: Pathname
mt: instance
fn: sysopen
fs: sysopen(*args)
fd: See IO.sysopen.
pt: Pathname
mt: instance
fn: taint
fs: taint()
fd: 
pt: Pathname
mt: instance
fn: TO_PATH
fs: TO_PATH()
fd: "Alias for #to_s"
pt: Pathname
mt: instance
fn: to_s
fs: to_s()
fd: Return the path as a String.
pt: Pathname
mt: instance
fn: truncate
fs: truncate(length)
fd: See File.truncate. Truncate the file to length bytes.
pt: Pathname
mt: instance
fn: unlink
fs: unlink()
fd: Removes a file or directory, using File.unlink or Dir.unlink as necessary.
pt: Pathname
mt: instance
fn: untaint
fs: untaint()
fd: 
pt: Pathname
mt: instance
fn: utime
fs: utime(atime, mtime)
fd: See File.utime. Update the access and modification times.
pt: Pathname
mt: instance
fn: world_readable?
fs: world_readable?()
fd: See FileTest.world_readable?.
pt: Pathname
mt: instance
fn: world_writable?
fs: world_writable?()
fd: See FileTest.world_writable?.
pt: Pathname
mt: instance
fn: writable?
fs: writable?()
fd: See FileTest.writable?.
pt: Pathname
mt: instance
fn: writable_real?
fs: writable_real?()
fd: See FileTest.writable_real?.
pt: Pathname
mt: instance
fn: zero?
fs: zero?()
fd: See FileTest.zero?.
pt: Pathname
mt: instance
fn: pingecho
fs: pingecho(host, timeout=5, service="echo")
fd: Return true if we can open a connection to the hostname or IP address host on port service (which defaults to the &quot;echo&quot; port) waiting up to timeout seconds.
pt: Ping
mt: instance
fn: pretty_print
fs: pretty_print(q)
fd: "A default pretty printing method for general objects. It calls #pretty_print_instance_variables to list instance variables."
pt: PP::ObjectMixin
mt: instance
fn: pretty_print_cycle
fs: pretty_print_cycle(q)
fd: A default pretty printing method for general objects that are detected as part of a cycle.
pt: PP::ObjectMixin
mt: instance
fn: pretty_print_inspect
fs: pretty_print_inspect()
fd: "Is #inspect implementation using #pretty_print. If you implement #pretty_print, it can be used as follows."
pt: PP::ObjectMixin
mt: instance
fn: pretty_print_instance_variables
fs: pretty_print_instance_variables()
fd: Returns a sorted array of instance variable names.
pt: PP::ObjectMixin
mt: instance
fn: pp
fs: pp(obj, out=$>, width=79)
fd: Outputs obj to out in pretty printed format of width columns in width.
pt: PP
mt: class
fn: comma_breakable
fs: comma_breakable()
fd: "A convenience method which is same as follows:"
pt: PP::PPMethods
mt: instance
fn: guard_inspect_key
fs: guard_inspect_key()
fd: 
pt: PP::PPMethods
mt: instance
fn: object_address_group
fs: object_address_group(obj, &block)
fd: 
pt: PP::PPMethods
mt: instance
fn: object_group
fs: object_group(obj)
fd: "A convenience method which is same as follows:"
pt: PP::PPMethods
mt: instance
fn: pp
fs: pp(obj)
fd: Adds obj to the pretty printing buffer using Object#pretty_print or Object#pretty_print_cycle.
pt: PP::PPMethods
mt: instance
fn: pp_hash
fs: pp_hash(obj)
fd: 
pt: PP::PPMethods
mt: instance
fn: pp_object
fs: pp_object(obj)
fd: 
pt: PP::PPMethods
mt: instance
fn: seplist
fs: seplist(list, sep=nil, iter_method=:each)
fd: Adds a separated list. The list is separated by comma with breakable space, by default.
pt: PP::PPMethods
mt: instance
fn: singleline_pp
fs: singleline_pp(obj, out=$>)
fd: Outputs obj to out like PP.pp but with no indent and newline.
pt: PP
mt: class
fn: included
fs: included(p1)
fd: "call_seq:"
pt: Precision
mt: class
fn: prec
fs: prec(klass)
fd: Converts self into an instance of klass. By default, prec invokes
pt: Precision
mt: instance
fn: prec_f
fs: prec_f
fd: Returns a Float converted from num. It is equivalent to prec(Float).
pt: Precision
mt: instance
fn: prec_i
fs: prec_i
fd: Returns an Integer converted from num. It is equivalent to prec(Integer).
pt: Precision
mt: instance
fn: break_outmost_groups
fs: break_outmost_groups()
fd: 
pt: PrettyPrint
mt: instance
fn: new
fs: new(sep, width, q)
fd: 
pt: PrettyPrint::Breakable
mt: class
fn: output
fs: output(out, output_width)
fd: 
pt: PrettyPrint::Breakable
mt: instance
fn: breakable
fs: breakable(sep=' ', width=sep.length)
fd: This tells &quot;you can break a line here if necessary&quot;, and a width\-column text sep is inserted if a line is not broken at the point.
pt: PrettyPrint
mt: instance
fn: current_group
fs: current_group()
fd: 
pt: PrettyPrint
mt: instance
fn: fill_breakable
fs: fill_breakable(sep=' ', width=sep.length)
fd: 
pt: PrettyPrint
mt: instance
fn: first?
fs: first?()
fd: first? is a predicate to test the call is a first call to first? with current group.
pt: PrettyPrint
mt: instance
fn: flush
fs: flush()
fd: outputs buffered data.
pt: PrettyPrint
mt: instance
fn: format
fs: format(output='', maxwidth=79, newline="\n", genspace=lambda {|n| ' ' * n} {|q| ...}
fd: "This is a convenience method which is same as follows:"
pt: PrettyPrint
mt: class
fn: break?
fs: break?()
fd: 
pt: PrettyPrint::Group
mt: instance
fn: break
fs: break()
fd: 
pt: PrettyPrint::Group
mt: instance
fn: first?
fs: first?()
fd: 
pt: PrettyPrint::Group
mt: instance
fn: new
fs: new(depth)
fd: 
pt: PrettyPrint::Group
mt: class
fn: group
fs: group(indent=0, open_obj='', close_obj='', open_width=open_obj.length, close_width=close_obj.length)
fd: Groups line break hints added in the block. The line break hints are all to be used or not.
pt: PrettyPrint
mt: instance
fn: group_sub
fs: group_sub()
fd: 
pt: PrettyPrint
mt: instance
fn: delete
fs: delete(group)
fd: 
pt: PrettyPrint::GroupQueue
mt: instance
fn: deq
fs: deq()
fd: 
pt: PrettyPrint::GroupQueue
mt: instance
fn: enq
fs: enq(group)
fd: 
pt: PrettyPrint::GroupQueue
mt: instance
fn: new
fs: new(*groups)
fd: 
pt: PrettyPrint::GroupQueue
mt: class
fn: nest
fs: nest(indent)
fd: Increases left margin after newline with indent for line breaks added in the block.
pt: PrettyPrint
mt: instance
fn: new
fs: new(output='', maxwidth=79, newline="\n", &genspace)
fd: Creates a buffer for pretty printing.
pt: PrettyPrint
mt: class
fn: breakable
fs: breakable(sep=' ', width=nil)
fd: 
pt: PrettyPrint::SingleLine
mt: instance
fn: first?
fs: first?()
fd: 
pt: PrettyPrint::SingleLine
mt: instance
fn: flush
fs: flush()
fd: 
pt: PrettyPrint::SingleLine
mt: instance
fn: group
fs: group(indent=nil, open_obj='', close_obj='', open_width=nil, close_width=nil)
fd: 
pt: PrettyPrint::SingleLine
mt: instance
fn: nest
fs: nest(indent)
fd: 
pt: PrettyPrint::SingleLine
mt: instance
fn: new
fs: new(output, maxwidth=nil, newline=nil)
fd: 
pt: PrettyPrint::SingleLine
mt: class
fn: text
fs: text(obj, width=nil)
fd: 
pt: PrettyPrint::SingleLine
mt: instance
fn: singleline_format
fs: singleline_format(output='', maxwidth=nil, newline=nil, genspace=nil)
fd: This is similar to PrettyPrint::format but the result has no breaks.
pt: PrettyPrint
mt: class
fn: add
fs: add(obj, width)
fd: 
pt: PrettyPrint::Text
mt: instance
fn: new
fs: new()
fd: 
pt: PrettyPrint::Text
mt: class
fn: output
fs: output(out, output_width)
fd: 
pt: PrettyPrint::Text
mt: instance
fn: text
fs: text(obj, width=obj.length)
fd: This adds obj as a text of width columns in width.
pt: PrettyPrint
mt: instance
fn: each
fs: each()
fd: 
pt: Prime
mt: instance
fn: new
fs: new()
fd: 
pt: Prime
mt: class
fn: next
fs: next()
fd: "Alias for #succ"
pt: Prime
mt: instance
fn: succ
fs: succ()
fd: 
pt: Prime
mt: instance
fn: arity
fs: arity
fd: Returns the number of arguments that would not be ignored. If the block is declared to take no arguments, returns 0. If the block is known to take exactly n arguments, returns n. If the block has optional arguments, return -n-1, where n is the number of mandatory arguments. A proc with no argument declarations is the same a block declaring || as its arguments.
pt: Proc
mt: instance
fn: binding
fs: binding
fd: Returns the binding associated with prc. Note that Kernel#eval accepts either a Proc or a Binding object as its second parameter.
pt: Proc
mt: instance
fn: call
fs: call(params,...)
fd: Invokes the block, setting the block's parameters to the values in params using something close to method calling semantics. Generates a warning if multiple values are passed to a proc that expects just one (previously this silently converted the parameters to an array).
pt: Proc
mt: instance
fn: clone
fs: clone()
fd: "MISSING: documentation"
pt: Proc
mt: instance
fn: dup
fs: dup()
fd: "MISSING: documentation"
pt: Proc
mt: instance
fn: new
fs: new
fd: Creates a new Proc object, bound to the current context. Proc::new may be called without a block only within a method with an attached block, in which case that block is converted to the Proc object.
pt: Proc
mt: class
fn: to_proc
fs: to_proc
fd: Part of the protocol for converting objects to Proc objects. Instances of class Proc simply return themselves.
pt: Proc
mt: instance
fn: to_s
fs: to_s
fd: Shows the unique identifier for this proc, along with an indication of where the proc was defined.
pt: Proc
mt: instance
fn: abort
fs: abort
fd: Terminate execution immediately, effectively by calling Kernel.exit(1). If msg is given, it is written to STDERR prior to terminating.
pt: Process
mt: class
fn: detach
fs: detach(pid)
fd: Some operating systems retain the status of terminated child processes until the parent collects that status (normally using some variant of wait(). If the parent never collects this status, the child stays around as a zombie process. Process::detach prevents this by setting up a separate Ruby thread whose sole job is to reap the status of the process pid when it terminates. Use detach only when you do not intent to explicitly wait for the child to terminate. detach only checks the status periodically (currently once each second).
pt: Process
mt: class
fn: egid=
fs: egid=
fd: Sets the effective group ID for this process. Not available on all platforms.
pt: Process
mt: class
fn: egid
fs: egid
fd: Returns the effective group ID for this process. Not available on all platforms.
pt: Process
mt: class
fn: euid=
fs: euid=
fd: Sets the effective user ID for this process. Not available on all platforms.
pt: Process
mt: class
fn: euid
fs: euid
fd: Returns the effective user ID for this process.
pt: Process
mt: class
fn: exit!
fs: exit!(fixnum=-1)
fd: Exits the process immediately. No exit handlers are run. fixnum is returned to the underlying system as the exit status.
pt: Process
mt: class
fn: exit
fs: exit  exit(integer=0)
fd: Initiates the termination of the Ruby script by raising the SystemExit exception. This exception may be caught. The optional parameter is used to return a status code to the invoking environment.
pt: Process
mt: class
fn: fork
fs: fork
fd: Creates a subprocess. If a block is specified, that block is run in the subprocess, and the subprocess terminates with a status of zero. Otherwise, the fork call returns twice, once in the parent, returning the process ID of the child, and once in the child, returning nil. The child process can exit using Kernel.exit! to avoid running any at_exit functions. The parent process should use Process.wait to collect the termination statuses of its children or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes.
pt: Process
mt: class
fn: getpgid
fs: getpgid(pid)
fd: Returns the process group ID for the given process id. Not available on all platforms.
pt: Process
mt: class
fn: getpriority
fs: getpriority(kind, integer)
fd: "Gets the scheduling priority for specified process, process group, or user. kind indicates the kind of entity to find: one of Process::PRIO_PGRP, Process::PRIO_USER, or Process::PRIO_PROCESS. integer is an id indicating the particular process, process group, or user (an id of 0 means current). Lower priorities are more favorable for scheduling. Not available on all platforms."
pt: Process
mt: class
fn: getrlimit
fs: getrlimit(resource)
fd: Gets the resource limit of the process. cur_limit means current (soft) limit and max_limit means maximum (hard) limit.
pt: Process
mt: class
fn: change_privilege
fs: change_privilege(integer)
fd: Change the current process's real and effective group ID to that specified by integer. Returns the new group ID. Not available on all platforms.
pt: Process::GID
mt: class
fn: eid
fs: eid
fd: Returns the effective group ID for this process. Not available on all platforms.
pt: Process::GID
mt: class
fn: grant_privilege
fs: grant_privilege(integer)
fd: Set the effective group ID, and if possible, the saved group ID of the process to the given integer. Returns the new effective group ID. Not available on all platforms.
pt: Process::GID
mt: class
fn: re_exchange
fs: re_exchange
fd: Exchange real and effective group IDs and return the new effective group ID. Not available on all platforms.
pt: Process::GID
mt: class
fn: re_exchangeable?
fs: re_exchangeable?
fd: Returns true if the real and effective group IDs of a process may be exchanged on the current platform.
pt: Process::GID
mt: class
fn: rid
fs: rid
fd: Returns the (real) group ID for this process.
pt: Process::GID
mt: class
fn: sid_available?
fs: sid_available?
fd: Returns true if the current platform has saved group ID functionality.
pt: Process::GID
mt: class
fn: switch
fs: switch
fd: Switch the effective and real group IDs of the current process. If a block is given, the group IDs will be switched back after the block is executed. Returns the new effective group ID if called without a block, and the return value of the block if one is given.
pt: Process::GID
mt: class
fn: gid=
fs: gid=
fd: Sets the group ID for this process.
pt: Process
mt: class
fn: gid
fs: gid
fd: Returns the (real) group ID for this process.
pt: Process
mt: class
fn: groups=
fs: groups=
fd: Set the supplemental group access list to the given Array of group IDs.
pt: Process
mt: class
fn: groups
fs: groups
fd: Get an Array of the gids of groups in the supplemental group access list for this process.
pt: Process
mt: class
fn: initgroups
fs: initgroups(username, gid)
fd: Initializes the supplemental group access list by reading the system group database and using all groups of which the given user is a member. The group with the specified gid is also added to the list. Returns the resulting Array of the gids of all the groups in the supplementary group access list. Not available on all platforms.
pt: Process
mt: class
fn: kill
fs: kill(signal, pid, ...)
fd: Sends the given signal to the specified process id(s), or to the current process if pid is zero. signal may be an integer signal number or a POSIX signal name (either with or without a SIG prefix). If signal is negative (or starts with a minus sign), kills process groups instead of processes. Not all signals are available on all platforms.
pt: Process
mt: class
fn: maxgroups=
fs: maxgroups=
fd: Sets the maximum number of gids allowed in the supplemental group access list.
pt: Process
mt: class
fn: maxgroups
fs: maxgroups
fd: Returns the maximum number of gids allowed in the supplemental group access list.
pt: Process
mt: class
fn: pid
fs: pid
fd: Returns the process id of this process. Not available on all platforms.
pt: Process
mt: class
fn: ppid
fs: ppid
fd: Returns the process id of the parent of this process. Always returns 0 on NT. Not available on all platforms.
pt: Process
mt: class
fn: setpgid
fs: setpgid(pid, integer)
fd: Sets the process group ID of pid (0 indicates this process) to integer. Not available on all platforms.
pt: Process
mt: class
fn: setpgrp
fs: setpgrp
fd: Equivalent to setpgid(0,0). Not available on all platforms.
pt: Process
mt: class
fn: setpriority
fs: setpriority(kind, integer, priority)
fd: See Process#getpriority.
pt: Process
mt: class
fn: setrlimit
fs: setrlimit(resource, cur_limit, max_limit)
fd: Sets the resource limit of the process. cur_limit means current (soft) limit and max_limit means maximum (hard) limit.
pt: Process
mt: class
fn: setsid
fs: setsid
fd: Establishes this process as a new session and process group leader, with no controlling tty. Returns the session id. Not available on all platforms.
pt: Process
mt: class
fn: coredump?
fs: coredump?
fd: Returns true if stat generated a coredump when it terminated. Not available on all platforms.
pt: Process::Status
mt: instance
fn: exited?
fs: exited?
fd: Returns true if stat exited normally (for example using an exit() call or finishing the program).
pt: Process::Status
mt: instance
fn: exitstatus
fs: exitstatus
fd: Returns the least significant eight bits of the return code of stat. Only available if exited? is true.
pt: Process::Status
mt: instance
fn: inspect
fs: inspect
fd: Override the inspection method.
pt: Process::Status
mt: instance
fn: pid
fs: pid
fd: Returns the process ID that this status object represents.
pt: Process::Status
mt: instance
fn: signaled?
fs: signaled?
fd: Returns true if stat terminated because of an uncaught signal.
pt: Process::Status
mt: instance
fn: stopped?
fs: stopped?
fd: Returns true if this process is stopped. This is only returned if the corresponding wait call had the WUNTRACED flag set.
pt: Process::Status
mt: instance
fn: stopsig
fs: stopsig
fd: Returns the number of the signal that caused stat to stop (or nil if self is not stopped).
pt: Process::Status
mt: instance
fn: success?
fs: success?
fd: Returns true if stat is successful, false if not. Returns nil if exited? is not true.
pt: Process::Status
mt: instance
fn: termsig
fs: termsig
fd: Returns the number of the signal that caused stat to terminate (or nil if self was not terminated by an uncaught signal).
pt: Process::Status
mt: instance
fn: to_i
fs: to_i
fd: Returns the bits in stat as a Fixnum. Poking around in these bits is platform dependent.
pt: Process::Status
mt: instance
fn: to_int
fs: to_int
fd: Returns the bits in stat as a Fixnum. Poking around in these bits is platform dependent.
pt: Process::Status
mt: instance
fn: to_s
fs: to_s
fd: Equivalent to stat.to_i.to_s.
pt: Process::Status
mt: instance
fn: getegid
fs: getegid
fd: Returns the effective group ID for this process. Not available on all platforms.
pt: Process::Sys
mt: class
fn: geteuid
fs: geteuid
fd: Returns the effective user ID for this process.
pt: Process::Sys
mt: class
fn: getgid
fs: getgid
fd: Returns the (real) group ID for this process.
pt: Process::Sys
mt: class
fn: getuid
fs: getuid
fd: Returns the (real) user ID of this process.
pt: Process::Sys
mt: class
fn: issetugid
fs: issetugid
fd: Returns true if the process was created as a result of an execve(2) system call which had either of the setuid or setgid bits set (and extra privileges were given as a result) or if it has changed any of its real, effective or saved user or group IDs since it began execution.
pt: Process::Sys
mt: class
fn: setegid
fs: setegid(integer)
fd: Set the effective group ID of the calling process to integer. Not available on all platforms.
pt: Process::Sys
mt: class
fn: seteuid
fs: seteuid(integer)
fd: Set the effective user ID of the calling process to integer. Not available on all platforms.
pt: Process::Sys
mt: class
fn: setgid
fs: setgid(integer)
fd: Set the group ID of the current process to integer. Not available on all platforms.
pt: Process::Sys
mt: class
fn: setregid
fs: setregid(rid, eid)
fd: Sets the (integer) real and/or effective group IDs of the current process to rid and eid, respectively. A value of -1 for either means to leave that ID unchanged. Not available on all platforms.
pt: Process::Sys
mt: class
fn: setresgid
fs: setresgid(rid, eid, sid)
fd: Sets the (integer) real, effective, and saved user IDs of the current process to rid, eid, and sid respectively. A value of -1 for any value means to leave that ID unchanged. Not available on all platforms.
pt: Process::Sys
mt: class
fn: setresuid
fs: setresuid(rid, eid, sid)
fd: Sets the (integer) real, effective, and saved user IDs of the current process to rid, eid, and sid respectively. A value of -1 for any value means to leave that ID unchanged. Not available on all platforms.
pt: Process::Sys
mt: class
fn: setreuid
fs: setreuid(rid, eid)
fd: Sets the (integer) real and/or effective user IDs of the current process to rid and eid, respectively. A value of -1 for either means to leave that ID unchanged. Not available on all platforms.
pt: Process::Sys
mt: class
fn: setrgid
fs: setrgid(integer)
fd: Set the real group ID of the calling process to integer. Not available on all platforms.
pt: Process::Sys
mt: class
fn: setruid
fs: setruid(integer)
fd: Set the real user ID of the calling process to integer. Not available on all platforms.
pt: Process::Sys
mt: class
fn: setuid
fs: setuid(integer)
fd: Set the user ID of the current process to integer. Not available on all platforms.
pt: Process::Sys
mt: class
fn: times
fs: times
fd: Returns a Tms structure (see Struct::Tms on page 388) that contains user and system CPU times for this process.
pt: Process
mt: class
fn: change_privilege
fs: change_privilege(integer)
fd: Change the current process's real and effective user ID to that specified by integer. Returns the new user ID. Not available on all platforms.
pt: Process::UID
mt: class
fn: eid
fs: eid
fd: Returns the effective user ID for this process.
pt: Process::UID
mt: class
fn: grant_privilege
fs: grant_privilege(integer)
fd: Set the effective user ID, and if possible, the saved user ID of the process to the given integer. Returns the new effective user ID. Not available on all platforms.
pt: Process::UID
mt: class
fn: re_exchange
fs: re_exchange
fd: Exchange real and effective user IDs and return the new effective user ID. Not available on all platforms.
pt: Process::UID
mt: class
fn: re_exchangeable?
fs: re_exchangeable?
fd: Returns true if the real and effective user IDs of a process may be exchanged on the current platform.
pt: Process::UID
mt: class
fn: rid
fs: rid
fd: Returns the (real) user ID of this process.
pt: Process::UID
mt: class
fn: sid_available?
fs: sid_available?
fd: Returns true if the current platform has saved user ID functionality.
pt: Process::UID
mt: class
fn: switch
fs: switch
fd: Switch the effective and real user IDs of the current process. If a block is given, the user IDs will be switched back after the block is executed. Returns the new effective user ID if called without a block, and the return value of the block if one is given.
pt: Process::UID
mt: class
fn: uid=
fs: uid=
fd: Sets the (integer) user ID for this process. Not available on all platforms.
pt: Process
mt: class
fn: uid
fs: uid
fd: Returns the (real) user ID of this process.
pt: Process
mt: class
fn: wait
fs: wait()
fd: "Waits for a child process to exit, returns its process id, and sets $? to a Process::Status object containing information on that process. Which child it waits on depends on the value of pid:"
pt: Process
mt: class
fn: wait2
fs: wait2(pid=-1, flags=0)
fd: Waits for a child process to exit (see Process::waitpid for exact semantics) and returns an array containing the process id and the exit status (a Process::Status object) of that child. Raises a SystemError if there are no child processes.
pt: Process
mt: class
fn: waitall
fs: waitall
fd: Waits for all children, returning an array of pid/status pairs (where status is a Process::Status object).
pt: Process
mt: class
fn: waitpid
fs: waitpid(pid=-1, flags=0)
fd: "Waits for a child process to exit, returns its process id, and sets $? to a Process::Status object containing information on that process. Which child it waits on depends on the value of pid:"
pt: Process
mt: class
fn: waitpid2
fs: waitpid2(pid=-1, flags=0)
fd: Waits for a child process to exit (see Process::waitpid for exact semantics) and returns an array containing the process id and the exit status (a Process::Status object) of that child. Raises a SystemError if there are no child processes.
pt: Process
mt: class
fn: abort
fs: abort()
fd: Ends the current PStore#transaction, discarding any changes to the data store.
pt: PStore
mt: instance
fn: commit
fs: commit()
fd: Ends the current PStore#transaction, committing any changes to the data store immediately.
pt: PStore
mt: instance
fn: delete
fs: delete(name)
fd: Removes an object hierarchy from the data store, by name.
pt: PStore
mt: instance
fn: fetch
fs: fetch(name, default=PStore::Error)
fd: This method is just like PStore#[], save that you may also provide a default value for the object. In the event the specified name is not found in the data store, your default will be returned instead. If you do not specify a default, PStore::Error will be raised if the object is not found.
pt: PStore
mt: instance
fn: new
fs: new(file)
fd: To construct a PStore object, pass in the file path where you would like the data to be stored.
pt: PStore
mt: class
fn: path
fs: path()
fd: Returns the path to the data store file.
pt: PStore
mt: instance
fn: root?
fs: root?(name)
fd: Returns true if the supplied name is currently in the data store.
pt: PStore
mt: instance
fn: roots
fs: roots()
fd: Returns the names of all object hierarchies currently in the store.
pt: PStore
mt: instance
fn: transaction
fs: transaction(read_only=false)
fd: Opens a new transaction for the data store. Code executed inside a block passed to this method may read and write data to and from the data store file.
pt: PStore
mt: instance
fn: clear
fs: clear()
fd: Removes all objects from the queue.
pt: Queue
mt: instance
fn: deq
fs: deq(non_block=false)
fd: "Alias for #pop"
pt: Queue
mt: instance
fn: empty?
fs: empty?()
fd: Returns true is the queue is empty.
pt: Queue
mt: instance
fn: enq
fs: enq(obj)
fd: "Alias for #push"
pt: Queue
mt: instance
fn: length
fs: length()
fd: Returns the length of the queue.
pt: Queue
mt: instance
fn: new
fs: new()
fd: Creates a new queue.
pt: Queue
mt: class
fn: num_waiting
fs: num_waiting()
fd: Returns the number of threads waiting on the queue.
pt: Queue
mt: instance
fn: pop
fs: pop(non_block=false)
fd: Retrieves data from the queue. If the queue is empty, the calling thread is suspended until data is pushed onto the queue. If non_block is true, the thread isn't suspended, and an exception is raised.
pt: Queue
mt: instance
fn: push
fs: push(obj)
fd: Pushes obj to the queue.
pt: Queue
mt: instance
fn: shift
fs: shift(non_block=false)
fd: "Alias for #pop"
pt: Queue
mt: instance
fn: size
fs: size()
fd: "Alias for #length"
pt: Queue
mt: instance
fn: racc_runtime_type
fs: racc_runtime_type()
fd: 
pt: Racc::Parser
mt: class
fn: begin
fs: begin
fd: Returns the first object in rng.
pt: Range
mt: instance
fn: each
fs: each
fd: Iterates over the elements rng, passing each in turn to the block. You can only iterate if the start object of the range supports the succ method (which means that you can't iterate over ranges of Float objects).
pt: Range
mt: instance
fn: end
fs: end
fd: Returns the object that defines the end of rng.
pt: Range
mt: instance
fn: eql?
fs: eql?(obj)
fd: "Returns true only if obj is a Range, has equivalent beginning and end items (by comparing them with #eql?), and has the same #exclude_end? setting as rng."
pt: Range
mt: instance
fn: exclude_end?
fs: exclude_end?
fd: Returns true if rng excludes its end value.
pt: Range
mt: instance
fn: first
fs: first
fd: Returns the first object in rng.
pt: Range
mt: instance
fn: hash
fs: hash
fd: Generate a hash value such that two ranges with the same start and end points, and the same value for the &quot;exclude end&quot; flag, generate the same hash value.
pt: Range
mt: instance
fn: include?
fs: include?(val)
fd: Returns true if obj is an element of rng, false otherwise. Conveniently, === is the comparison operator used by case statements.
pt: Range
mt: instance
fn: inspect
fs: inspect
fd: Convert this range object to a printable form (using inspect to convert the start and end objects).
pt: Range
mt: instance
fn: last
fs: last
fd: Returns the object that defines the end of rng.
pt: Range
mt: instance
fn: member?
fs: member?(val)
fd: Returns true if obj is an element of rng, false otherwise. Conveniently, === is the comparison operator used by case statements.
pt: Range
mt: instance
fn: new
fs: new(start, end, exclusive=false)
fd: Constructs a range using the given start and end. If the third parameter is omitted or is false, the range will include the end object; otherwise, it will be excluded.
pt: Range
mt: class
fn: pretty_print
fs: pretty_print(q)
fd: 
pt: Range
mt: instance
fn: step
fs: step(n=1)
fd: Iterates over rng, passing each nth element to the block. If the range contains numbers or strings, natural ordering is used. Otherwise step invokes succ to iterate through range elements. The following code uses class Xs, which is defined in the class-level documentation.
pt: Range
mt: instance
fn: to_s
fs: to_s
fd: Convert this range object to a printable form.
pt: Range
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Range
mt: instance
fn: yaml_new
fs: yaml_new( klass, tag, val )
fd: 
pt: Range
mt: class
fn: abs
fs: abs()
fd: Returns the absolute value.
pt: Rational
mt: instance
fn: coerce
fs: coerce(other)
fd: 
pt: Rational
mt: instance
fn: divmod
fs: divmod(other)
fd: Returns the quotient and remainder.
pt: Rational
mt: instance
fn: hash
fs: hash()
fd: Returns a hash code for the object.
pt: Rational
mt: instance
fn: inspect
fs: inspect()
fd: "Returns a reconstructable string representation:"
pt: Rational
mt: instance
fn: new!
fs: new!(num, den = 1)
fd: "Implements the constructor. This method does not reduce to lowest terms or check for division by zero. Therefore #Rational() should be preferred in normal use."
pt: Rational
mt: class
fn: new
fs: new(num, den)
fd: This method is actually private.
pt: Rational
mt: class
fn: power2
fs: power2(other)
fd: 
pt: Rational
mt: instance
fn: reduce
fs: reduce(num, den = 1)
fd: Reduces the given numerator and denominator to their lowest terms. Use Rational() instead.
pt: Rational
mt: class
fn: to_f
fs: to_f()
fd: Converts the rational to a Float.
pt: Rational
mt: instance
fn: to_i
fs: to_i()
fd: "Converts the rational to an Integer. Not the nearest integer, the truncated integer. Study the following example carefully:"
pt: Rational
mt: instance
fn: to_r
fs: to_r()
fd: Returns self.
pt: Rational
mt: instance
fn: to_s
fs: to_s()
fd: Returns a string representation of the rational number.
pt: Rational
mt: instance
fn: new
fs: new(text, old_name, new_name, comment)
fd: 
pt: RDoc::Alias
mt: class
fn: to_s
fs: to_s()
fd: 
pt: RDoc::Alias
mt: instance
fn: add_alias
fs: add_alias(method)
fd: 
pt: RDoc::AnyMethod
mt: instance
fn: new
fs: new(text, name)
fd: 
pt: RDoc::AnyMethod
mt: class
fn: param_seq
fs: param_seq()
fd: 
pt: RDoc::AnyMethod
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: RDoc::AnyMethod
mt: instance
fn: new
fs: new(text, name, rw, comment)
fd: 
pt: RDoc::Attr
mt: class
fn: to_s
fs: to_s()
fd: 
pt: RDoc::Attr
mt: instance
fn: new
fs: new(top_level, file_name, body, options, stats)
fd: prepare to parse a C file
pt: RDoc::C_Parser
mt: class
fn: scan
fs: scan()
fd: Extract the classes/modules and methods from a C file and return the corresponding top-level object
pt: RDoc::C_Parser
mt: instance
fn: find_class_named
fs: find_class_named(name)
fd: 
pt: RDoc::ClassModule
mt: instance
fn: full_name
fs: full_name()
fd: Return the fully qualified name of this class or module
pt: RDoc::ClassModule
mt: instance
fn: http_url
fs: http_url(prefix)
fd: 
pt: RDoc::ClassModule
mt: instance
fn: is_module?
fs: is_module?()
fd: Return true if this object represents a module
pt: RDoc::ClassModule
mt: instance
fn: new
fs: new(name, superclass = nil)
fd: 
pt: RDoc::ClassModule
mt: class
fn: to_s
fs: to_s()
fd: to_s is simply for debugging
pt: RDoc::ClassModule
mt: instance
fn: attr_overridable
fs: attr_overridable(name, *aliases)
fd: There's a wee trick we pull. Comment blocks can have directives that override the stuff we extract during the parse. So, we have a special class method, attr_overridable, that lets code objects list those directives. Wehn a comment is assigned, we then extract out any matching directives and update our object
pt: RDoc::CodeObject
mt: class
fn: comment=
fs: comment=(comment)
fd: Update the comment, but don't overwrite a real comment with an empty one
pt: RDoc::CodeObject
mt: instance
fn: document_children=
fs: document_children=(val)
fd: 
pt: RDoc::CodeObject
mt: instance
fn: document_self=
fs: document_self=(val)
fd: 
pt: RDoc::CodeObject
mt: instance
fn: new
fs: new()
fd: 
pt: RDoc::CodeObject
mt: class
fn: remove_classes_and_modules
fs: remove_classes_and_modules()
fd: Default callbacks to nothing, but this is overridden for classes and modules
pt: RDoc::CodeObject
mt: instance
fn: remove_methods_etc
fs: remove_methods_etc()
fd: 
pt: RDoc::CodeObject
mt: instance
fn: start_doc
fs: start_doc()
fd: "set and cleared by :startdoc: and :enddoc:, this is used to toggle the capturing of documentation"
pt: RDoc::CodeObject
mt: instance
fn: stop_doc
fs: stop_doc()
fd: 
pt: RDoc::CodeObject
mt: instance
fn: new
fs: new(name, value, comment)
fd: 
pt: RDoc::Constant
mt: class
fn: add_alias
fs: add_alias(an_alias)
fd: 
pt: RDoc::Context
mt: instance
fn: add_attribute
fs: add_attribute(an_attribute)
fd: 
pt: RDoc::Context
mt: instance
fn: add_class
fs: add_class(class_type, name, superclass)
fd: 
pt: RDoc::Context
mt: instance
fn: add_class_or_module
fs: add_class_or_module(collection, class_type, name, superclass=nil)
fd: 
pt: RDoc::Context
mt: instance
fn: add_constant
fs: add_constant(const)
fd: 
pt: RDoc::Context
mt: instance
fn: add_include
fs: add_include(an_include)
fd: 
pt: RDoc::Context
mt: instance
fn: add_method
fs: add_method(a_method)
fd: 
pt: RDoc::Context
mt: instance
fn: add_module
fs: add_module(class_type, name)
fd: 
pt: RDoc::Context
mt: instance
fn: add_require
fs: add_require(a_require)
fd: Requires always get added to the top-level (file) context
pt: RDoc::Context
mt: instance
fn: add_to
fs: add_to(array, thing)
fd: 
pt: RDoc::Context
mt: instance
fn: classes
fs: classes()
fd: map the class hash to an array externally
pt: RDoc::Context
mt: instance
fn: defined_in?
fs: defined_in?(file)
fd: Return true if at least part of this thing was defined in file
pt: RDoc::Context
mt: instance
fn: each_attribute
fs: each_attribute()
fd: 
pt: RDoc::Context
mt: instance
fn: each_classmodule
fs: each_classmodule()
fd: Iterate over all the classes and modules in this object
pt: RDoc::Context
mt: instance
fn: each_constant
fs: each_constant()
fd: 
pt: RDoc::Context
mt: instance
fn: each_method
fs: each_method()
fd: 
pt: RDoc::Context
mt: instance
fn: find_enclosing_module_named
fs: find_enclosing_module_named(name)
fd: find a module at a higher scope
pt: RDoc::Context
mt: instance
fn: find_local_symbol
fs: find_local_symbol(symbol)
fd: 
pt: RDoc::Context
mt: instance
fn: find_module_named
fs: find_module_named(name)
fd: Find a named module
pt: RDoc::Context
mt: instance
fn: find_symbol
fs: find_symbol(symbol, method=nil)
fd: Look up the given symbol. If method is non-nil, then we assume the symbol references a module that contains that method
pt: RDoc::Context
mt: instance
fn: initialize_classes_and_modules
fs: initialize_classes_and_modules()
fd: 
pt: RDoc::Context
mt: instance
fn: initialize_methods_etc
fs: initialize_methods_etc()
fd: 
pt: RDoc::Context
mt: instance
fn: modules
fs: modules()
fd: map the module hash to an array externally
pt: RDoc::Context
mt: instance
fn: new
fs: new()
fd: 
pt: RDoc::Context
mt: class
fn: ongoing_visibility=
fs: ongoing_visibility=(vis)
fd: Change the default visibility for new methods
pt: RDoc::Context
mt: instance
fn: record_location
fs: record_location(toplevel)
fd: Record the file that we happen to find it in
pt: RDoc::Context
mt: instance
fn: remove_classes_and_modules
fs: remove_classes_and_modules()
fd: "and remove classes and modules when we see a :nodoc: all"
pt: RDoc::Context
mt: instance
fn: remove_methods_etc
fs: remove_methods_etc()
fd: If a class's documentation is turned off after we've started collecting methods etc., we need to remove the ones we have
pt: RDoc::Context
mt: instance
fn: new
fs: new(title, comment)
fd: 
pt: RDoc::Context::Section
mt: class
fn: set_current_section
fs: set_current_section(title, comment)
fd: Handle sections
pt: RDoc::Context
mt: instance
fn: set_visibility_for
fs: set_visibility_for(methods, vis, singleton=false)
fd: Given an array methods of method names, set the visibility of the corresponding AnyMethod object
pt: RDoc::Context
mt: instance
fn: toplevel
fs: toplevel()
fd: Return the toplevel that owns us
pt: RDoc::Context
mt: instance
fn: draw
fs: draw()
fd: Draw the diagrams. We traverse the files, drawing a diagram for each. We also traverse each top-level class and module in that file drawing a diagram for these too.
pt: RDoc::Diagram
mt: instance
fn: new
fs: new(info, options)
fd: Pass in the set of top level objects. The method also creates the subdirectory to hold the images
pt: RDoc::Diagram
mt: class
fn: include_attr?
fs: include_attr?(attr)
fd: If attr is included, true is returned
pt: RDoc::Fortran95parser::Fortran95Definition
mt: instance
fn: new
fs: new(varname, types, inivalue, arraysuffix, comment, nodoc=false)
fd: 
pt: RDoc::Fortran95parser::Fortran95Definition
mt: class
fn: to_s
fs: to_s()
fd: 
pt: RDoc::Fortran95parser::Fortran95Definition
mt: instance
fn: new
fs: new(top_level, file_name, body, options, stats)
fd: prepare to parse a Fortran 95 file
pt: RDoc::Fortran95parser
mt: class
fn: scan
fs: scan()
fd: devine code constructs
pt: RDoc::Fortran95parser
mt: instance
fn: new
fs: new(name, comment)
fd: 
pt: RDoc::Include
mt: class
fn: is_module?
fs: is_module?()
fd: 
pt: RDoc::NormalModule
mt: instance
fn: write_extra_pages
fs: write_extra_pages()
fd: 
pt: RDoc::Page
mt: instance
fn: alias_extension
fs: alias_extension(old_ext, new_ext)
fd: Alias an extension to another extension. After this call, files ending &quot;new_ext&quot; will be parsed using the same parser as &quot;old_ext&quot;
pt: RDoc::ParserFactory
mt: class
fn: can_parse
fs: can_parse(file_name)
fd: Return a parser that can handle a particular extension
pt: RDoc::ParserFactory
mt: class
fn: parse_files_matching
fs: parse_files_matching(regexp)
fd: Record the fact that a particular class parses files that match a given extension
pt: RDoc::ParserFactory
mt: instance
fn: parser_for
fs: parser_for(top_level, file_name, body, options, stats)
fd: Find the correct parser for a particular file name. Return a SimpleParser for ones that we don't know
pt: RDoc::ParserFactory
mt: class
fn: document
fs: document(argv)
fd: Format up one or more files according to the given arguments. For simplicity, argv is an array of strings, equivalent to the strings that would be passed on the command line. (This isn't a coincidence, as we do pass in ARGV when running interactively). For a list of options, see rdoc/rdoc.rb. By default, output will be stored in a directory called doc below the current directory, so make sure you're somewhere writable before invoking.
pt: RDoc::RDoc
mt: instance
fn: new
fs: new(name, comment)
fd: 
pt: RDoc::Require
mt: class
fn: new
fs: new(top_level, file_name, content, options, stats)
fd: 
pt: RDoc::RubyParser
mt: class
fn: scan
fs: scan()
fd: 
pt: RDoc::RubyParser
mt: instance
fn: new
fs: new(top_level, file_name, body, options, stats)
fd: prepare to parse a plain file
pt: RDoc::SimpleParser
mt: class
fn: remove_private_comments
fs: remove_private_comments(comment)
fd: 
pt: RDoc::SimpleParser
mt: instance
fn: scan
fs: scan()
fd: Extract the file contents and attach them to the toplevel as a comment
pt: RDoc::SimpleParser
mt: instance
fn: new
fs: new()
fd: 
pt: RDoc::Stats
mt: class
fn: print
fs: print()
fd: 
pt: RDoc::Stats
mt: instance
fn: new
fs: new(line_no, char_no)
fd: 
pt: RDoc::Token
mt: class
fn: set_text
fs: set_text(text)
fd: Because we're used in contexts that expect to return a token, we set the text string and then return ourselves
pt: RDoc::Token
mt: instance
fn: add_class_or_module
fs: add_class_or_module(collection, class_type, name, superclass)
fd: Adding a class or module to a TopLevel is special, as we only want one copy of a particular top-level class. For example, if both file A and file B implement class C, we only want one ClassModule object for C. This code arranges to share classes and modules between files.
pt: RDoc::TopLevel
mt: instance
fn: all_classes_and_modules
fs: all_classes_and_modules()
fd: 
pt: RDoc::TopLevel
mt: class
fn: find_class_named
fs: find_class_named(name)
fd: 
pt: RDoc::TopLevel
mt: class
fn: find_class_or_module_named
fs: find_class_or_module_named(symbol)
fd: 
pt: RDoc::TopLevel
mt: instance
fn: find_local_symbol
fs: find_local_symbol(symbol)
fd: 
pt: RDoc::TopLevel
mt: instance
fn: find_module_named
fs: find_module_named(name)
fd: Find a named module
pt: RDoc::TopLevel
mt: instance
fn: full_name
fs: full_name()
fd: 
pt: RDoc::TopLevel
mt: instance
fn: new
fs: new(file_name)
fd: 
pt: RDoc::TopLevel
mt: class
fn: reset
fs: reset()
fd: 
pt: RDoc::TopLevel
mt: class
fn: usage
fs: usage(*args)
fd: Display usage information from the comment at the top of the file. String arguments identify specific sections of the comment to display. An optional integer first argument specifies the exit status (defaults to 0)
pt: RDoc
mt: class
fn: usage_no_exit
fs: usage_no_exit(*args)
fd: Display usage
pt: RDoc
mt: class
fn: new
fs: new(re1, re2)
fd: 
pt: RegAnd
mt: class
fn: casefold?
fs: casefold?
fd: Returns the value of the case-insensitive flag.
pt: Regexp
mt: instance
fn: compile
fs: compile(...)
fd: Synonym for Regexp.new
pt: Regexp
mt: class
fn: eql?
fs: eql?(other_rxp)
fd: Equality---Two regexps are equal if their patterns are identical, they have the same character set code, and their casefold? values are the same.
pt: Regexp
mt: instance
fn: escape
fs: escape(str)
fd: Escapes any characters that would have special meaning in a regular expression. Returns a new escaped string, or self if no characters are escaped. For any string, Regexp.escape(str)=~str will be true.
pt: Regexp
mt: class
fn: hash
fs: hash
fd: Produce a hash based on the text and options of this regular expression.
pt: Regexp
mt: instance
fn: inspect
fs: inspect
fd: Produce a nicely formatted string-version of rxp. Perhaps surprisingly, #inspect actually produces the more natural version of the string than #to_s.
pt: Regexp
mt: instance
fn: kcode
fs: kcode
fd: Returns the character set code for the regexp.
pt: Regexp
mt: instance
fn: last_match
fs: last_match(fixnum)
fd: The first form returns the MatchData object generated by the last successful pattern match. Equivalent to reading the global variable $~. The second form returns the nth field in this MatchData object.
pt: Regexp
mt: class
fn: match
fs: match(str)
fd: Returns a MatchData object describing the match, or nil if there was no match. This is equivalent to retrieving the value of the special variable $~ following a normal match.
pt: Regexp
mt: instance
fn: new
fs: new(string [, options [, lang]])
fd: "Constructs a new regular expression from pattern, which can be either a String or a Regexp (in which case that regexp's options are propagated, and new options may not be specified (a change as of Ruby 1.8). If options is a Fixnum, it should be one or more of the constants Regexp::EXTENDED, Regexp::IGNORECASE, and Regexp::MULTILINE, or-ed together. Otherwise, if options is not nil, the regexp will be case insensitive. The lang parameter enables multibyte support for the regexp: `n', `N' = none, `e', `E' = EUC, `s', `S' = SJIS, `u', `U' = UTF-8."
pt: Regexp
mt: class
fn: options
fs: options
fd: "Returns the set of bits corresponding to the options used when creating this Regexp (see Regexp::new for details. Note that additional bits may be set in the returned options: these are used internally by the regular expression code. These extra bits are ignored if the options are passed to Regexp::new."
pt: Regexp
mt: instance
fn: quote
fs: quote(str)
fd: Escapes any characters that would have special meaning in a regular expression. Returns a new escaped string, or self if no characters are escaped. For any string, Regexp.escape(str)=~str will be true.
pt: Regexp
mt: class
fn: source
fs: source
fd: Returns the original string of the pattern.
pt: Regexp
mt: instance
fn: to_s
fs: to_s
fd: Returns a string containing the regular expression and its options (using the (?xxx:yyy) notation. This string can be fed back in to Regexp::new to a regular expression with the same semantics as the original. (However, Regexp#== may not return true when comparing the two, as the source of the regular expression itself may differ, as the example shows). Regexp#inspect produces a generally more readable version of rxp.
pt: Regexp
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Regexp
mt: instance
fn: union
fs: union([pattern]*)
fd: Return a Regexp object that is the union of the given patterns, i.e., will match any of its parts. The patterns can be Regexp objects, in which case their options will be preserved, or Strings. If no arguments are given, returns /(?!)/.
pt: Regexp
mt: class
fn: yaml_new
fs: yaml_new( klass, tag, val )
fd: 
pt: Regexp
mt: class
fn: new
fs: new(re1, re2)
fd: 
pt: RegOr
mt: class
fn: close
fs: close()
fd: 
pt: Resolv::DNS
mt: instance
fn: default_config_hash
fs: default_config_hash(filename="/etc/resolv.conf")
fd: 
pt: Resolv::DNS::Config
mt: class
fn: generate_candidates
fs: generate_candidates(name)
fd: 
pt: Resolv::DNS::Config
mt: instance
fn: generate_timeouts
fs: generate_timeouts()
fd: 
pt: Resolv::DNS::Config
mt: instance
fn: lazy_initialize
fs: lazy_initialize()
fd: 
pt: Resolv::DNS::Config
mt: instance
fn: new
fs: new(config_info=nil)
fd: 
pt: Resolv::DNS::Config
mt: class
fn: parse_resolv_conf
fs: parse_resolv_conf(filename)
fd: 
pt: Resolv::DNS::Config
mt: class
fn: resolv
fs: resolv(name)
fd: 
pt: Resolv::DNS::Config
mt: instance
fn: single?
fs: single?()
fd: 
pt: Resolv::DNS::Config
mt: instance
fn: each_address
fs: each_address(name)
fd: 
pt: Resolv::DNS
mt: instance
fn: each_name
fs: each_name(address)
fd: 
pt: Resolv::DNS
mt: instance
fn: each_resource
fs: each_resource(name, typeclass, &proc)
fd: 
pt: Resolv::DNS
mt: instance
fn: extract_resources
fs: extract_resources(msg, name, typeclass)
fd: 
pt: Resolv::DNS
mt: instance
fn: getaddress
fs: getaddress(name)
fd: 
pt: Resolv::DNS
mt: instance
fn: getaddresses
fs: getaddresses(name)
fd: 
pt: Resolv::DNS
mt: instance
fn: getname
fs: getname(address)
fd: 
pt: Resolv::DNS
mt: instance
fn: getnames
fs: getnames(address)
fd: 
pt: Resolv::DNS
mt: instance
fn: getresource
fs: getresource(name, typeclass)
fd: 
pt: Resolv::DNS
mt: instance
fn: getresources
fs: getresources(name, typeclass)
fd: 
pt: Resolv::DNS
mt: instance
fn: split
fs: split(arg)
fd: 
pt: Resolv::DNS::Label
mt: class
fn: eql?
fs: eql?(other)
fd: 
pt: Resolv::DNS::Label::Str
mt: instance
fn: hash
fs: hash()
fd: 
pt: Resolv::DNS::Label::Str
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: Resolv::DNS::Label::Str
mt: instance
fn: new
fs: new(string)
fd: 
pt: Resolv::DNS::Label::Str
mt: class
fn: to_s
fs: to_s()
fd: 
pt: Resolv::DNS::Label::Str
mt: instance
fn: lazy_initialize
fs: lazy_initialize()
fd: 
pt: Resolv::DNS
mt: instance
fn: add_additional
fs: add_additional(name, ttl, data)
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: add_answer
fs: add_answer(name, ttl, data)
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: add_authority
fs: add_authority(name, ttl, data)
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: add_question
fs: add_question(name, typeclass)
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: decode
fs: decode(m)
fd: 
pt: Resolv::DNS::Message
mt: class
fn: each_additional
fs: each_additional()
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: each_answer
fs: each_answer()
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: each_authority
fs: each_authority()
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: each_question
fs: each_question()
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: each_resource
fs: each_resource()
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: encode
fs: encode()
fd: 
pt: Resolv::DNS::Message
mt: instance
fn: get_bytes
fs: get_bytes(len = @limit - @index)
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_label
fs: get_label()
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_labels
fs: get_labels(limit=nil)
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_length16
fs: get_length16()
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_name
fs: get_name()
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_question
fs: get_question()
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_rr
fs: get_rr()
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_string
fs: get_string()
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_string_list
fs: get_string_list()
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: get_unpack
fs: get_unpack(template)
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: instance
fn: new
fs: new(data)
fd: 
pt: Resolv::DNS::Message::MessageDecoder
mt: class
fn: new
fs: new()
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: class
fn: put_bytes
fs: put_bytes(d)
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: put_label
fs: put_label(d)
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: put_labels
fs: put_labels(d)
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: put_length16
fs: put_length16()
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: put_name
fs: put_name(d)
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: put_pack
fs: put_pack(template, *d)
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: put_string
fs: put_string(d)
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: put_string_list
fs: put_string_list(ds)
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: Resolv::DNS::Message::MessageEncoder
mt: instance
fn: new
fs: new(id = (@@identifier += 1)
fd: 
pt: Resolv::DNS::Message
mt: class
fn: absolute?
fs: absolute?()
fd: 
pt: Resolv::DNS::Name
mt: instance
fn: create
fs: create(arg)
fd: 
pt: Resolv::DNS::Name
mt: class
fn: eql?
fs: eql?(other)
fd: "Alias for #=="
pt: Resolv::DNS::Name
mt: instance
fn: hash
fs: hash()
fd: 
pt: Resolv::DNS::Name
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: Resolv::DNS::Name
mt: instance
fn: length
fs: length()
fd: 
pt: Resolv::DNS::Name
mt: instance
fn: new
fs: new(labels, absolute=true)
fd: 
pt: Resolv::DNS::Name
mt: class
fn: subdomain_of?
fs: subdomain_of?(other)
fd: tests subdomain-of relation.
pt: Resolv::DNS::Name
mt: instance
fn: to_a
fs: to_a()
fd: 
pt: Resolv::DNS::Name
mt: instance
fn: to_s
fs: to_s()
fd: returns the domain name as a string.
pt: Resolv::DNS::Name
mt: instance
fn: new
fs: new(config_info=nil)
fd: 
pt: Resolv::DNS
mt: class
fn: open
fs: open(*args)
fd: 
pt: Resolv::DNS
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Query
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Query
mt: instance
fn: close
fs: close()
fd: 
pt: Resolv::DNS::Requester
mt: instance
fn: new
fs: new(host, port=Port)
fd: 
pt: Resolv::DNS::Requester::ConnectedUDP
mt: class
fn: send
fs: send()
fd: 
pt: Resolv::DNS::Requester::ConnectedUDP::Sender
mt: instance
fn: sender
fs: sender(msg, data, queue, host=@host, port=@port)
fd: 
pt: Resolv::DNS::Requester::ConnectedUDP
mt: instance
fn: delete
fs: delete(arg)
fd: 
pt: Resolv::DNS::Requester
mt: instance
fn: new
fs: new()
fd: 
pt: Resolv::DNS::Requester
mt: class
fn: new
fs: new(msg, data, sock, queue)
fd: 
pt: Resolv::DNS::Requester::Sender
mt: class
fn: recv
fs: recv(msg)
fd: 
pt: Resolv::DNS::Requester::Sender
mt: instance
fn: new
fs: new(host, port=Port)
fd: 
pt: Resolv::DNS::Requester::TCP
mt: class
fn: send
fs: send()
fd: 
pt: Resolv::DNS::Requester::TCP::Sender
mt: instance
fn: sender
fs: sender(msg, data, queue, host=@host, port=@port)
fd: 
pt: Resolv::DNS::Requester::TCP
mt: instance
fn: new
fs: new()
fd: 
pt: Resolv::DNS::Requester::UnconnectedUDP
mt: class
fn: new
fs: new(msg, data, sock, host, port, queue)
fd: 
pt: Resolv::DNS::Requester::UnconnectedUDP::Sender
mt: class
fn: send
fs: send()
fd: 
pt: Resolv::DNS::Requester::UnconnectedUDP::Sender
mt: instance
fn: sender
fs: sender(msg, data, queue, host, port=Port)
fd: 
pt: Resolv::DNS::Requester::UnconnectedUDP
mt: instance
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::DomainName
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::DomainName
mt: instance
fn: new
fs: new(name)
fd: 
pt: Resolv::DNS::Resource::DomainName
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource
mt: instance
fn: eql?
fs: eql?(other)
fd: 
pt: Resolv::DNS::Resource
mt: instance
fn: create
fs: create(type_value, class_value)
fd: 
pt: Resolv::DNS::Resource::Generic
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::Generic
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::Generic
mt: instance
fn: new
fs: new(data)
fd: 
pt: Resolv::DNS::Resource::Generic
mt: class
fn: get_class
fs: get_class(type_value, class_value)
fd: 
pt: Resolv::DNS::Resource
mt: class
fn: hash
fs: hash()
fd: 
pt: Resolv::DNS::Resource
mt: instance
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::HINFO
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::HINFO
mt: instance
fn: new
fs: new(cpu, os)
fd: 
pt: Resolv::DNS::Resource::HINFO
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::IN::A
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::IN::A
mt: instance
fn: new
fs: new(address)
fd: 
pt: Resolv::DNS::Resource::IN::A
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::IN::AAAA
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::IN::AAAA
mt: instance
fn: new
fs: new(address)
fd: 
pt: Resolv::DNS::Resource::IN::AAAA
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::IN::SRV
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::IN::SRV
mt: instance
fn: new
fs: new(priority, weight, port, target)
fd: Create a SRV resource record.
pt: Resolv::DNS::Resource::IN::SRV
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::IN::WKS
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::IN::WKS
mt: instance
fn: new
fs: new(address, protocol, bitmap)
fd: 
pt: Resolv::DNS::Resource::IN::WKS
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::MINFO
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::MINFO
mt: instance
fn: new
fs: new(rmailbx, emailbx)
fd: 
pt: Resolv::DNS::Resource::MINFO
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::MX
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::MX
mt: instance
fn: new
fs: new(preference, exchange)
fd: 
pt: Resolv::DNS::Resource::MX
mt: class
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::SOA
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::SOA
mt: instance
fn: new
fs: new(mname, rname, serial, refresh, retry_, expire, minimum)
fd: 
pt: Resolv::DNS::Resource::SOA
mt: class
fn: data
fs: data()
fd: 
pt: Resolv::DNS::Resource::TXT
mt: instance
fn: decode_rdata
fs: decode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::TXT
mt: class
fn: encode_rdata
fs: encode_rdata(msg)
fd: 
pt: Resolv::DNS::Resource::TXT
mt: instance
fn: new
fs: new(first_string, *rest_strings)
fd: 
pt: Resolv::DNS::Resource::TXT
mt: class
fn: each_address
fs: each_address(name, &block)
fd: 
pt: Resolv
mt: class
fn: each_address
fs: each_address(name)
fd: 
pt: Resolv
mt: instance
fn: each_name
fs: each_name(address, &proc)
fd: 
pt: Resolv
mt: class
fn: each_name
fs: each_name(address)
fd: 
pt: Resolv
mt: instance
fn: getaddress
fs: getaddress(name)
fd: 
pt: Resolv
mt: class
fn: getaddress
fs: getaddress(name)
fd: 
pt: Resolv
mt: instance
fn: getaddresses
fs: getaddresses(name)
fd: 
pt: Resolv
mt: class
fn: getaddresses
fs: getaddresses(name)
fd: 
pt: Resolv
mt: instance
fn: getname
fs: getname(address)
fd: 
pt: Resolv
mt: class
fn: getname
fs: getname(address)
fd: 
pt: Resolv
mt: instance
fn: getnames
fs: getnames(address)
fd: 
pt: Resolv
mt: class
fn: getnames
fs: getnames(address)
fd: 
pt: Resolv
mt: instance
fn: each_address
fs: each_address(name, &proc)
fd: 
pt: Resolv::Hosts
mt: instance
fn: each_name
fs: each_name(address, &proc)
fd: 
pt: Resolv::Hosts
mt: instance
fn: getaddress
fs: getaddress(name)
fd: 
pt: Resolv::Hosts
mt: instance
fn: getaddresses
fs: getaddresses(name)
fd: 
pt: Resolv::Hosts
mt: instance
fn: getname
fs: getname(address)
fd: 
pt: Resolv::Hosts
mt: instance
fn: getnames
fs: getnames(address)
fd: 
pt: Resolv::Hosts
mt: instance
fn: lazy_initialize
fs: lazy_initialize()
fd: 
pt: Resolv::Hosts
mt: instance
fn: new
fs: new(filename = DefaultFileName)
fd: 
pt: Resolv::Hosts
mt: class
fn: create
fs: create(arg)
fd: 
pt: Resolv::IPv4
mt: class
fn: eql?
fs: eql?(other)
fd: 
pt: Resolv::IPv4
mt: instance
fn: hash
fs: hash()
fd: 
pt: Resolv::IPv4
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: Resolv::IPv4
mt: instance
fn: new
fs: new(address)
fd: 
pt: Resolv::IPv4
mt: class
fn: to_name
fs: to_name()
fd: 
pt: Resolv::IPv4
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: Resolv::IPv4
mt: instance
fn: create
fs: create(arg)
fd: 
pt: Resolv::IPv6
mt: class
fn: eql?
fs: eql?(other)
fd: 
pt: Resolv::IPv6
mt: instance
fn: hash
fs: hash()
fd: 
pt: Resolv::IPv6
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: Resolv::IPv6
mt: instance
fn: new
fs: new(address)
fd: 
pt: Resolv::IPv6
mt: class
fn: to_name
fs: to_name()
fd: 
pt: Resolv::IPv6
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: Resolv::IPv6
mt: instance
fn: new
fs: new(resolvers=[Hosts.new, DNS.new])
fd: 
pt: Resolv
mt: class
fn: each
fs: each(&block)
fd: "Itterate over the key/value pairs:"
pt: REXML::AttlistDecl
mt: instance
fn: include?
fs: include?(key)
fd: Whether an attlist declaration includes the given attribute definition
pt: REXML::AttlistDecl
mt: instance
fn: new
fs: new(source)
fd: Create an AttlistDecl, pulling the information from a Source. Notice that this isn't very convenient; to create an AttlistDecl, you basically have to format it yourself, and then have the initializer parse it. Sorry, but for the forseeable future, DTD support in REXML is pretty weak on convenience. Have I mentioned how much I hate DTDs?
pt: REXML::AttlistDecl
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::AttlistDecl
mt: instance
fn: write
fs: write(out, indent=-1)
fd: Write out exactly what we got in.
pt: REXML::AttlistDecl
mt: instance
fn: clone
fs: clone()
fd: Returns a copy of this attribute
pt: REXML::Attribute
mt: instance
fn: element=
fs: element=( element )
fd: Sets the element of which this object is an attribute. Normally, this is not directly called.
pt: REXML::Attribute
mt: instance
fn: hash
fs: hash()
fd: Creates (and returns) a hash from both the name and value
pt: REXML::Attribute
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Attribute
mt: instance
fn: namespace
fs: namespace(arg=nil)
fd: Returns the namespace URL, if defined, or nil otherwise
pt: REXML::Attribute
mt: instance
fn: new
fs: new( first, second=nil, parent=nil )
fd: "Constructor. FIXME: The parser doesn't catch illegal characters in attributes"
pt: REXML::Attribute
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::Attribute
mt: instance
fn: prefix
fs: prefix()
fd: Returns the namespace of the attribute.
pt: REXML::Attribute
mt: instance
fn: remove
fs: remove()
fd: Removes this Attribute from the tree, and returns true if successfull
pt: REXML::Attribute
mt: instance
fn: to_s
fs: to_s()
fd: Returns the attribute value, with entities replaced
pt: REXML::Attribute
mt: instance
fn: to_string
fs: to_string()
fd: Returns this attribute out as XML source, expanding the name
pt: REXML::Attribute
mt: instance
fn: value
fs: value()
fd: Returns the UNNORMALIZED value of this attribute. That is, entities have been expanded to their values
pt: REXML::Attribute
mt: instance
fn: write
fs: write( output, indent=-1 )
fd: Writes this attribute (EG, puts 'key=&quot;value&quot;' to the output)
pt: REXML::Attribute
mt: instance
fn: xpath
fs: xpath()
fd: 
pt: REXML::Attribute
mt: instance
fn: add
fs: add( attribute )
fd: Adds an attribute, overriding any existing attribute by the same name. Namespaces are significant.
pt: REXML::Attributes
mt: instance
fn: delete
fs: delete( attribute )
fd: Removes an attribute
pt: REXML::Attributes
mt: instance
fn: delete_all
fs: delete_all( name )
fd: Deletes all attributes matching a name. Namespaces are significant.
pt: REXML::Attributes
mt: instance
fn: each
fs: each()
fd: Itterates over each attribute of an Element, yielding the expanded name and value as a pair of Strings.
pt: REXML::Attributes
mt: instance
fn: each_attribute
fs: each_attribute( {|attribute| ...}
fd: Itterates over the attributes of an Element. Yields actual Attribute nodes, not String values.
pt: REXML::Attributes
mt: instance
fn: get_attribute
fs: get_attribute( name )
fd: Fetches an attribute
pt: REXML::Attributes
mt: instance
fn: get_attribute_ns
fs: get_attribute_ns(namespace, name)
fd: The get_attribute_ns method retrieves a method by its namespace and name. Thus it is possible to reliably identify an attribute even if an XML processor has changed the prefix.
pt: REXML::Attributes
mt: instance
fn: length
fs: length()
fd: Returns the number of attributes the owning Element contains.
pt: REXML::Attributes
mt: instance
fn: namespaces
fs: namespaces()
fd: 
pt: REXML::Attributes
mt: instance
fn: new
fs: new(element)
fd: Constructor
pt: REXML::Attributes
mt: class
fn: prefixes
fs: prefixes()
fd: "Returns an array of Strings containing all of the prefixes declared by this set of # attributes. The array does not include the default namespace declaration, if one exists."
pt: REXML::Attributes
mt: instance
fn: size
fs: size()
fd: "Alias for #length"
pt: REXML::Attributes
mt: instance
fn: to_a
fs: to_a()
fd: 
pt: REXML::Attributes
mt: instance
fn: clone
fs: clone()
fd: Make a copy of this object
pt: REXML::CData
mt: instance
fn: new
fs: new( first, whitespace=true, parent=nil )
fd: "    Constructor.  CData is data between &lt;![CDATA[ ... ]]&gt;\n"
pt: REXML::CData
mt: class
fn: to_s
fs: to_s()
fd: Returns the content of this CData object
pt: REXML::CData
mt: instance
fn: value
fs: value()
fd: 
pt: REXML::CData
mt: instance
fn: write
fs: write( output=$stdout, indent=-1, transitive=false, ie_hack=false )
fd: See the rexml/formatters package
pt: REXML::CData
mt: instance
fn: bytes
fs: bytes()
fd: This doesn't yet handle encodings
pt: REXML::Child
mt: instance
fn: document
fs: document()
fd: the document this child belongs to, or nil if this child
pt: REXML::Child
mt: instance
fn: new
fs: new( parent = nil )
fd: Constructor. Any inheritors of this class should call super to make sure this method is called.
pt: REXML::Child
mt: class
fn: next_sibling=
fs: next_sibling=( other )
fd: Sets the next sibling of this child. This can be used to insert a child after some other child.
pt: REXML::Child
mt: instance
fn: parent=
fs: parent=( other )
fd: Sets the parent of this child to the supplied argument.
pt: REXML::Child
mt: instance
fn: previous_sibling=
fs: previous_sibling=(other)
fd: Sets the previous sibling of this child. This can be used to insert a child before some other child.
pt: REXML::Child
mt: instance
fn: remove
fs: remove()
fd: Removes this child from the parent.
pt: REXML::Child
mt: instance
fn: replace_with
fs: replace_with( child )
fd: Replaces this object with another object. Basically, calls Parent.replace_child
pt: REXML::Child
mt: instance
fn: clone
fs: clone()
fd: 
pt: REXML::Comment
mt: instance
fn: new
fs: new( first, second = nil )
fd: "Constructor. The first argument can be one of three types: @param first If String, the contents of this comment are set to the argument. If Comment, the argument is duplicated. If Source, the argument is scanned for a comment. @param second If the first argument is a Source, this argument should be nil, not supplied, or a Parent to be set as the parent of this object"
pt: REXML::Comment
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::Comment
mt: instance
fn: write
fs: write( output, indent=-1, transitive=false, ie_hack=false )
fd: See REXML::Formatters
pt: REXML::Comment
mt: instance
fn: new
fs: new(src)
fd: 
pt: REXML::Declaration
mt: class
fn: to_s
fs: to_s()
fd: 
pt: REXML::Declaration
mt: instance
fn: write
fs: write( output, indent )
fd: See REXML::Formatters
pt: REXML::Declaration
mt: instance
fn: add
fs: add(child)
fd: 
pt: REXML::DocType
mt: instance
fn: attribute_of
fs: attribute_of(element, attribute)
fd: 
pt: REXML::DocType
mt: instance
fn: attributes_of
fs: attributes_of(element)
fd: 
pt: REXML::DocType
mt: instance
fn: clone
fs: clone()
fd: 
pt: REXML::DocType
mt: instance
fn: context
fs: context()
fd: 
pt: REXML::DocType
mt: instance
fn: entity
fs: entity( name )
fd: 
pt: REXML::DocType
mt: instance
fn: new
fs: new( first, parent=nil )
fd: Constructor
pt: REXML::DocType
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::DocType
mt: instance
fn: notation
fs: notation(name)
fd: Retrieves a named notation. Only notations declared in the internal DTD subset can be retrieved.
pt: REXML::DocType
mt: instance
fn: notations
fs: notations()
fd: This method returns a list of notations that have been declared in the internal DTD subset. Notations in the external DTD subset are not listed.
pt: REXML::DocType
mt: instance
fn: public
fs: public()
fd: This method retrieves the public identifier identifying the document's DTD.
pt: REXML::DocType
mt: instance
fn: system
fs: system()
fd: This method retrieves the system identifier identifying the document's DTD
pt: REXML::DocType
mt: instance
fn: write
fs: write( output, indent=0, transitive=false, ie_hack=false )
fd: Where to write the string
pt: REXML::DocType
mt: instance
fn: add
fs: add( child )
fd: We override this, because XMLDecls and DocTypes must go at the start of the document
pt: REXML::Document
mt: instance
fn: add_element
fs: add_element(arg=nil, arg2=nil)
fd: 
pt: REXML::Document
mt: instance
fn: clone
fs: clone()
fd: Should be obvious
pt: REXML::Document
mt: instance
fn: doctype
fs: doctype()
fd: "@return the DocType child of the document, if one exists, and nil otherwise."
pt: REXML::Document
mt: instance
fn: encoding
fs: encoding()
fd: "@return the XMLDecl encoding of this document as a String. If no XMLDecl has been set, returns the default encoding."
pt: REXML::Document
mt: instance
fn: expanded_name
fs: expanded_name()
fd: According to the XML spec, a root node has no expanded name
pt: REXML::Document
mt: instance
fn: name
fs: name()
fd: "Alias for #expanded_name"
pt: REXML::Document
mt: instance
fn: new
fs: new( source = nil, context = {} )
fd: Constructor @param source if supplied, must be a Document, String, or IO. Documents have their context and Element attributes cloned. Strings are expected to be valid XML documents. IOs are expected to be sources of valid XML documents. @param context if supplied, contains the context of the document; this should be a Hash.
pt: REXML::Document
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::Document
mt: instance
fn: parse_stream
fs: parse_stream( source, listener )
fd: 
pt: REXML::Document
mt: class
fn: root
fs: root()
fd: "@return the root Element of the document, or nil if this document has no children."
pt: REXML::Document
mt: instance
fn: stand_alone?
fs: stand_alone?()
fd: "@return the XMLDecl standalone value of this document as a String. If no XMLDecl has been set, returns the default setting."
pt: REXML::Document
mt: instance
fn: version
fs: version()
fd: "@return the XMLDecl version of this document as a String. If no XMLDecl has been set, returns the default version."
pt: REXML::Document
mt: instance
fn: write
fs: write( output=$stdout, indent=-1, transitive=false, ie_hack=false )
fd: Write the XML tree out, optionally with indent. This writes out the entire XML document, including XML declarations, doctype declarations, and processing instructions (if any are given).
pt: REXML::Document
mt: instance
fn: xml_decl
fs: xml_decl()
fd: "@return the XMLDecl of this document; if no XMLDecl has been set, the default declaration is returned."
pt: REXML::Document
mt: instance
fn: new
fs: new(match)
fd: \s*(((([&quot;']).*?\5)|[^\/'&quot;&gt;]*)*?)(\/)?&gt;/um, true)
pt: REXML::DTD::ElementDecl
mt: class
fn: new
fs: new(src)
fd: "&lt;!ENTITY name SYSTEM &quot;...&quot;&gt; &lt;!ENTITY name &quot;...&quot;&gt;"
pt: REXML::DTD::EntityDecl
mt: class
fn: parse_source
fs: parse_source(source, listener)
fd: 
pt: REXML::DTD::EntityDecl
mt: class
fn: to_s
fs: to_s()
fd: 
pt: REXML::DTD::EntityDecl
mt: instance
fn: write
fs: write( output, indent )
fd: 
pt: REXML::DTD::EntityDecl
mt: instance
fn: new
fs: new(src)
fd: 
pt: REXML::DTD::NotationDecl
mt: class
fn: parse_source
fs: parse_source(source, listener)
fd: 
pt: REXML::DTD::NotationDecl
mt: class
fn: to_s
fs: to_s()
fd: 
pt: REXML::DTD::NotationDecl
mt: instance
fn: write
fs: write( output, indent )
fd: 
pt: REXML::DTD::NotationDecl
mt: instance
fn: parse
fs: parse( input )
fd: 
pt: REXML::DTD::Parser
mt: class
fn: parse_helper
fs: parse_helper( input )
fd: Takes a String and parses it out
pt: REXML::DTD::Parser
mt: class
fn: add_attribute
fs: add_attribute( key, value=nil )
fd: Adds an attribute to this element, overwriting any existing attribute by the same name.
pt: REXML::Element
mt: instance
fn: add_attributes
fs: add_attributes(hash)
fd: Add multiple attributes to this element.
pt: REXML::Element
mt: instance
fn: add_element
fs: add_element(element, attrs=nil)
fd: Adds a child to this element, optionally setting attributes in the element.
pt: REXML::Element
mt: instance
fn: add_namespace
fs: add_namespace( prefix, uri=nil )
fd: Adds a namespace to this element.
pt: REXML::Element
mt: instance
fn: add_text
fs: add_text( text )
fd: A helper method to add a Text child. Actual Text instances can be added with regular Parent methods, such as add() and &lt;&lt;()
pt: REXML::Element
mt: instance
fn: attribute
fs: attribute( name, namespace=nil )
fd: "Attributes #"
pt: REXML::Element
mt: instance
fn: cdatas
fs: cdatas()
fd: Get an array of all CData children. IMMUTABLE
pt: REXML::Element
mt: instance
fn: clone
fs: clone()
fd: Creates a shallow copy of self.
pt: REXML::Element
mt: instance
fn: comments
fs: comments()
fd: Get an array of all Comment children. IMMUTABLE
pt: REXML::Element
mt: instance
fn: delete_attribute
fs: delete_attribute(key)
fd: Removes an attribute
pt: REXML::Element
mt: instance
fn: delete_element
fs: delete_element(element)
fd: Deletes a child element.
pt: REXML::Element
mt: instance
fn: delete_namespace
fs: delete_namespace(namespace="xmlns")
fd: Removes a namespace from this node. This only works if the namespace is actually declared in this node. If no argument is passed, deletes the default namespace.
pt: REXML::Element
mt: instance
fn: document
fs: document()
fd: Evaluates to the document to which this element belongs, or nil if this element doesn't belong to a document.
pt: REXML::Element
mt: instance
fn: each_element
fs: each_element( xpath=nil )
fd: Synonym for Element.elements.each
pt: REXML::Element
mt: instance
fn: each_element_with_attribute
fs: each_element_with_attribute( key, value=nil, max=0, name=nil )
fd: Iterates through the child elements, yielding for each Element that has a particular attribute set.
pt: REXML::Element
mt: instance
fn: each_element_with_text
fs: each_element_with_text( text=nil, max=0, name=nil )
fd: Iterates through the children, yielding for each Element that has a particular text set.
pt: REXML::Element
mt: instance
fn: get_elements
fs: get_elements( xpath )
fd: Synonym for Element.to_a This is a little slower than calling elements.each directly.
pt: REXML::Element
mt: instance
fn: get_text
fs: get_text(path = nil)
fd: Returns the first child Text node, if any, or nil otherwise. This method returns the actual Text node, rather than the String content.
pt: REXML::Element
mt: instance
fn: has_attributes?
fs: has_attributes?()
fd: Evaluates to true if this element has any attributes set, false otherwise.
pt: REXML::Element
mt: instance
fn: has_elements?
fs: has_elements?()
fd: Evaluates to true if this element has at least one child Element
pt: REXML::Element
mt: instance
fn: has_text?
fs: has_text?()
fd: Evaluates to true if this element has at least one Text child
pt: REXML::Element
mt: instance
fn: ignore_whitespace_nodes
fs: ignore_whitespace_nodes()
fd: 
pt: REXML::Element
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Element
mt: instance
fn: instructions
fs: instructions()
fd: Get an array of all Instruction children. IMMUTABLE
pt: REXML::Element
mt: instance
fn: namespace
fs: namespace(prefix=nil)
fd: Evalutas to the URI for a prefix, or the empty string if no such namespace is declared for this element. Evaluates recursively for ancestors. Returns the default namespace, if there is one.
pt: REXML::Element
mt: instance
fn: namespaces
fs: namespaces()
fd: 
pt: REXML::Element
mt: instance
fn: new
fs: new( arg = UNDEFINED, parent=nil, context=nil )
fd: Constructor
pt: REXML::Element
mt: class
fn: next_element
fs: next_element()
fd: Returns the next sibling that is an element, or nil if there is no Element sibling after this one
pt: REXML::Element
mt: instance
fn: node_type
fs: node_type()
fd: 
pt: REXML::Element
mt: instance
fn: prefixes
fs: prefixes()
fd: Evaluates to an Array containing the prefixes (names) of all defined namespaces at this context node.
pt: REXML::Element
mt: instance
fn: previous_element
fs: previous_element()
fd: Returns the previous sibling that is an element, or nil if there is no Element sibling prior to this one
pt: REXML::Element
mt: instance
fn: raw
fs: raw()
fd: Evaluates to true if raw mode is set for this element. This is the case if the context has :raw set to :all or an array containing the name of this element.
pt: REXML::Element
mt: instance
fn: root
fs: root()
fd: 
pt: REXML::Element
mt: instance
fn: root_node
fs: root_node()
fd: Evaluates to the root node of the document that this element belongs to. If this element doesn't belong to a document, but does belong to another Element, the parent's root will be returned, until the earliest ancestor is found.
pt: REXML::Element
mt: instance
fn: text=
fs: text=( text )
fd: Sets the first Text child of this object. See text() for a discussion about Text children.
pt: REXML::Element
mt: instance
fn: text
fs: text( path = nil )
fd: A convenience method which returns the String value of the first child text element, if one exists, and nil otherwise.
pt: REXML::Element
mt: instance
fn: texts
fs: texts()
fd: Get an array of all Text children. IMMUTABLE
pt: REXML::Element
mt: instance
fn: whitespace
fs: whitespace()
fd: "Evaluates to true if whitespace is respected for this element. This is the case if:"
pt: REXML::Element
mt: instance
fn: write
fs: write(writer=$stdout, indent=-1, transitive=false, ie_hack=false)
fd: See REXML::Formatters
pt: REXML::Element
mt: instance
fn: xpath
fs: xpath()
fd: 
pt: REXML::Element
mt: instance
fn: new
fs: new( src )
fd: 
pt: REXML::ElementDecl
mt: class
fn: add
fs: add(element=nil)
fd: Adds an element
pt: REXML::Elements
mt: instance
fn: collect
fs: collect( xpath=nil, &block )
fd: 
pt: REXML::Elements
mt: instance
fn: delete
fs: delete(element)
fd: Deletes a child Element
pt: REXML::Elements
mt: instance
fn: delete_all
fs: delete_all( xpath )
fd: Removes multiple elements. Filters for Element children, regardless of XPath matching.
pt: REXML::Elements
mt: instance
fn: each
fs: each( xpath=nil, &block)
fd: Iterates through all of the child Elements, optionally filtering them by a given XPath
pt: REXML::Elements
mt: instance
fn: empty?
fs: empty?()
fd: Returns true if there are no Element children, false otherwise
pt: REXML::Elements
mt: instance
fn: index
fs: index(element)
fd: Returns the index of the supplied child (starting at 1), or -1 if the element is not a child
pt: REXML::Elements
mt: instance
fn: inject
fs: inject( xpath=nil, initial=nil, &block )
fd: 
pt: REXML::Elements
mt: instance
fn: new
fs: new(parent)
fd: Constructor
pt: REXML::Elements
mt: class
fn: size
fs: size()
fd: Returns the number of Element children of the parent object.
pt: REXML::Elements
mt: instance
fn: to_a
fs: to_a( xpath=nil )
fd: Returns an Array of Element children. An XPath may be supplied to filter the children. Only Element children are returned, even if the supplied XPath matches non-Element children.
pt: REXML::Elements
mt: instance
fn: apply
fs: apply(obj, enc)
fd: 
pt: REXML::Encoding
mt: class
fn: check_encoding
fs: check_encoding(str)
fd: 
pt: REXML::Encoding
mt: instance
fn: decode_ascii
fs: decode_ascii(str)
fd: Convert to UTF-8
pt: REXML::Encoding
mt: instance
fn: decode_cp1252
fs: decode_cp1252(str)
fd: Convert to UTF-8
pt: REXML::Encoding
mt: instance
fn: decode_eucjp
fs: decode_eucjp(str)
fd: 
pt: REXML::Encoding
mt: instance
fn: decode_iconv
fs: decode_iconv(str)
fd: 
pt: REXML::Encoding
mt: instance
fn: decode_sjis
fs: decode_sjis(str)
fd: 
pt: REXML::Encoding
mt: instance
fn: decode_unile
fs: decode_unile(str)
fd: 
pt: REXML::Encoding
mt: instance
fn: decode_utf16
fs: decode_utf16(str)
fd: 
pt: REXML::Encoding
mt: instance
fn: decode_utf8
fs: decode_utf8(str)
fd: 
pt: REXML::Encoding
mt: instance
fn: encode_ascii
fs: encode_ascii(content)
fd: Convert from UTF-8
pt: REXML::Encoding
mt: instance
fn: encode_cp1252
fs: encode_cp1252(content)
fd: Convert from UTF-8
pt: REXML::Encoding
mt: instance
fn: encode_eucjp
fs: encode_eucjp(content)
fd: 
pt: REXML::Encoding
mt: instance
fn: encode_iconv
fs: encode_iconv(content)
fd: 
pt: REXML::Encoding
mt: instance
fn: encode_sjis
fs: encode_sjis(content)
fd: 
pt: REXML::Encoding
mt: instance
fn: encode_unile
fs: encode_unile(content)
fd: 
pt: REXML::Encoding
mt: instance
fn: encode_utf16
fs: encode_utf16(content)
fd: 
pt: REXML::Encoding
mt: instance
fn: encode_utf8
fs: encode_utf8(content)
fd: 
pt: REXML::Encoding
mt: instance
fn: encoding=
fs: encoding=( enc )
fd: 
pt: REXML::Encoding
mt: instance
fn: encoding_method
fs: encoding_method(enc)
fd: 
pt: REXML::Encoding
mt: class
fn: from_iso_8859_15
fs: from_iso_8859_15(str)
fd: Convert to UTF-8
pt: REXML::Encoding
mt: instance
fn: register
fs: register(enc, &block)
fd: 
pt: REXML::Encoding
mt: class
fn: to_iso_8859_15
fs: to_iso_8859_15(content)
fd: Convert from UTF-8
pt: REXML::Encoding
mt: instance
fn: matches?
fs: matches?(string)
fd: Evaluates whether the given string matchs an entity definition, returning true if so, and false otherwise.
pt: REXML::Entity
mt: class
fn: new
fs: new(stream, value=nil, parent=nil, reference=false)
fd: "Create a new entity. Simple entities can be constructed by passing a name, value to the constructor; this creates a generic, plain entity reference. For anything more complicated, you have to pass a Source to the constructor with the entity definiton, or use the accessor methods. WARNING: There is no validation of entity state except when the entity is read from a stream. If you start poking around with the accessors, you can easily create a non-conformant Entity. The best thing to do is dump the stupid DTDs and use XMLSchema instead."
pt: REXML::Entity
mt: class
fn: normalized
fs: normalized()
fd: Returns the value of this entity unprocessed -- raw. This is the normalized value; that is, with all %ent; and &amp;ent; entities intact
pt: REXML::Entity
mt: instance
fn: to_s
fs: to_s()
fd: Returns this entity as a string. See write().
pt: REXML::Entity
mt: instance
fn: unnormalized
fs: unnormalized()
fd: Evaluates to the unnormalized value of this entity; that is, replacing all entities -- both %ent; and &amp;ent; entities. This differs from +value()+ in that value only replaces %ent; entities.
pt: REXML::Entity
mt: instance
fn: value
fs: value()
fd: "Returns the value of this entity. At the moment, only internal entities are processed. If the value contains internal references (IE, %blah;), those are replaced with their values. IE, if the doctype contains:"
pt: REXML::Entity
mt: instance
fn: write
fs: write(out, indent=-1)
fd: Write out a fully formed, correct entity definition (assuming the Entity object itself is valid.)
pt: REXML::Entity
mt: instance
fn: new
fs: new( src )
fd: 
pt: REXML::ExternalEntity
mt: class
fn: to_s
fs: to_s()
fd: 
pt: REXML::ExternalEntity
mt: instance
fn: write
fs: write( output, indent )
fd: 
pt: REXML::ExternalEntity
mt: instance
fn: new
fs: new( ie_hack=false )
fd: Prints out the XML document with no formatting -- except if id_hack is set.
pt: REXML::Formatters::Default
mt: class
fn: write
fs: write( node, output )
fd: Writes the node to some output.
pt: REXML::Formatters::Default
mt: instance
fn: new
fs: new( indentation=2, ie_hack=false )
fd: Create a new pretty printer.
pt: REXML::Formatters::Pretty
mt: class
fn: new
fs: new( indentation=2 )
fd: 
pt: REXML::Formatters::Transitive
mt: class
fn: boolean
fs: boolean( object=nil )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: ceiling
fs: ceiling( number )
fd: 
pt: REXML::Functions
mt: class
fn: compare_language
fs: compare_language(lang1, lang2)
fd: 
pt: REXML::Functions
mt: class
fn: concat
fs: concat( *objects )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: contains
fs: contains( string, test )
fd: Fixed by Mike Stok
pt: REXML::Functions
mt: class
fn: context=
fs: context=(value)
fd: 
pt: REXML::Functions
mt: class
fn: count
fs: count( node_set )
fd: 
pt: REXML::Functions
mt: class
fn: "false"
fs: "false"( )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: floor
fs: floor( number )
fd: 
pt: REXML::Functions
mt: class
fn: get_namespace
fs: get_namespace( node_set = nil )
fd: Helper method.
pt: REXML::Functions
mt: class
fn: id
fs: id( object )
fd: Since REXML is non-validating, this method is not implemented as it requires a DTD
pt: REXML::Functions
mt: class
fn: lang
fs: lang( language )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: last
fs: last( )
fd: 
pt: REXML::Functions
mt: class
fn: local_name
fs: local_name( node_set=nil )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: method_missing
fs: method_missing( id )
fd: 
pt: REXML::Functions
mt: class
fn: name
fs: name( node_set=nil )
fd: 
pt: REXML::Functions
mt: class
fn: namespace_context=
fs: namespace_context=(x)
fd: 
pt: REXML::Functions
mt: class
fn: namespace_context
fs: namespace_context()
fd: 
pt: REXML::Functions
mt: class
fn: namespace_uri
fs: namespace_uri( node_set=nil )
fd: 
pt: REXML::Functions
mt: class
fn: normalize_space
fs: normalize_space( string=nil )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: not
fs: not( object )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: number
fs: number( object=nil )
fd: a string that consists of optional whitespace followed by an optional minus sign followed by a Number followed by whitespace is converted to the IEEE 754 number that is nearest (according to the IEEE 754 round-to-nearest rule) to the mathematical value represented by the string; any other string is converted to NaN
pt: REXML::Functions
mt: class
fn: position
fs: position( )
fd: 
pt: REXML::Functions
mt: class
fn: processing_instruction
fs: processing_instruction( node )
fd: 
pt: REXML::Functions
mt: class
fn: round
fs: round( number )
fd: 
pt: REXML::Functions
mt: class
fn: starts_with
fs: starts_with( string, test )
fd: Fixed by Mike Stok
pt: REXML::Functions
mt: class
fn: string
fs: string( object=nil )
fd: A node-set is converted to a string by returning the string-value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned.
pt: REXML::Functions
mt: class
fn: string_length
fs: string_length( string )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: string_value
fs: string_value( o )
fd: 
pt: REXML::Functions
mt: class
fn: substring
fs: substring( string, start, length=nil )
fd: Take equal portions of Mike Stok and Sean Russell; mix vigorously, and pour into a tall, chilled glass. Serves 10,000.
pt: REXML::Functions
mt: class
fn: substring_after
fs: substring_after( string, test )
fd: Kouhei fixed this too
pt: REXML::Functions
mt: class
fn: substring_before
fs: substring_before( string, test )
fd: Kouhei fixed this
pt: REXML::Functions
mt: class
fn: sum
fs: sum( nodes )
fd: 
pt: REXML::Functions
mt: class
fn: text
fs: text( )
fd: 
pt: REXML::Functions
mt: class
fn: translate
fs: translate( string, tr1, tr2 )
fd: This is entirely Mike Stok's beast
pt: REXML::Functions
mt: class
fn: "true"
fs: "true"( )
fd: UNTESTED
pt: REXML::Functions
mt: class
fn: variables=
fs: variables=(x)
fd: 
pt: REXML::Functions
mt: class
fn: variables
fs: variables()
fd: 
pt: REXML::Functions
mt: class
fn: clone
fs: clone()
fd: 
pt: REXML::Instruction
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Instruction
mt: instance
fn: new
fs: new(target, content=nil)
fd: Constructs a new Instruction @param target can be one of a number of things. If String, then the target of this instruction is set to this. If an Instruction, then the Instruction is shallowly cloned (target and content are copied). If a Source, then the source is scanned and parsed for an Instruction declaration. @param content Must be either a String, or a Parent. Can only be a Parent if the target argument is a Source. Otherwise, this String is set as the content of this instruction.
pt: REXML::Instruction
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::Instruction
mt: instance
fn: write
fs: write(writer, indent=-1, transitive=false, ie_hack=false)
fd: See the rexml/formatters package
pt: REXML::Instruction
mt: instance
fn: consume
fs: consume( pattern )
fd: 
pt: REXML::IOSource
mt: instance
fn: current_line
fs: current_line()
fd: "@return the current line in the source"
pt: REXML::IOSource
mt: instance
fn: empty?
fs: empty?()
fd: 
pt: REXML::IOSource
mt: instance
fn: match
fs: match( pattern, cons=false )
fd: 
pt: REXML::IOSource
mt: instance
fn: new
fs: new(arg, block_size=500, encoding=nil)
fd: block_size has been deprecated
pt: REXML::IOSource
mt: class
fn: position
fs: position()
fd: 
pt: REXML::IOSource
mt: instance
fn: read
fs: read()
fd: 
pt: REXML::IOSource
mt: instance
fn: scan
fs: scan(pattern, cons=false)
fd: 
pt: REXML::IOSource
mt: instance
fn: children
fs: children()
fd: 
pt: REXML::Light::Node
mt: instance
fn: each
fs: each( &block )
fd: 
pt: REXML::Light::Node
mt: instance
fn: has_name?
fs: has_name?( name, namespace = '' )
fd: 
pt: REXML::Light::Node
mt: instance
fn: local_name=
fs: local_name=( name_str )
fd: 
pt: REXML::Light::Node
mt: instance
fn: local_name
fs: local_name()
fd: 
pt: REXML::Light::Node
mt: instance
fn: name=
fs: name=( name_str, ns=nil )
fd: 
pt: REXML::Light::Node
mt: instance
fn: name
fs: name()
fd: 
pt: REXML::Light::Node
mt: instance
fn: namespace=
fs: namespace=( namespace )
fd: 
pt: REXML::Light::Node
mt: instance
fn: namespace
fs: namespace( prefix=prefix()
fd: 
pt: REXML::Light::Node
mt: instance
fn: new
fs: new(node=nil)
fd: Create a new element.
pt: REXML::Light::Node
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::Light::Node
mt: instance
fn: parent=
fs: parent=( node )
fd: 
pt: REXML::Light::Node
mt: instance
fn: parent
fs: parent()
fd: 
pt: REXML::Light::Node
mt: instance
fn: prefix
fs: prefix( namespace=nil )
fd: 
pt: REXML::Light::Node
mt: instance
fn: root
fs: root()
fd: 
pt: REXML::Light::Node
mt: instance
fn: size
fs: size()
fd: 
pt: REXML::Light::Node
mt: instance
fn: text=
fs: text=( foo )
fd: 
pt: REXML::Light::Node
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: REXML::Light::Node
mt: instance
fn: fully_expanded_name
fs: fully_expanded_name()
fd: Fully expand the name, even if the prefix wasn't specified in the source file.
pt: REXML::Namespace
mt: instance
fn: has_name?
fs: has_name?( other, ns=nil )
fd: Compares names optionally WITH namespaces
pt: REXML::Namespace
mt: instance
fn: name=
fs: name=( name )
fd: Sets the name and the expanded name
pt: REXML::Namespace
mt: instance
fn: each_recursive
fs: each_recursive()
fd: Visit all subnodes of self recursively
pt: REXML::Node
mt: instance
fn: find_first_recursive
fs: find_first_recursive()
fd: Find (and return) first subnode (recursively) for which the block evaluates to true. Returns nil if none was found.
pt: REXML::Node
mt: instance
fn: indent
fs: indent(to, ind)
fd: 
pt: REXML::Node
mt: instance
fn: index_in_parent
fs: index_in_parent()
fd: Returns the position that self holds in its parent's array, indexed from 1.
pt: REXML::Node
mt: instance
fn: next_sibling_node
fs: next_sibling_node()
fd: "@return the next sibling (nil if unset)"
pt: REXML::Node
mt: instance
fn: parent?
fs: parent?()
fd: 
pt: REXML::Node
mt: instance
fn: previous_sibling_node
fs: previous_sibling_node()
fd: "@return the previous sibling (nil if unset)"
pt: REXML::Node
mt: instance
fn: to_s
fs: to_s(indent=nil)
fd: <b>DEPRECATED</b> This parameter is now ignored. See the formatters in the REXML::Formatters package for changing the output style.
pt: REXML::Node
mt: instance
fn: name
fs: name()
fd: This method retrieves the name of the notation.
pt: REXML::NotationDecl
mt: instance
fn: new
fs: new(name, middle, pub, sys)
fd: 
pt: REXML::NotationDecl
mt: class
fn: to_s
fs: to_s()
fd: 
pt: REXML::NotationDecl
mt: instance
fn: write
fs: write( output, indent=-1 )
fd: 
pt: REXML::NotationDecl
mt: instance
fn: new
fs: new(real_IO, encd="iso-8859-1")
fd: 
pt: REXML::Output
mt: class
fn: to_s
fs: to_s()
fd: 
pt: REXML::Output
mt: instance
fn: add
fs: add( object )
fd: 
pt: REXML::Parent
mt: instance
fn: children
fs: children()
fd: "Alias for #to_a"
pt: REXML::Parent
mt: instance
fn: deep_clone
fs: deep_clone()
fd: Deeply clones this object. This creates a complete duplicate of this Parent, including all descendants.
pt: REXML::Parent
mt: instance
fn: delete
fs: delete( object )
fd: 
pt: REXML::Parent
mt: instance
fn: delete_at
fs: delete_at( index )
fd: 
pt: REXML::Parent
mt: instance
fn: delete_if
fs: delete_if( &block )
fd: 
pt: REXML::Parent
mt: instance
fn: each
fs: each(&block)
fd: 
pt: REXML::Parent
mt: instance
fn: each_child
fs: each_child(&block)
fd: "Alias for #each"
pt: REXML::Parent
mt: instance
fn: each_index
fs: each_index( &block )
fd: 
pt: REXML::Parent
mt: instance
fn: index
fs: index( child )
fd: Fetches the index of a given child @param child the child to get the index of @return the index of the child, or nil if the object is not a child of this parent.
pt: REXML::Parent
mt: instance
fn: insert_after
fs: insert_after( child1, child2 )
fd: Inserts an child after another child @param child1 this is either an xpath or an Element. If an Element, child2 will be inserted after child1 in the child list of the parent. If an xpath, child2 will be inserted after the first child to match the xpath. @param child2 the child to insert @return the parent (self)
pt: REXML::Parent
mt: instance
fn: insert_before
fs: insert_before( child1, child2 )
fd: Inserts an child before another child @param child1 this is either an xpath or an Element. If an Element, child2 will be inserted before child1 in the child list of the parent. If an xpath, child2 will be inserted before the first child to match the xpath. @param child2 the child to insert @return the parent (self)
pt: REXML::Parent
mt: instance
fn: length
fs: length()
fd: "Alias for #size"
pt: REXML::Parent
mt: instance
fn: new
fs: new(parent=nil)
fd: Constructor @param parent if supplied, will be set as the parent of this object
pt: REXML::Parent
mt: class
fn: parent?
fs: parent?()
fd: 
pt: REXML::Parent
mt: instance
fn: push
fs: push( object )
fd: "Alias for #add"
pt: REXML::Parent
mt: instance
fn: replace_child
fs: replace_child( to_replace, replacement )
fd: Replaces one child with another, making sure the nodelist is correct @param to_replace the child to replace (must be a Child) @param replacement the child to insert into the nodelist (must be a Child)
pt: REXML::Parent
mt: instance
fn: size
fs: size()
fd: "@return the number of children of this parent"
pt: REXML::Parent
mt: instance
fn: to_a
fs: to_a()
fd: 
pt: REXML::Parent
mt: instance
fn: unshift
fs: unshift( object )
fd: 
pt: REXML::Parent
mt: instance
fn: context
fs: context()
fd: 
pt: REXML::ParseException
mt: instance
fn: line
fs: line()
fd: 
pt: REXML::ParseException
mt: instance
fn: new
fs: new( message, source=nil, parser=nil, exception=nil )
fd: 
pt: REXML::ParseException
mt: class
fn: position
fs: position()
fd: 
pt: REXML::ParseException
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: REXML::ParseException
mt: instance
fn: add_listener
fs: add_listener( listener )
fd: 
pt: REXML::Parsers::BaseParser
mt: instance
fn: empty?
fs: empty?()
fd: Returns true if there are no more events
pt: REXML::Parsers::BaseParser
mt: instance
fn: entity
fs: entity( reference, entities )
fd: 
pt: REXML::Parsers::BaseParser
mt: instance
fn: has_next?
fs: has_next?()
fd: Returns true if there are more events. Synonymous with !empty?
pt: REXML::Parsers::BaseParser
mt: instance
fn: new
fs: new( source )
fd: 
pt: REXML::Parsers::BaseParser
mt: class
fn: normalize
fs: normalize( input, entities=nil, entity_filter=nil )
fd: Escapes all possible entities
pt: REXML::Parsers::BaseParser
mt: instance
fn: peek
fs: peek(depth=0)
fd: Peek at the depth event in the stack. The first element on the stack is at depth 0. If depth is -1, will parse to the end of the input stream and return the last event, which is always :end_document. Be aware that this causes the stream to be parsed up to the depth event, so you can effectively pre-parse the entire document (pull the entire thing into memory) using this method.
pt: REXML::Parsers::BaseParser
mt: instance
fn: position
fs: position()
fd: 
pt: REXML::Parsers::BaseParser
mt: instance
fn: pull
fs: pull()
fd: Returns the next event. This is a PullEvent object.
pt: REXML::Parsers::BaseParser
mt: instance
fn: stream=
fs: stream=( source )
fd: 
pt: REXML::Parsers::BaseParser
mt: instance
fn: unnormalize
fs: unnormalize( string, entities=nil, filter=nil )
fd: Unescapes all possible entities
pt: REXML::Parsers::BaseParser
mt: instance
fn: unshift
fs: unshift(token)
fd: Push an event back on the head of the stream. This method has (theoretically) infinite depth.
pt: REXML::Parsers::BaseParser
mt: instance
fn: add_listener
fs: add_listener( listener )
fd: 
pt: REXML::Parsers::LightParser
mt: instance
fn: new
fs: new(stream)
fd: 
pt: REXML::Parsers::LightParser
mt: class
fn: parse
fs: parse()
fd: 
pt: REXML::Parsers::LightParser
mt: instance
fn: rewind
fs: rewind()
fd: 
pt: REXML::Parsers::LightParser
mt: instance
fn: attlistdecl?
fs: attlistdecl?()
fd: "Content: [ String text ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: cdata?
fs: cdata?()
fd: "Content: [ String text ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: comment?
fs: comment?()
fd: "Content: [ String text ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: doctype?
fs: doctype?()
fd: "Content: [ String name, String pub_sys, String long_name, String uri ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: elementdecl?
fs: elementdecl?()
fd: "Content: [ String text ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: end_element?
fs: end_element?()
fd: "Content: [ String tag_name ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: entity?
fs: entity?()
fd: "Content: [ String text ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: entitydecl?
fs: entitydecl?()
fd: "Due to the wonders of DTDs, an entity declaration can be just about anything. There's no way to normalize it; you'll have to interpret the content yourself. However, the following is true:"
pt: REXML::Parsers::PullEvent
mt: instance
fn: error?
fs: error?()
fd: 
pt: REXML::Parsers::PullEvent
mt: instance
fn: event_type
fs: event_type()
fd: 
pt: REXML::Parsers::PullEvent
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Parsers::PullEvent
mt: instance
fn: instruction?
fs: instruction?()
fd: "Content: [ String text ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: new
fs: new(arg)
fd: The type of this event. Will be one of :tag_start, :tag_end, :text, :processing_instruction, :comment, :doctype, :attlistdecl, :entitydecl, :notationdecl, :entity, :cdata, :xmldecl, or :error.
pt: REXML::Parsers::PullEvent
mt: class
fn: notationdecl?
fs: notationdecl?()
fd: "Content: [ String text ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: start_element?
fs: start_element?()
fd: "Content: [ String tag_name, Hash attributes ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: text?
fs: text?()
fd: "Content: [ String raw_text, String unnormalized_text ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: xmldecl?
fs: xmldecl?()
fd: "Content: [ String version, String encoding, String standalone ]"
pt: REXML::Parsers::PullEvent
mt: instance
fn: add_listener
fs: add_listener( listener )
fd: 
pt: REXML::Parsers::PullParser
mt: instance
fn: each
fs: each()
fd: 
pt: REXML::Parsers::PullParser
mt: instance
fn: new
fs: new(stream)
fd: 
pt: REXML::Parsers::PullParser
mt: class
fn: peek
fs: peek(depth=0)
fd: 
pt: REXML::Parsers::PullParser
mt: instance
fn: pull
fs: pull()
fd: 
pt: REXML::Parsers::PullParser
mt: instance
fn: unshift
fs: unshift(token)
fd: 
pt: REXML::Parsers::PullParser
mt: instance
fn: add_listener
fs: add_listener( listener )
fd: 
pt: REXML::Parsers::SAX2Parser
mt: instance
fn: deafen
fs: deafen( listener=nil, &blok )
fd: 
pt: REXML::Parsers::SAX2Parser
mt: instance
fn: listen
fs: listen( *args, &blok )
fd: "Listen arguments:"
pt: REXML::Parsers::SAX2Parser
mt: instance
fn: new
fs: new(source)
fd: 
pt: REXML::Parsers::SAX2Parser
mt: class
fn: parse
fs: parse()
fd: 
pt: REXML::Parsers::SAX2Parser
mt: instance
fn: source
fs: source()
fd: 
pt: REXML::Parsers::SAX2Parser
mt: instance
fn: add_listener
fs: add_listener( listener )
fd: 
pt: REXML::Parsers::StreamParser
mt: instance
fn: new
fs: new(source, listener)
fd: 
pt: REXML::Parsers::StreamParser
mt: class
fn: parse
fs: parse()
fd: 
pt: REXML::Parsers::StreamParser
mt: instance
fn: add_listener
fs: add_listener( listener )
fd: 
pt: REXML::Parsers::TreeParser
mt: instance
fn: new
fs: new( source, build_context = Document.new )
fd: 
pt: REXML::Parsers::TreeParser
mt: class
fn: parse
fs: parse()
fd: 
pt: REXML::Parsers::TreeParser
mt: instance
fn: add_listener
fs: add_listener( listener )
fd: 
pt: REXML::Parsers::UltraLightParser
mt: instance
fn: new
fs: new(stream)
fd: 
pt: REXML::Parsers::UltraLightParser
mt: class
fn: parse
fs: parse()
fd: 
pt: REXML::Parsers::UltraLightParser
mt: instance
fn: rewind
fs: rewind()
fd: 
pt: REXML::Parsers::UltraLightParser
mt: instance
fn: abbreviate
fs: abbreviate( path )
fd: 
pt: REXML::Parsers::XPathParser
mt: instance
fn: expand
fs: expand( path )
fd: 
pt: REXML::Parsers::XPathParser
mt: instance
fn: namespaces=
fs: namespaces=( namespaces )
fd: 
pt: REXML::Parsers::XPathParser
mt: instance
fn: parse
fs: parse(path)
fd: 
pt: REXML::Parsers::XPathParser
mt: instance
fn: predicate_to_string
fs: predicate_to_string( path, &block )
fd: 
pt: REXML::Parsers::XPathParser
mt: instance
fn: attribute
fs: attribute( name )
fd: 
pt: REXML::QuickPath
mt: class
fn: axe
fs: axe( elements, axe_name, rest )
fd: 
pt: REXML::QuickPath
mt: class
fn: each
fs: each(element, path, namespaces=EMPTY_HASH, &block)
fd: 
pt: REXML::QuickPath
mt: class
fn: filter
fs: filter(elements, path)
fd: Given an array of nodes it filters the array based on the path. The result is that when this method returns, the array will contain elements which match the path
pt: REXML::QuickPath
mt: class
fn: first
fs: first(element, path, namespaces=EMPTY_HASH)
fd: 
pt: REXML::QuickPath
mt: class
fn: function
fs: function( elements, fname, rest )
fd: 
pt: REXML::QuickPath
mt: class
fn: match
fs: match(element, path, namespaces=EMPTY_HASH)
fd: 
pt: REXML::QuickPath
mt: class
fn: method_missing
fs: method_missing( id, *args )
fd: 
pt: REXML::QuickPath
mt: class
fn: name
fs: name()
fd: 
pt: REXML::QuickPath
mt: class
fn: parse_args
fs: parse_args( element, string )
fd: 
pt: REXML::QuickPath
mt: class
fn: predicate
fs: predicate( elements, path )
fd: A predicate filters a node-set with respect to an axis to produce a new node-set. For each node in the node-set to be filtered, the PredicateExpr is evaluated with that node as the context node, with the number of nodes in the node-set as the context size, and with the proximity position of the node in the node-set with respect to the axis as the context position; if PredicateExpr evaluates to true for that node, the node is included in the new node-set; otherwise, it is not included.
pt: REXML::QuickPath
mt: class
fn: attlistdecl
fs: attlistdecl(element, pairs, contents)
fd: "If a doctype includes an ATTLIST declaration, it will cause this method to be called. The content is the declaration itself, unparsed. EG, &lt;!ATTLIST el attr CDATA #REQUIRED&gt; will come to this method as &quot;el attr CDATA #REQUIRED&quot;. This is the same for all of the .*decl methods."
pt: REXML::SAX2Listener
mt: instance
fn: cdata
fs: cdata(content)
fd: Called when &lt;![CDATA[ ... ]]&gt; is encountered in a document. @p content &quot;...&quot;
pt: REXML::SAX2Listener
mt: instance
fn: characters
fs: characters(text)
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: comment
fs: comment(comment)
fd: Called when a comment is encountered. @p comment The content of the comment
pt: REXML::SAX2Listener
mt: instance
fn: doctype
fs: doctype(name, pub_sys, long_name, uri)
fd: "Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil. # EG, &lt;!DOCTYPE me PUBLIC &quot;foo&quot; &quot;bar&quot;&gt; @p name the name of the doctype; EG, &quot;me&quot; @p pub_sys &quot;PUBLIC&quot;, &quot;SYSTEM&quot;, or nil. EG, &quot;PUBLIC&quot; @p long_name the supplied long name, or nil. EG, &quot;foo&quot; @p uri the uri of the doctype, or nil. EG, &quot;bar&quot;"
pt: REXML::SAX2Listener
mt: instance
fn: elementdecl
fs: elementdecl(content)
fd: "&lt;!ELEMENT ...&gt;"
pt: REXML::SAX2Listener
mt: instance
fn: end_document
fs: end_document()
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: end_element
fs: end_element(uri, localname, qname)
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: end_prefix_mapping
fs: end_prefix_mapping(prefix)
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: entitydecl
fs: entitydecl(name, decl)
fd: "&lt;!ENTITY ...&gt; The argument passed to this method is an array of the entity declaration. It can be in a number of formats, but in general it returns (example, result):"
pt: REXML::SAX2Listener
mt: instance
fn: notationdecl
fs: notationdecl(content)
fd: "&lt;!NOTATION ...&gt;"
pt: REXML::SAX2Listener
mt: instance
fn: processing_instruction
fs: processing_instruction(target, data)
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: progress
fs: progress(position)
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: start_document
fs: start_document()
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: start_element
fs: start_element(uri, localname, qname, attributes)
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: start_prefix_mapping
fs: start_prefix_mapping(prefix, uri)
fd: 
pt: REXML::SAX2Listener
mt: instance
fn: xmldecl
fs: xmldecl(version, encoding, standalone)
fd: "Called when an XML PI is encountered in the document. EG: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf&quot;?&gt; @p version the version attribute value. EG, &quot;1.0&quot; @p encoding the encoding attribute value, or nil. EG, &quot;utf&quot; @p standalone the standalone attribute value, or nil. EG, nil @p spaced the declaration is followed by a line break"
pt: REXML::SAX2Listener
mt: instance
fn: consume
fs: consume( pattern )
fd: 
pt: REXML::Source
mt: instance
fn: current_line
fs: current_line()
fd: "@return the current line in the source"
pt: REXML::Source
mt: instance
fn: empty?
fs: empty?()
fd: "@return true if the Source is exhausted"
pt: REXML::Source
mt: instance
fn: encoding=
fs: encoding=(enc)
fd: Inherited from Encoding Overridden to support optimized en/decoding
pt: REXML::Source
mt: instance
fn: match
fs: match(pattern, cons=false)
fd: 
pt: REXML::Source
mt: instance
fn: match_to
fs: match_to( char, pattern )
fd: 
pt: REXML::Source
mt: instance
fn: match_to_consume
fs: match_to_consume( char, pattern )
fd: 
pt: REXML::Source
mt: instance
fn: new
fs: new(arg, encoding=nil)
fd: Constructor @param arg must be a String, and should be a valid XML document @param encoding if non-null, sets the encoding of the source to this value, overriding all encoding detection
pt: REXML::Source
mt: class
fn: position
fs: position()
fd: 
pt: REXML::Source
mt: instance
fn: read
fs: read()
fd: 
pt: REXML::Source
mt: instance
fn: scan
fs: scan(pattern, cons=false)
fd: Scans the source for a given pattern. Note, that this is not your usual scan() method. For one thing, the pattern argument has some requirements; for another, the source can be consumed. You can easily confuse this method. Originally, the patterns were easier to construct and this method more robust, because this method generated search regexes on the fly; however, this was computationally expensive and slowed down the entire REXML package considerably, since this is by far the most commonly called method. @param pattern must be a Regexp, and must be in the form of /^\s*(#{your pattern, with no groups})(.*)/. The first group will be returned; the second group is used if the consume flag is set. @param consume if true, the pattern returned will be consumed, leaving everything after it in the Source. @return the pattern, if found, or nil if the Source is empty or the pattern is not found.
pt: REXML::Source
mt: instance
fn: create_from
fs: create_from(arg)
fd: Generates a Source object @param arg Either a String, or an IO @return a Source, or nil if a bad argument was given
pt: REXML::SourceFactory
mt: class
fn: attlistdecl
fs: attlistdecl(element_name, attributes, raw_content)
fd: "If a doctype includes an ATTLIST declaration, it will cause this method to be called. The content is the declaration itself, unparsed. EG, &lt;!ATTLIST el attr CDATA #REQUIRED&gt; will come to this method as &quot;el attr CDATA #REQUIRED&quot;. This is the same for all of the .*decl methods."
pt: REXML::StreamListener
mt: instance
fn: cdata
fs: cdata(content)
fd: Called when &lt;![CDATA[ ... ]]&gt; is encountered in a document. @p content &quot;...&quot;
pt: REXML::StreamListener
mt: instance
fn: comment
fs: comment(comment)
fd: Called when a comment is encountered. @p comment The content of the comment
pt: REXML::StreamListener
mt: instance
fn: doctype
fs: doctype(name, pub_sys, long_name, uri)
fd: "Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil. # EG, &lt;!DOCTYPE me PUBLIC &quot;foo&quot; &quot;bar&quot;&gt; @p name the name of the doctype; EG, &quot;me&quot; @p pub_sys &quot;PUBLIC&quot;, &quot;SYSTEM&quot;, or nil. EG, &quot;PUBLIC&quot; @p long_name the supplied long name, or nil. EG, &quot;foo&quot; @p uri the uri of the doctype, or nil. EG, &quot;bar&quot;"
pt: REXML::StreamListener
mt: instance
fn: doctype_end
fs: doctype_end()
fd: Called when the doctype is done
pt: REXML::StreamListener
mt: instance
fn: elementdecl
fs: elementdecl(content)
fd: "&lt;!ELEMENT ...&gt;"
pt: REXML::StreamListener
mt: instance
fn: entity
fs: entity(content)
fd: Called when %foo; is encountered in a doctype declaration. @p content &quot;foo&quot;
pt: REXML::StreamListener
mt: instance
fn: entitydecl
fs: entitydecl(content)
fd: "&lt;!ENTITY ...&gt; The argument passed to this method is an array of the entity declaration. It can be in a number of formats, but in general it returns (example, result):"
pt: REXML::StreamListener
mt: instance
fn: instruction
fs: instruction(name, instruction)
fd: "Called when an instruction is encountered. EG: &lt;?xsl sheet='foo'?&gt; @p name the instruction name; in the example, &quot;xsl&quot; @p instruction the rest of the instruction. In the example, &quot;sheet='foo'&quot;"
pt: REXML::StreamListener
mt: instance
fn: notationdecl
fs: notationdecl(content)
fd: "&lt;!NOTATION ...&gt;"
pt: REXML::StreamListener
mt: instance
fn: tag_end
fs: tag_end(name)
fd: Called when the end tag is reached. In the case of &lt;tag/&gt;, tag_end will be called immidiately after tag_start @p the name of the tag
pt: REXML::StreamListener
mt: instance
fn: tag_start
fs: tag_start(name, attrs)
fd: "Called when a tag is encountered. @p name the tag name @p attrs an array of arrays of attribute/value pairs, suitable for use with assoc or rassoc. IE, &lt;tag attr1=&quot;value1&quot; attr2=&quot;value2&quot;&gt; will result in tag_start( &quot;tag&quot;, # [[&quot;attr1&quot;,&quot;value1&quot;],[&quot;attr2&quot;,&quot;value2&quot;]])"
pt: REXML::StreamListener
mt: instance
fn: text
fs: text(text)
fd: Called when text is encountered in the document @p text the text content.
pt: REXML::StreamListener
mt: instance
fn: xmldecl
fs: xmldecl(version, encoding, standalone)
fd: "Called when an XML PI is encountered in the document. EG: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf&quot;?&gt; @p version the version attribute value. EG, &quot;1.0&quot; @p encoding the encoding attribute value, or nil. EG, &quot;utf&quot; @p standalone the standalone attribute value, or nil. EG, nil"
pt: REXML::StreamListener
mt: instance
fn: each
fs: each()
fd: Enumerates rows of the Enumerable objects.
pt: REXML::SyncEnumerator
mt: instance
fn: length
fs: length()
fd: Returns the number of enumerated Enumerable objects, i.e. the size of each row.
pt: REXML::SyncEnumerator
mt: instance
fn: new
fs: new(*enums)
fd: Creates a new SyncEnumerator which enumerates rows of given Enumerable objects.
pt: REXML::SyncEnumerator
mt: class
fn: size
fs: size()
fd: Returns the number of enumerated Enumerable objects, i.e. the size of each row.
pt: REXML::SyncEnumerator
mt: instance
fn: clone
fs: clone()
fd: 
pt: REXML::Text
mt: instance
fn: empty?
fs: empty?()
fd: 
pt: REXML::Text
mt: instance
fn: indent_text
fs: indent_text(string, level=1, style="\t", indentfirstline=true)
fd: 
pt: REXML::Text
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Text
mt: instance
fn: new
fs: new(arg, respect_whitespace=false, parent=nil, raw=nil, entity_filter=nil, illegal=ILLEGAL )
fd: Constructor arg if a String, the content is set to the String. If a Text, the object is shallowly cloned.
pt: REXML::Text
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::Text
mt: instance
fn: normalize
fs: normalize( input, doctype=nil, entity_filter=nil )
fd: Escapes all possible entities
pt: REXML::Text
mt: class
fn: read_with_substitution
fs: read_with_substitution( input, illegal=nil )
fd: Reads text, substituting entities
pt: REXML::Text
mt: class
fn: to_s
fs: to_s()
fd: Returns the string value of this text node. This string is always escaped, meaning that it is a valid XML text node string, and all entities that can be escaped, have been inserted. This method respects the entity filter set in the constructor.
pt: REXML::Text
mt: instance
fn: unnormalize
fs: unnormalize( string, doctype=nil, filter=nil, illegal=nil )
fd: Unescapes all possible entities
pt: REXML::Text
mt: class
fn: value=
fs: value=( val )
fd: Sets the contents of this text node. This expects the text to be unnormalized. It returns self.
pt: REXML::Text
mt: instance
fn: value
fs: value()
fd: Returns the string value of this text. This is the text without entities, as it might be used programmatically, or printed to the console. This ignores the 'raw' attribute setting, and any entity_filter.
pt: REXML::Text
mt: instance
fn: wrap
fs: wrap(string, width, addnewline=false)
fd: 
pt: REXML::Text
mt: instance
fn: write
fs: write( writer, indent=-1, transitive=false, ie_hack=false )
fd: See REXML::Formatters
pt: REXML::Text
mt: instance
fn: write_with_substitution
fs: write_with_substitution(out, input)
fd: Writes out text, substituting special characters beforehand. out A String, IO, or any other object supporting &lt;&lt;( String ) input the text to substitute and the write out
pt: REXML::Text
mt: instance
fn: xpath
fs: xpath()
fd: FIXME This probably won't work properly
pt: REXML::Text
mt: instance
fn: expected
fs: expected()
fd: 
pt: REXML::Validation::Choice
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Validation::Choice
mt: instance
fn: matches?
fs: matches?( event )
fd: 
pt: REXML::Validation::Choice
mt: instance
fn: new
fs: new(context)
fd: 
pt: REXML::Validation::Choice
mt: class
fn: next
fs: next( event )
fd: 
pt: REXML::Validation::Choice
mt: instance
fn: reset
fs: reset()
fd: 
pt: REXML::Validation::Choice
mt: instance
fn: done?
fs: done?()
fd: 
pt: REXML::Validation::Event
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Validation::Event
mt: instance
fn: matches?
fs: matches?( event )
fd: 
pt: REXML::Validation::Event
mt: instance
fn: new
fs: new(event_type, event_arg=nil )
fd: 
pt: REXML::Validation::Event
mt: class
fn: single?
fs: single?()
fd: 
pt: REXML::Validation::Event
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: REXML::Validation::Event
mt: instance
fn: expected
fs: expected()
fd: 
pt: REXML::Validation::Interleave
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Validation::Interleave
mt: instance
fn: matches?
fs: matches?( event )
fd: 
pt: REXML::Validation::Interleave
mt: instance
fn: new
fs: new(context)
fd: 
pt: REXML::Validation::Interleave
mt: class
fn: next
fs: next( event )
fd: 
pt: REXML::Validation::Interleave
mt: instance
fn: next_current
fs: next_current( event )
fd: 
pt: REXML::Validation::Interleave
mt: instance
fn: reset
fs: reset()
fd: 
pt: REXML::Validation::Interleave
mt: instance
fn: expected
fs: expected()
fd: 
pt: REXML::Validation::OneOrMore
mt: instance
fn: matches?
fs: matches?( event )
fd: 
pt: REXML::Validation::OneOrMore
mt: instance
fn: new
fs: new(context)
fd: 
pt: REXML::Validation::OneOrMore
mt: class
fn: next
fs: next( event )
fd: 
pt: REXML::Validation::OneOrMore
mt: instance
fn: reset
fs: reset()
fd: 
pt: REXML::Validation::OneOrMore
mt: instance
fn: expected
fs: expected()
fd: 
pt: REXML::Validation::Optional
mt: instance
fn: matches?
fs: matches?(event)
fd: 
pt: REXML::Validation::Optional
mt: instance
fn: next
fs: next( event )
fd: 
pt: REXML::Validation::Optional
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Validation::Ref
mt: instance
fn: new
fs: new(value)
fd: 
pt: REXML::Validation::Ref
mt: class
fn: to_s
fs: to_s()
fd: 
pt: REXML::Validation::Ref
mt: instance
fn: new
fs: new(source)
fd: "FIXME: Namespaces"
pt: REXML::Validation::RelaxNG
mt: class
fn: receive
fs: receive(event)
fd: 
pt: REXML::Validation::RelaxNG
mt: instance
fn: matches?
fs: matches?(event)
fd: 
pt: REXML::Validation::Sequence
mt: instance
fn: expected
fs: expected()
fd: 
pt: REXML::Validation::State
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::Validation::State
mt: instance
fn: new
fs: new( context )
fd: 
pt: REXML::Validation::State
mt: class
fn: next
fs: next( event )
fd: 
pt: REXML::Validation::State
mt: instance
fn: previous=
fs: previous=( previous )
fd: 
pt: REXML::Validation::State
mt: instance
fn: reset
fs: reset()
fd: 
pt: REXML::Validation::State
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: REXML::Validation::State
mt: instance
fn: new
fs: new(msg)
fd: 
pt: REXML::Validation::ValidationException
mt: class
fn: dump
fs: dump()
fd: 
pt: REXML::Validation::Validator
mt: instance
fn: reset
fs: reset()
fd: 
pt: REXML::Validation::Validator
mt: instance
fn: validate
fs: validate( event )
fd: 
pt: REXML::Validation::Validator
mt: instance
fn: expected
fs: expected()
fd: 
pt: REXML::Validation::ZeroOrMore
mt: instance
fn: next
fs: next( event )
fd: 
pt: REXML::Validation::ZeroOrMore
mt: instance
fn: clone
fs: clone()
fd: 
pt: REXML::XMLDecl
mt: instance
fn: default
fs: default()
fd: Only use this if you do not want the XML declaration to be written; this object is ignored by the XML writer. Otherwise, instantiate your own XMLDecl and add it to the document.
pt: REXML::XMLDecl
mt: class
fn: dowrite
fs: dowrite()
fd: 
pt: REXML::XMLDecl
mt: instance
fn: encoding=
fs: encoding=( enc )
fd: 
pt: REXML::XMLDecl
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: REXML::XMLDecl
mt: instance
fn: new
fs: new(version=DEFAULT_VERSION, encoding=nil, standalone=nil)
fd: 
pt: REXML::XMLDecl
mt: class
fn: node_type
fs: node_type()
fd: 
pt: REXML::XMLDecl
mt: instance
fn: nowrite
fs: nowrite()
fd: 
pt: REXML::XMLDecl
mt: instance
fn: write
fs: write(writer, indent=-1, transitive=false, ie_hack=false)
fd: Ignored. There must be no whitespace before an XML declaration
pt: REXML::XMLDecl
mt: instance
fn: xmldecl
fs: xmldecl(version, encoding, standalone)
fd: 
pt: REXML::XMLDecl
mt: instance
fn: each
fs: each(element, path=nil, namespaces=nil, variables={})
fd: Itterates over nodes that match the given path, calling the supplied block with the match.
pt: REXML::XPath
mt: class
fn: first
fs: first(element, path=nil, namespaces=nil, variables={})
fd: Finds and returns the first node that matches the supplied xpath.
pt: REXML::XPath
mt: class
fn: match
fs: match(element, path=nil, namespaces=nil, variables={})
fd: Returns an array of nodes matching a given XPath.
pt: REXML::XPath
mt: class
fn: first
fs: first( path_stack, node )
fd: Performs a depth-first (document order) XPath search, and returns the first match. This is the fastest, lightest way to return a single result.
pt: REXML::XPathParser
mt: instance
fn: get_first
fs: get_first(path, nodeset)
fd: 
pt: REXML::XPathParser
mt: instance
fn: match
fs: match( path_stack, nodeset )
fd: 
pt: REXML::XPathParser
mt: instance
fn: namespaces=
fs: namespaces=( namespaces={} )
fd: 
pt: REXML::XPathParser
mt: instance
fn: new
fs: new( )
fd: 
pt: REXML::XPathParser
mt: class
fn: parse
fs: parse(path, nodeset)
fd: 
pt: REXML::XPathParser
mt: instance
fn: predicate
fs: predicate(path, nodeset)
fd: 
pt: REXML::XPathParser
mt: instance
fn: variables=
fs: variables=( vars={} )
fd: 
pt: REXML::XPathParser
mt: instance
fn: bold_print
fs: bold_print(txt)
fd: 
pt: RI::AnsiFormatter
mt: instance
fn: display_heading
fs: display_heading(text, level, indent)
fd: 
pt: RI::AnsiFormatter
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RI::AnsiFormatter
mt: class
fn: write_attribute_text
fs: write_attribute_text(prefix, line)
fd: 
pt: RI::AnsiFormatter
mt: instance
fn: new
fs: new(name, rw, comment)
fd: 
pt: RI::Attribute
mt: class
fn: new
fs: new(char, attr)
fd: 
pt: RI::AttributeFormatter::AttrChar
mt: class
fn: empty?
fs: empty?()
fd: 
pt: RI::AttributeFormatter::AttributeString
mt: instance
fn: new
fs: new()
fd: 
pt: RI::AttributeFormatter::AttributeString
mt: class
fn: next_word
fs: next_word()
fd: accept non space, then all following spaces
pt: RI::AttributeFormatter::AttributeString
mt: instance
fn: wrap
fs: wrap(txt, prefix=@indent, linelen=@width)
fd: overrides base class. Looks for ... etc sequences and generates an array of AttrChars. This array is then used as the basis for the split
pt: RI::AttributeFormatter
mt: instance
fn: display_name
fs: display_name()
fd: 
pt: RI::ClassDescription
mt: instance
fn: superclass_string
fs: superclass_string()
fd: 
pt: RI::ClassDescription
mt: instance
fn: add_path
fs: add_path(path)
fd: We found this class in more tha one place, so add in the name from there.
pt: RI::ClassEntry
mt: instance
fn: all_method_names
fs: all_method_names()
fd: Return a list of all out method names
pt: RI::ClassEntry
mt: instance
fn: classes_and_modules
fs: classes_and_modules()
fd: 
pt: RI::ClassEntry
mt: instance
fn: contained_class_named
fs: contained_class_named(name)
fd: Return an exact match to a particular name
pt: RI::ClassEntry
mt: instance
fn: contained_modules_matching
fs: contained_modules_matching(name)
fd: Return a list of any classes or modules that we contain that match a given string
pt: RI::ClassEntry
mt: instance
fn: full_name
fs: full_name()
fd: Return our full name
pt: RI::ClassEntry
mt: instance
fn: load_from
fs: load_from(dir)
fd: read in our methods and any classes and modules in our namespace. Methods are stored in files called name-c|i.yaml, where the 'name' portion is the external form of the method name and the c|i is a class|instance flag
pt: RI::ClassEntry
mt: instance
fn: methods_matching
fs: methods_matching(name, is_class_method)
fd: return the list of local methods matching name We're split into two because we need distinct behavior when called from the toplevel
pt: RI::ClassEntry
mt: instance
fn: new
fs: new(path_name, name, in_class)
fd: 
pt: RI::ClassEntry
mt: class
fn: recursively_find_methods_matching
fs: recursively_find_methods_matching(name, is_class_method)
fd: Find methods matching 'name' in ourselves and in any classes we contain
pt: RI::ClassEntry
mt: instance
fn: new
fs: new(name, value, comment)
fd: 
pt: RI::Constant
mt: class
fn: deserialize
fs: deserialize(from)
fd: 
pt: RI::Description
mt: class
fn: serialize
fs: serialize()
fd: 
pt: RI::Description
mt: instance
fn: blankline
fs: blankline()
fd: 
pt: RI::HtmlFormatter
mt: instance
fn: bold_print
fs: bold_print(txt)
fd: 
pt: RI::HtmlFormatter
mt: instance
fn: break_to_newline
fs: break_to_newline()
fd: 
pt: RI::HtmlFormatter
mt: instance
fn: display_heading
fs: display_heading(text, level, indent)
fd: 
pt: RI::HtmlFormatter
mt: instance
fn: display_list
fs: display_list(list)
fd: 
pt: RI::HtmlFormatter
mt: instance
fn: display_verbatim_flow_item
fs: display_verbatim_flow_item(item, prefix=@indent)
fd: 
pt: RI::HtmlFormatter
mt: instance
fn: draw_line
fs: draw_line(label=nil)
fd: 
pt: RI::HtmlFormatter
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RI::HtmlFormatter
mt: class
fn: write_attribute_text
fs: write_attribute_text(prefix, line)
fd: 
pt: RI::HtmlFormatter
mt: instance
fn: full_name
fs: full_name()
fd: 
pt: RI::MethodEntry
mt: instance
fn: new
fs: new(path_name, name, is_class_method, in_class)
fd: 
pt: RI::MethodEntry
mt: class
fn: new
fs: new(name="")
fd: 
pt: RI::MethodSummary
mt: class
fn: display_name
fs: display_name()
fd: 
pt: RI::ModuleDescription
mt: instance
fn: merge_in
fs: merge_in(old)
fd: merge in another class desscription into this one
pt: RI::ModuleDescription
mt: instance
fn: superclass_string
fs: superclass_string()
fd: the 'ClassDescription' subclass overrides this to format up the name of a parent
pt: RI::ModuleDescription
mt: instance
fn: eql?
fs: eql?(other)
fd: 
pt: RI::NamedThing
mt: instance
fn: hash
fs: hash()
fd: 
pt: RI::NamedThing
mt: instance
fn: new
fs: new(name)
fd: 
pt: RI::NamedThing
mt: class
fn: displayer
fs: displayer()
fd: Return an instance of the displayer (the thing that actually writes the information). This allows us to load in new displayer classes at runtime (for example to help with IDE integration)
pt: RI::Options
mt: instance
fn: new
fs: new()
fd: 
pt: RI::Options
mt: class
fn: error
fs: error(msg)
fd: Show an error and exit
pt: RI::Options::OptionList
mt: class
fn: options
fs: options()
fd: 
pt: RI::Options::OptionList
mt: class
fn: strip_output
fs: strip_output(text)
fd: 
pt: RI::Options::OptionList
mt: class
fn: usage
fs: usage(short_form=false)
fd: Show usage and exit
pt: RI::Options::OptionList
mt: class
fn: parse
fs: parse(args)
fd: Parse command line options.
pt: RI::Options
mt: instance
fn: path
fs: path()
fd: Return the selected documentation directories.
pt: RI::Options
mt: instance
fn: raw_path
fs: raw_path()
fd: 
pt: RI::Options
mt: instance
fn: show_version
fs: show_version()
fd: Show the version and exit
pt: RI::Options
mt: instance
fn: bold_print
fs: bold_print(text)
fd: draw a string in bold
pt: RI::OverstrikeFormatter
mt: instance
fn: write_attribute_text
fs: write_attribute_text(prefix, line)
fd: 
pt: RI::OverstrikeFormatter
mt: instance
fn: new
fs: new(dirs)
fd: 
pt: RI::RiCache
mt: class
fn: all_names
fs: all_names()
fd: return a list of all classes, modules, and methods
pt: RI::RiReader
mt: instance
fn: find_class_by_name
fs: find_class_by_name(full_name)
fd: 
pt: RI::RiReader
mt: instance
fn: find_methods
fs: find_methods(name, is_class_method, namespaces)
fd: 
pt: RI::RiReader
mt: instance
fn: full_class_names
fs: full_class_names()
fd: return the names of all classes and modules
pt: RI::RiReader
mt: instance
fn: get_class
fs: get_class(class_entry)
fd: Return a class description
pt: RI::RiReader
mt: instance
fn: get_method
fs: get_method(method_entry)
fd: return the MethodDescription for a given MethodEntry by deserializing the YAML
pt: RI::RiReader
mt: instance
fn: lookup_namespace_in
fs: lookup_namespace_in(target, namespaces)
fd: 
pt: RI::RiReader
mt: instance
fn: new
fs: new(ri_cache)
fd: 
pt: RI::RiReader
mt: class
fn: top_level_namespace
fs: top_level_namespace()
fd: 
pt: RI::RiReader
mt: instance
fn: add_class
fs: add_class(class_desc)
fd: 
pt: RI::RiWriter
mt: instance
fn: add_method
fs: add_method(class_desc, method_desc)
fd: 
pt: RI::RiWriter
mt: instance
fn: class_desc_path
fs: class_desc_path(dir, class_desc)
fd: 
pt: RI::RiWriter
mt: class
fn: external_to_internal
fs: external_to_internal(name)
fd: And the reverse operation
pt: RI::RiWriter
mt: class
fn: internal_to_external
fs: internal_to_external(name)
fd: Convert a name from internal form (containing punctuation) to an external form (where punctuation is replaced by %xx)
pt: RI::RiWriter
mt: class
fn: new
fs: new(base_dir)
fd: 
pt: RI::RiWriter
mt: class
fn: remove_class
fs: remove_class(class_desc)
fd: 
pt: RI::RiWriter
mt: instance
fn: blankline
fs: blankline()
fd: No extra blank lines
pt: RI::SimpleFormatter
mt: instance
fn: display_heading
fs: display_heading(text, level, indent)
fd: Place heading level indicators inline with heading.
pt: RI::SimpleFormatter
mt: instance
fn: draw_line
fs: draw_line(label=nil)
fd: Display labels only, no lines
pt: RI::SimpleFormatter
mt: instance
fn: blankline
fs: blankline()
fd: 
pt: RI::TextFormatter
mt: instance
fn: bold_print
fs: bold_print(txt)
fd: 
pt: RI::TextFormatter
mt: instance
fn: break_to_newline
fs: break_to_newline()
fd: called when we want to ensure a nbew 'wrap' starts on a newline Only needed for HtmlFormatter, because the rest do their own line breaking
pt: RI::TextFormatter
mt: instance
fn: conv_html
fs: conv_html(txt)
fd: convert HTML entities back to ASCII
pt: RI::TextFormatter
mt: instance
fn: conv_markup
fs: conv_markup(txt)
fd: convert markup into display form
pt: RI::TextFormatter
mt: instance
fn: display_flow
fs: display_flow(flow)
fd: 
pt: RI::TextFormatter
mt: instance
fn: display_flow_item
fs: display_flow_item(item, prefix=@indent)
fd: 
pt: RI::TextFormatter
mt: instance
fn: display_heading
fs: display_heading(text, level, indent)
fd: 
pt: RI::TextFormatter
mt: instance
fn: display_list
fs: display_list(list)
fd: 
pt: RI::TextFormatter
mt: instance
fn: display_verbatim_flow_item
fs: display_verbatim_flow_item(item, prefix=@indent)
fd: 
pt: RI::TextFormatter
mt: instance
fn: draw_line
fs: draw_line(label=nil)
fd: 
pt: RI::TextFormatter
mt: instance
fn: for
fs: for(name)
fd: 
pt: RI::TextFormatter
mt: class
fn: list
fs: list()
fd: 
pt: RI::TextFormatter
mt: class
fn: new
fs: new(options, indent)
fd: 
pt: RI::TextFormatter
mt: class
fn: raw_print_line
fs: raw_print_line(txt)
fd: 
pt: RI::TextFormatter
mt: instance
fn: strip_attributes
fs: strip_attributes(txt)
fd: 
pt: RI::TextFormatter
mt: instance
fn: wrap
fs: wrap(txt, prefix=@indent, linelen=@width)
fd: 
pt: RI::TextFormatter
mt: instance
fn: full_name
fs: full_name()
fd: 
pt: RI::TopLevelEntry
mt: instance
fn: methods_matching
fs: methods_matching(name, is_class_method)
fd: 
pt: RI::TopLevelEntry
mt: instance
fn: module_named
fs: module_named(name)
fd: 
pt: RI::TopLevelEntry
mt: instance
fn: append_features
fs: append_features(display_class)
fd: 
pt: RiDisplay
mt: class
fn: new
fs: new(*args)
fd: 
pt: RiDisplay
mt: class
fn: get_info_for
fs: get_info_for(arg)
fd: 
pt: RiDriver
mt: instance
fn: new
fs: new()
fd: 
pt: RiDriver
mt: class
fn: process_args
fs: process_args()
fd: 
pt: RiDriver
mt: instance
fn: report_class_stuff
fs: report_class_stuff(namespaces)
fd: 
pt: RiDriver
mt: instance
fn: report_method_stuff
fs: report_method_stuff(requested_method_name, methods)
fd: If the list of matching methods contains exactly one entry, or if it contains an entry that exactly matches the requested method, then display that entry, otherwise display the list of matching method names
pt: RiDriver
mt: instance
fn: report_missing_documentation
fs: report_missing_documentation(path)
fd: Couldn't find documentation in path, so tell the user what to do
pt: RiDriver
mt: instance
fn: new
fs: new(uri=nil, ref=nil)
fd: Creates a new DRbObjectTemplate that will match against uri and ref.
pt: Rinda::DRbObjectTemplate
mt: class
fn: each
fs: each( {|event, tuple| ...}
fd: Yields event/tuple pairs until this NotifyTemplateEntry expires.
pt: Rinda::NotifyTemplateEntry
mt: instance
fn: new
fs: new(place, event, tuple, expires=nil)
fd: Creates a new NotifyTemplateEntry that watches place for +event+s that match tuple.
pt: Rinda::NotifyTemplateEntry
mt: class
fn: notify
fs: notify(ev)
fd: Called by TupleSpace to notify this NotifyTemplateEntry of a new event.
pt: Rinda::NotifyTemplateEntry
mt: instance
fn: pop
fs: pop()
fd: Retrieves a notification. Raises RequestExpiredError when this NotifyTemplateEntry expires.
pt: Rinda::NotifyTemplateEntry
mt: instance
fn: each
fs: each()
fd: Iterates over all discovered TupleSpaces starting with the primary.
pt: Rinda::RingFinger
mt: instance
fn: finger
fs: finger()
fd: Creates a singleton RingFinger and looks for a RingServer. Returns the created RingFinger.
pt: Rinda::RingFinger
mt: class
fn: lookup_ring
fs: lookup_ring(timeout=5, &block)
fd: Looks up RingServers waiting timeout seconds. RingServers will be given block as a callback, which will be called with the remote TupleSpace.
pt: Rinda::RingFinger
mt: instance
fn: lookup_ring_any
fs: lookup_ring_any(timeout=5)
fd: Returns the first found remote TupleSpace. Any further recovered TupleSpaces can be found by calling to_a.
pt: Rinda::RingFinger
mt: instance
fn: new
fs: new(broadcast_list=@@broadcast_list, port=Ring_PORT)
fd: Creates a new RingFinger that will look for RingServers at port on the addresses in broadcast_list.
pt: Rinda::RingFinger
mt: class
fn: primary
fs: primary()
fd: Returns the first advertised TupleSpace.
pt: Rinda::RingFinger
mt: class
fn: to_a
fs: to_a()
fd: Contains all discoverd TupleSpaces except for the primary.
pt: Rinda::RingFinger
mt: class
fn: to_a
fs: to_a()
fd: Contains all discovered TupleSpaces except for the primary.
pt: Rinda::RingFinger
mt: instance
fn: new
fs: new(klass, front, desc, renewer = nil)
fd: Creates a RingProvider that will provide a klass service running on front, with a description. renewer is optional.
pt: Rinda::RingProvider
mt: class
fn: provide
fs: provide()
fd: Advertises this service on the primary remote TupleSpace.
pt: Rinda::RingProvider
mt: instance
fn: do_reply
fs: do_reply()
fd: Pulls lookup tuples out of the TupleSpace and sends their DRb object the address of the local TupleSpace.
pt: Rinda::RingServer
mt: instance
fn: do_write
fs: do_write(msg)
fd: Extracts the response URI from msg and adds it to TupleSpace where it will be picked up by reply_service for notification.
pt: Rinda::RingServer
mt: instance
fn: new
fs: new(ts, port=Ring_PORT)
fd: Advertises ts on the UDP broadcast address at port.
pt: Rinda::RingServer
mt: class
fn: reply_service
fs: reply_service()
fd: Creates a thread that notifies waiting clients from the TupleSpace.
pt: Rinda::RingServer
mt: instance
fn: write_service
fs: write_service()
fd: Creates a thread that picks up UDP packets and passes them to do_write for decoding.
pt: Rinda::RingServer
mt: instance
fn: new
fs: new(sec=180)
fd: Creates a new SimpleRenewer that keeps an object alive for another sec seconds.
pt: Rinda::SimpleRenewer
mt: class
fn: renew
fs: renew()
fd: Called by the TupleSpace to check if the object is still alive.
pt: Rinda::SimpleRenewer
mt: instance
fn: match
fs: match(tuple)
fd: "Matches this template against tuple. The tuple must be the same size as the template. An element with a nil value in a template acts as a wildcard, matching any value in the corresponding position in the tuple. Elements of the template match the tuple if the are #== or #===."
pt: Rinda::Template
mt: instance
fn: match
fs: match(tuple)
fd: Matches this TemplateEntry against tuple. See Template#match for details on how a Template matches a Tuple.
pt: Rinda::TemplateEntry
mt: instance
fn: each
fs: each( {|k, v| ...}
fd: Iterate through the tuple, yielding the index or key, and the value, thus ensuring arrays are iterated similarly to hashes.
pt: Rinda::Tuple
mt: instance
fn: fetch
fs: fetch(k)
fd: Fetches item k from the tuple.
pt: Rinda::Tuple
mt: instance
fn: new
fs: new(ary_or_hash)
fd: Creates a new Tuple from ary_or_hash which must be an Array or Hash.
pt: Rinda::Tuple
mt: class
fn: size
fs: size()
fd: The number of elements in the tuple.
pt: Rinda::Tuple
mt: instance
fn: value
fs: value()
fd: Return the tuple itself
pt: Rinda::Tuple
mt: instance
fn: delete
fs: delete(ary)
fd: Removes ary from the TupleBag.
pt: Rinda::TupleBag
mt: instance
fn: delete_unless_alive
fs: delete_unless_alive()
fd: Delete tuples which dead tuples from the TupleBag, returning the deleted tuples.
pt: Rinda::TupleBag
mt: instance
fn: find
fs: find(template)
fd: Finds a live tuple that matches template.
pt: Rinda::TupleBag
mt: instance
fn: find_all
fs: find_all(template)
fd: Finds all live tuples that match template.
pt: Rinda::TupleBag
mt: instance
fn: find_all_template
fs: find_all_template(tuple)
fd: Finds all tuples in the TupleBag which when treated as templates, match tuple and are alive.
pt: Rinda::TupleBag
mt: instance
fn: has_expires?
fs: has_expires?()
fd: true if the TupleBag to see if it has any expired entries.
pt: Rinda::TupleBag
mt: instance
fn: push
fs: push(ary)
fd: Add ary to the TupleBag.
pt: Rinda::TupleBag
mt: instance
fn: alive?
fs: alive?()
fd: A TupleEntry is dead when it is canceled or expired.
pt: Rinda::TupleEntry
mt: instance
fn: cancel
fs: cancel()
fd: Marks this TupleEntry as canceled.
pt: Rinda::TupleEntry
mt: instance
fn: canceled?
fs: canceled?()
fd: Returns the canceled status.
pt: Rinda::TupleEntry
mt: instance
fn: expired?
fs: expired?()
fd: Has this tuple expired? (true/false).
pt: Rinda::TupleEntry
mt: instance
fn: fetch
fs: fetch(key)
fd: Fetches key from the tuple.
pt: Rinda::TupleEntry
mt: instance
fn: make_expires
fs: make_expires(sec=nil)
fd: "Returns an expiry Time based on sec which can be one of:"
pt: Rinda::TupleEntry
mt: instance
fn: make_tuple
fs: make_tuple(ary)
fd: Creates a Rinda::Tuple for ary.
pt: Rinda::TupleEntry
mt: instance
fn: new
fs: new(ary, sec=nil)
fd: Creates a TupleEntry based on ary with an optional renewer or expiry time sec.
pt: Rinda::TupleEntry
mt: class
fn: renew
fs: renew(sec_or_renewer)
fd: Reset the expiry time according to sec_or_renewer.
pt: Rinda::TupleEntry
mt: instance
fn: size
fs: size()
fd: The size of the tuple.
pt: Rinda::TupleEntry
mt: instance
fn: value
fs: value()
fd: "Return the object which makes up the tuple itself: the Array or Hash."
pt: Rinda::TupleEntry
mt: instance
fn: move
fs: move(port, tuple, sec=nil)
fd: Moves tuple to port.
pt: Rinda::TupleSpace
mt: instance
fn: new
fs: new(period=60)
fd: Creates a new TupleSpace. period is used to control how often to look for dead tuples after modifications to the TupleSpace.
pt: Rinda::TupleSpace
mt: class
fn: notify
fs: notify(event, tuple, sec=nil)
fd: Registers for notifications of event. Returns a NotifyTemplateEntry. See NotifyTemplateEntry for examples of how to listen for notifications.
pt: Rinda::TupleSpace
mt: instance
fn: read
fs: read(tuple, sec=nil)
fd: Reads tuple, but does not remove it.
pt: Rinda::TupleSpace
mt: instance
fn: read_all
fs: read_all(tuple)
fd: Returns all tuples matching tuple. Does not remove the found tuples.
pt: Rinda::TupleSpace
mt: instance
fn: take
fs: take(tuple, sec=nil, &block)
fd: Removes tuple
pt: Rinda::TupleSpace
mt: instance
fn: write
fs: write(tuple, sec=nil)
fd: Adds tuple
pt: Rinda::TupleSpace
mt: instance
fn: new
fs: new(ts)
fd: Creates a new TupleSpaceProxy to wrap ts.
pt: Rinda::TupleSpaceProxy
mt: class
fn: notify
fs: notify(ev, tuple, sec=nil)
fd: Registers for notifications of event ev on the proxied TupleSpace. See TupleSpace#notify
pt: Rinda::TupleSpaceProxy
mt: instance
fn: read
fs: read(tuple, sec=nil, &block)
fd: Reads tuple from the proxied TupleSpace. See TupleSpace#read.
pt: Rinda::TupleSpaceProxy
mt: instance
fn: read_all
fs: read_all(tuple)
fd: Reads all tuples matching tuple from the proxied TupleSpace. See TupleSpace#read_all.
pt: Rinda::TupleSpaceProxy
mt: instance
fn: take
fs: take(tuple, sec=nil, &block)
fd: Takes tuple from the proxied TupleSpace. See TupleSpace#take.
pt: Rinda::TupleSpaceProxy
mt: instance
fn: write
fs: write(tuple, sec=nil)
fd: Adds tuple to the proxied TupleSpace. See TupleSpace#write.
pt: Rinda::TupleSpaceProxy
mt: instance
fn: cancel
fs: cancel()
fd: 
pt: Rinda::WaitTemplateEntry
mt: instance
fn: new
fs: new(place, ary, expires=nil)
fd: 
pt: Rinda::WaitTemplateEntry
mt: class
fn: read
fs: read(tuple)
fd: 
pt: Rinda::WaitTemplateEntry
mt: instance
fn: signal
fs: signal()
fd: 
pt: Rinda::WaitTemplateEntry
mt: instance
fn: wait
fs: wait()
fd: 
pt: Rinda::WaitTemplateEntry
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::BaseDublinCoreModel
mt: instance
fn: available_tags
fs: available_tags(uri)
fd: return the tag_names for setters associated with uri
pt: RSS::BaseListener
mt: class
fn: class_name
fs: class_name(uri, tag_name)
fd: retrieve class_name for the supplied uri and tag_name If it doesn't exist, capitalize the tag_name
pt: RSS::BaseListener
mt: class
fn: install_class_name
fs: install_class_name(uri, tag_name, class_name)
fd: record class_name for the supplied uri and tag_name
pt: RSS::BaseListener
mt: class
fn: install_get_text_element
fs: install_get_text_element(uri, name, setter)
fd: 
pt: RSS::BaseListener
mt: class
fn: raise_for_undefined_entity?
fs: raise_for_undefined_entity?()
fd: 
pt: RSS::BaseListener
mt: class
fn: register_uri
fs: register_uri(uri, name)
fd: register uri against this name.
pt: RSS::BaseListener
mt: class
fn: setter
fs: setter(uri, tag_name)
fd: return the setter for the uri, tag_name pair, or nil.
pt: RSS::BaseListener
mt: class
fn: uri_registered?
fs: uri_registered?(uri, name)
fd: test if this uri is registered against this name
pt: RSS::BaseListener
mt: class
fn: install_date_element
fs: install_date_element(tag_name, uri, occurs, name=nil, type=nil, disp_name=nil)
fd: 
pt: RSS::BaseModel
mt: instance
fn: install_have_attribute_element
fs: install_have_attribute_element(tag_name, uri, occurs, name=nil)
fd: "Alias for #install_have_child_element"
pt: RSS::BaseModel
mt: instance
fn: install_have_child_element
fs: install_have_child_element(tag_name, uri, occurs, name=nil)
fd: 
pt: RSS::BaseModel
mt: instance
fn: install_have_children_element
fs: install_have_children_element(tag_name, uri, occurs, name=nil, plural_name=nil)
fd: 
pt: RSS::BaseModel
mt: instance
fn: install_text_element
fs: install_text_element(tag_name, uri, occurs, name=nil, type=nil, disp_name=nil)
fd: 
pt: RSS::BaseModel
mt: instance
fn: do_validate=
fs: do_validate=(new_value)
fd: 
pt: RSS::BaseParser
mt: instance
fn: do_validate
fs: do_validate()
fd: 
pt: RSS::BaseParser
mt: instance
fn: ignore_unknown_element=
fs: ignore_unknown_element=(new_value)
fd: 
pt: RSS::BaseParser
mt: instance
fn: ignore_unknown_element
fs: ignore_unknown_element()
fd: 
pt: RSS::BaseParser
mt: instance
fn: new
fs: new(rss)
fd: 
pt: RSS::BaseParser
mt: class
fn: parse
fs: parse()
fd: 
pt: RSS::BaseParser
mt: instance
fn: raise_for_undefined_entity?
fs: raise_for_undefined_entity?()
fd: 
pt: RSS::BaseParser
mt: class
fn: rss
fs: rss()
fd: 
pt: RSS::BaseParser
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::BaseTrackBackModel
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::ContentModel
mt: class
fn: new
fs: new(string, to, from)
fd: 
pt: RSS::ConversionError
mt: class
fn: convert
fs: convert(value)
fd: 
pt: RSS::Converter
mt: instance
fn: def_convert
fs: def_convert(depth=0)
fd: 
pt: RSS::Converter
mt: instance
fn: def_else_enc
fs: def_else_enc(to_enc, from_enc)
fd: 
pt: RSS::Converter
mt: instance
fn: def_iconv_convert
fs: def_iconv_convert(to_enc, from_enc, depth=0)
fd: 
pt: RSS::Converter
mt: instance
fn: def_same_enc
fs: def_same_enc()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_euc_jp_from_iso_2022_jp
fs: def_to_euc_jp_from_iso_2022_jp()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_euc_jp_from_shift_jis
fs: def_to_euc_jp_from_shift_jis()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_euc_jp_from_utf_8
fs: def_to_euc_jp_from_utf_8()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_iso_2022_jp_from_euc_jp
fs: def_to_iso_2022_jp_from_euc_jp()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_iso_8859_1_from_utf_8
fs: def_to_iso_8859_1_from_utf_8()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_shift_jis_from_euc_jp
fs: def_to_shift_jis_from_euc_jp()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_shift_jis_from_utf_8
fs: def_to_shift_jis_from_utf_8()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_utf_8_from_euc_jp
fs: def_to_utf_8_from_euc_jp()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_utf_8_from_iso_8859_1
fs: def_to_utf_8_from_iso_8859_1()
fd: 
pt: RSS::Converter
mt: instance
fn: def_to_utf_8_from_shift_jis
fs: def_to_utf_8_from_shift_jis()
fd: 
pt: RSS::Converter
mt: instance
fn: def_uconv_convert_if_can
fs: def_uconv_convert_if_can(meth, to_enc, from_enc, nkf_arg)
fd: 
pt: RSS::Converter
mt: instance
fn: new
fs: new(to_enc, from_enc=nil)
fd: 
pt: RSS::Converter
mt: class
fn: convert
fs: convert(value)
fd: 
pt: RSS::Element
mt: instance
fn: converter=
fs: converter=(converter)
fd: 
pt: RSS::Element
mt: instance
fn: full_name
fs: full_name()
fd: 
pt: RSS::Element
mt: instance
fn: get_attributes
fs: get_attributes()
fd: 
pt: RSS::Element
mt: class
fn: have_children_elements
fs: have_children_elements()
fd: 
pt: RSS::Element
mt: class
fn: inherited
fs: inherited(klass)
fd: 
pt: RSS::Element
mt: class
fn: install_ns
fs: install_ns(prefix, uri)
fd: 
pt: RSS::Element
mt: class
fn: models
fs: models()
fd: 
pt: RSS::Element
mt: class
fn: must_call_validators
fs: must_call_validators()
fd: 
pt: RSS::Element
mt: class
fn: need_initialize_variables
fs: need_initialize_variables()
fd: 
pt: RSS::Element
mt: class
fn: new
fs: new(do_validate=true, attrs={})
fd: 
pt: RSS::Element
mt: class
fn: plural_forms
fs: plural_forms()
fd: 
pt: RSS::Element
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::Element
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::Element
mt: class
fn: setup_maker
fs: setup_maker(maker)
fd: 
pt: RSS::Element
mt: instance
fn: tag_name
fs: tag_name()
fd: 
pt: RSS::Element
mt: class
fn: tag_name
fs: tag_name()
fd: 
pt: RSS::Element
mt: instance
fn: to_element_methods
fs: to_element_methods()
fd: 
pt: RSS::Element
mt: class
fn: to_s
fs: to_s(need_convert=true, indent='')
fd: 
pt: RSS::Element
mt: instance
fn: validate
fs: validate(ignore_unknown_element=true)
fd: 
pt: RSS::Element
mt: instance
fn: validate_for_stream
fs: validate_for_stream(tags, ignore_unknown_element=true)
fd: 
pt: RSS::Element
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::ImageFaviconModel
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::ImageFaviconModel::ImageFavicon
mt: instance
fn: image_size=
fs: image_size=(new_value)
fd: "Alias for #size="
pt: RSS::ImageFaviconModel::ImageFavicon
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::ImageFaviconModel::ImageFavicon
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::ImageFaviconModel::ImageFavicon
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::ImageFaviconModel::ImageFavicon
mt: class
fn: size=
fs: size=(new_value)
fd: 
pt: RSS::ImageFaviconModel::ImageFavicon
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::ImageItemModel
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::ImageItemModel::ImageItem
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::ImageItemModel::ImageItem
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::ImageItemModel::ImageItem
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::ImageItemModel::ImageItem
mt: class
fn: validate_one_tag_name
fs: validate_one_tag_name(ignore_unknown_element, name, tags)
fd: 
pt: RSS::ImageModelUtils
mt: instance
fn: instruction
fs: instruction(name, content)
fd: 
pt: RSS::ListenerMixin
mt: instance
fn: new
fs: new()
fd: 
pt: RSS::ListenerMixin
mt: class
fn: tag_end
fs: tag_end(name)
fd: 
pt: RSS::ListenerMixin
mt: instance
fn: tag_start
fs: tag_start(name, attributes)
fd: 
pt: RSS::ListenerMixin
mt: instance
fn: text
fs: text(data)
fd: 
pt: RSS::ListenerMixin
mt: instance
fn: xmldecl
fs: xmldecl(version, encoding, standalone)
fd: set instance vars for version, encoding, standalone
pt: RSS::ListenerMixin
mt: instance
fn: add_maker
fs: add_maker(version, maker)
fd: 
pt: RSS::Maker
mt: class
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::Base
mt: class
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::Base
mt: instance
fn: new
fs: new(maker)
fd: 
pt: RSS::Maker::Base
mt: class
fn: new_category
fs: new_category()
fd: 
pt: RSS::Maker::ChannelBase::CategoriesBase
mt: instance
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ChannelBase::CloudBase
mt: instance
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ChannelBase
mt: instance
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ChannelBase::SkipDaysBase
mt: instance
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ChannelBase::SkipDaysBase::DayBase
mt: instance
fn: new_day
fs: new_day()
fd: 
pt: RSS::Maker::ChannelBase::SkipDaysBase
mt: instance
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ChannelBase::SkipHoursBase
mt: instance
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ChannelBase::SkipHoursBase::HourBase
mt: instance
fn: new_hour
fs: new_hour()
fd: 
pt: RSS::Maker::ChannelBase::SkipHoursBase
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::ContentModel
mt: class
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::DublinCoreModel
mt: class
fn: install_dublin_core
fs: install_dublin_core(klass)
fd: 
pt: RSS::Maker::DublinCoreModel
mt: class
fn: filename_to_version
fs: filename_to_version(filename)
fd: 
pt: RSS::Maker
mt: class
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ImageBase
mt: instance
fn: link
fs: link()
fd: 
pt: RSS::Maker::ImageBase
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::ImageFaviconModel
mt: class
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::ImageFaviconModel::ImageFaviconBase
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::ImageItemModel
mt: class
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::ImageItemModel::ImageItemBase
mt: instance
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ItemsBase
mt: instance
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::ItemsBase::ItemBase
mt: instance
fn: new
fs: new(maker)
fd: 
pt: RSS::Maker::ItemsBase
mt: class
fn: new_item
fs: new_item()
fd: 
pt: RSS::Maker::ItemsBase
mt: instance
fn: normalize
fs: normalize()
fd: 
pt: RSS::Maker::ItemsBase
mt: instance
fn: make
fs: make(version, &block)
fd: 
pt: RSS::Maker
mt: class
fn: maker
fs: maker(version)
fd: 
pt: RSS::Maker
mt: class
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Channel::Categories
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Channel::Cloud
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS09::Channel
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Channel::ImageFavicon
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS09::Channel::SkipDays::Day
mt: instance
fn: to_rss
fs: to_rss(rss, days)
fd: 
pt: RSS::Maker::RSS09::Channel::SkipDays::Day
mt: instance
fn: to_rss
fs: to_rss(rss, channel)
fd: 
pt: RSS::Maker::RSS09::Channel::SkipDays
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS09::Channel::SkipHours::Hour
mt: instance
fn: to_rss
fs: to_rss(rss, hours)
fd: 
pt: RSS::Maker::RSS09::Channel::SkipHours::Hour
mt: instance
fn: to_rss
fs: to_rss(rss, channel)
fd: 
pt: RSS::Maker::RSS09::Channel::SkipHours
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS09::Channel
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS09::Image
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS09::Image
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Items::Item::Categories
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Items::Item::Enclosure
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Items::Item::Guid
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Items::Item::ImageItem
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Items::Item::Source
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS09::Items::Item
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS09::Items::Item::TrackBackAbouts
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS09::Items
mt: instance
fn: new
fs: new(rss_version="0.91")
fd: 
pt: RSS::Maker::RSS09
mt: class
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS09::Textinput
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS10::Channel::Categories
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS10::Channel::Cloud
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS10::Channel
mt: instance
fn: to_rss
fs: to_rss(rss, current)
fd: 
pt: RSS::Maker::RSS10::Channel::ImageFavicon
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS10::Channel::SkipDays
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS10::Channel::SkipHours
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS10::Channel
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS10::Image
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS10::Image
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS10::Items::Item::Categories
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS10::Items::Item::Enclosure
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS10::Items::Item::Guid
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS10::Items::Item
mt: instance
fn: to_rss
fs: to_rss(rss, current)
fd: 
pt: RSS::Maker::RSS10::Items::Item::ImageItem
mt: instance
fn: to_rss
fs: to_rss(*args)
fd: 
pt: RSS::Maker::RSS10::Items::Item::Source
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS10::Items::Item
mt: instance
fn: to_rss
fs: to_rss(rss, current)
fd: 
pt: RSS::Maker::RSS10::Items::Item::TrackBackAbouts::TrackBackAbout
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS10::Items
mt: instance
fn: new
fs: new()
fd: 
pt: RSS::Maker::RSS10
mt: class
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS10::Textinput
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::RSS10::Textinput
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS20::Channel::Categories::Category
mt: instance
fn: to_rss
fs: to_rss(rss, channel)
fd: 
pt: RSS::Maker::RSS20::Channel::Categories::Category
mt: instance
fn: to_rss
fs: to_rss(rss, channel)
fd: 
pt: RSS::Maker::RSS20::Channel::Categories
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS20::Channel::Cloud
mt: instance
fn: to_rss
fs: to_rss(rss, channel)
fd: 
pt: RSS::Maker::RSS20::Channel::Cloud
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS20::Channel
mt: instance
fn: required_variable_names
fs: required_variable_names()
fd: 
pt: RSS::Maker::RSS20::Channel
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS20::Items::Item::Categories::Category
mt: instance
fn: to_rss
fs: to_rss(rss, item)
fd: 
pt: RSS::Maker::RSS20::Items::Item::Categories::Category
mt: instance
fn: to_rss
fs: to_rss(rss, item)
fd: 
pt: RSS::Maker::RSS20::Items::Item::Categories
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS20::Items::Item::Enclosure
mt: instance
fn: to_rss
fs: to_rss(rss, item)
fd: 
pt: RSS::Maker::RSS20::Items::Item::Enclosure
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS20::Items::Item::Guid
mt: instance
fn: to_rss
fs: to_rss(rss, item)
fd: 
pt: RSS::Maker::RSS20::Items::Item::Guid
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS20::Items::Item
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::RSS20::Items::Item::Source
mt: instance
fn: to_rss
fs: to_rss(rss, item)
fd: 
pt: RSS::Maker::RSS20::Items::Item::Source
mt: instance
fn: to_rss
fs: to_rss(rss, current)
fd: 
pt: RSS::Maker::RSS20::Items::Item::TrackBackAbouts::TrackBackAbout
mt: instance
fn: new
fs: new(rss_version="2.0")
fd: 
pt: RSS::Maker::RSS20
mt: class
fn: make
fs: make(&block)
fd: 
pt: RSS::Maker::RSSBase
mt: class
fn: make
fs: make()
fd: 
pt: RSS::Maker::RSSBase
mt: instance
fn: new
fs: new(rss_version)
fd: 
pt: RSS::Maker::RSSBase
mt: class
fn: to_rss
fs: to_rss()
fd: 
pt: RSS::Maker::RSSBase
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::SyndicationModel
mt: class
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::TaxonomyTopicModel
mt: class
fn: install_taxo_topic
fs: install_taxo_topic(klass)
fd: 
pt: RSS::Maker::TaxonomyTopicModel
mt: class
fn: new_taxo_topic
fs: new_taxo_topic()
fd: 
pt: RSS::Maker::TaxonomyTopicModel::TaxonomyTopicsBase
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::TaxonomyTopicModel::TaxonomyTopicsBase::TaxonomyTopicBase
mt: instance
fn: to_rss
fs: to_rss(rss, current)
fd: 
pt: RSS::Maker::TaxonomyTopicModel::TaxonomyTopicsBase
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::TaxonomyTopicsModel
mt: class
fn: install_taxo_topics
fs: install_taxo_topics(klass)
fd: 
pt: RSS::Maker::TaxonomyTopicsModel
mt: class
fn: current_element
fs: current_element(rss)
fd: 
pt: RSS::Maker::TextinputBase
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::Maker::TrackBackModel
mt: class
fn: new_about
fs: new_about()
fd: 
pt: RSS::Maker::TrackBackModel::TrackBackAboutsBase
mt: instance
fn: to_rss
fs: to_rss(rss, current)
fd: 
pt: RSS::Maker::TrackBackModel::TrackBackAboutsBase
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::TrackBackModel::TrackBackAboutsBase::TrackBackAboutBase
mt: instance
fn: new_xml_stylesheet
fs: new_xml_stylesheet()
fd: 
pt: RSS::Maker::XMLStyleSheets
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::XMLStyleSheets
mt: instance
fn: have_required_values?
fs: have_required_values?()
fd: 
pt: RSS::Maker::XMLStyleSheets::XMLStyleSheet
mt: instance
fn: to_rss
fs: to_rss(rss)
fd: 
pt: RSS::Maker::XMLStyleSheets::XMLStyleSheet
mt: instance
fn: new
fs: new(tag, attribute)
fd: 
pt: RSS::MissingAttributeError
mt: class
fn: new
fs: new(tag, parent)
fd: 
pt: RSS::MissingTagError
mt: class
fn: new
fs: new(tag, value, attribute=nil)
fd: 
pt: RSS::NotAvailableValueError
mt: class
fn: new
fs: new(tag, uri, parent)
fd: 
pt: RSS::NotExpectedTagError
mt: class
fn: new
fs: new(name, variables)
fd: 
pt: RSS::NotSetError
mt: class
fn: new
fs: new(parser)
fd: 
pt: RSS::NotValidXMLParser
mt: class
fn: new
fs: new(line=nil, element=nil)
fd: Create a new NotWellFormedError for an error at line in element. If a block is given the return value of the block ends up in the error message.
pt: RSS::NotWellFormedError
mt: class
fn: new
fs: new(tag, prefix, require_uri)
fd: 
pt: RSS::NSError
mt: class
fn: new
fs: new(prefix)
fd: 
pt: RSS::OverlappedPrefixError
mt: class
fn: default_parser=
fs: default_parser=(new_value)
fd: Set @@default_parser to new_value if it is one of the available parsers. Else raise NotValidXMLParser error.
pt: RSS::Parser
mt: class
fn: default_parser
fs: default_parser()
fd: 
pt: RSS::Parser
mt: class
fn: new
fs: new(rss, parser_class=self.class.default_parser)
fd: 
pt: RSS::Parser
mt: class
fn: parse
fs: parse(rss, do_validate=true, ignore_unknown_element=true, parser_class=default_parser)
fd: 
pt: RSS::Parser
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::RDF::Bag
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Bag
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Bag
mt: class
fn: setup_maker
fs: setup_maker(target)
fd: 
pt: RSS::RDF::Bag
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Channel::Image
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Channel::Image
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Channel::Items
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Channel::Items
mt: class
fn: resources
fs: resources()
fd: 
pt: RSS::RDF::Channel::Items
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Channel
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Channel
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Channel::Textinput
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Channel::Textinput
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::RDF
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Image
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Image
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Item
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Item
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::RDF::Li
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Li
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Li
mt: class
fn: new
fs: new(version=nil, encoding=nil, standalone=nil)
fd: 
pt: RSS::RDF
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::RDF::Seq
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Seq
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Seq
mt: class
fn: setup_maker
fs: setup_maker(target)
fd: 
pt: RSS::RDF::Seq
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::RDF::Textinput
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::RDF::Textinput
mt: class
fn: character
fs: character(data)
fd: 
pt: RSS::REXMLLikeXMLParser
mt: instance
fn: endElement
fs: endElement(name)
fd: 
pt: RSS::REXMLLikeXMLParser
mt: instance
fn: listener=
fs: listener=(listener)
fd: 
pt: RSS::REXMLLikeXMLParser
mt: instance
fn: processingInstruction
fs: processingInstruction(target, content)
fd: 
pt: RSS::REXMLLikeXMLParser
mt: instance
fn: startElement
fs: startElement(name, attrs)
fd: 
pt: RSS::REXMLLikeXMLParser
mt: instance
fn: xmlDecl
fs: xmlDecl(version, encoding, standalone)
fd: 
pt: RSS::REXMLLikeXMLParser
mt: instance
fn: raise_for_undefined_entity?
fs: raise_for_undefined_entity?()
fd: 
pt: RSS::REXMLListener
mt: class
fn: xmldecl
fs: xmldecl(version, encoding, standalone)
fd: 
pt: RSS::REXMLListener
mt: instance
fn: listener
fs: listener()
fd: 
pt: RSS::REXMLParser
mt: class
fn: new
fs: new(rss_version, version=nil, encoding=nil, standalone=nil)
fd: 
pt: RSS::RootElementMixin
mt: class
fn: output_encoding=
fs: output_encoding=(enc)
fd: 
pt: RSS::RootElementMixin
mt: instance
fn: setup_maker
fs: setup_maker(maker)
fd: 
pt: RSS::RootElementMixin
mt: instance
fn: to_xml
fs: to_xml(version=nil, &block)
fd: 
pt: RSS::RootElementMixin
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::Cloud
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::Image
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::Item::Category
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::Item::Enclosure
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::Item::Guid
mt: class
fn: PermaLink?
fs: PermaLink?()
fd: 
pt: RSS::Rss::Channel::Item::Guid
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::Item::Source
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::SkipDays::Day
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::SkipHours::Hour
mt: class
fn: new
fs: new(*args)
fd: 
pt: RSS::Rss::Channel::TextInput
mt: class
fn: image
fs: image()
fd: 
pt: RSS::Rss
mt: instance
fn: items
fs: items()
fd: 
pt: RSS::Rss
mt: instance
fn: new
fs: new(rss_version, version=nil, encoding=nil, standalone=nil)
fd: 
pt: RSS::Rss
mt: class
fn: setup_maker_elements
fs: setup_maker_elements(maker)
fd: 
pt: RSS::Rss
mt: instance
fn: textinput
fs: textinput()
fd: 
pt: RSS::Rss
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::RSS09
mt: class
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::RSS10
mt: class
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::SyndicationModel
mt: class
fn: sy_updatePeriod=
fs: sy_updatePeriod=(new_value)
fd: 
pt: RSS::SyndicationModel
mt: instance
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::TaxonomyTopicModel
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::TaxonomyTopicModel::TaxonomyTopic
mt: instance
fn: maker_target
fs: maker_target(target)
fd: 
pt: RSS::TaxonomyTopicModel::TaxonomyTopic
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::TaxonomyTopicModel::TaxonomyTopic
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::TaxonomyTopicModel::TaxonomyTopic
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::TaxonomyTopicModel::TaxonomyTopic
mt: class
fn: append_features
fs: append_features(klass)
fd: 
pt: RSS::TaxonomyTopicsModel
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::TaxonomyTopicsModel::TaxonomyTopics
mt: instance
fn: maker_target
fs: maker_target(target)
fd: 
pt: RSS::TaxonomyTopicsModel::TaxonomyTopics
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::TaxonomyTopicsModel::TaxonomyTopics
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::TaxonomyTopicsModel::TaxonomyTopics
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::TaxonomyTopicsModel::TaxonomyTopics
mt: class
fn: resources
fs: resources()
fd: 
pt: RSS::TaxonomyTopicsModel::TaxonomyTopics
mt: instance
fn: new
fs: new(tag, parent)
fd: 
pt: RSS::TooMuchTagError
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::TrackBackModel10::TrackBackAbout
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::TrackBackModel10::TrackBackAbout
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::TrackBackModel10::TrackBackAbout
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::TrackBackModel10::TrackBackAbout
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::TrackBackModel10::TrackBackPing
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::TrackBackModel10::TrackBackPing
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::TrackBackModel10::TrackBackPing
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::TrackBackModel10::TrackBackPing
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::TrackBackModel20::TrackBackAbout
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::TrackBackModel20::TrackBackAbout
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::TrackBackModel20::TrackBackAbout
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::TrackBackModel20::TrackBackAbout
mt: class
fn: full_name
fs: full_name()
fd: 
pt: RSS::TrackBackModel20::TrackBackPing
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::TrackBackModel20::TrackBackPing
mt: class
fn: required_prefix
fs: required_prefix()
fd: 
pt: RSS::TrackBackModel20::TrackBackPing
mt: class
fn: required_uri
fs: required_uri()
fd: 
pt: RSS::TrackBackModel20::TrackBackPing
mt: class
fn: new
fs: new(to, from)
fd: 
pt: RSS::UnknownConversionMethodError
mt: class
fn: new
fs: new(tag, uri)
fd: 
pt: RSS::UnknownTagError
mt: class
fn: element_initialize_arguments?
fs: element_initialize_arguments?(args)
fd: 
pt: RSS::Utils
mt: instance
fn: get_file_and_line_from_caller
fs: get_file_and_line_from_caller(i=0)
fd: 
pt: RSS::Utils
mt: instance
fn: h
fs: h(s)
fd: "Alias for #html_escape"
pt: RSS::Utils
mt: instance
fn: html_escape
fs: html_escape(s)
fd: escape '&amp;', '&quot;', '&lt;' and '&gt;' for use in HTML.
pt: RSS::Utils
mt: instance
fn: new_with_value_if_need
fs: new_with_value_if_need(klass, value)
fd: If value is an instance of class klass, return it, else create a new instance of klass with value value.
pt: RSS::Utils
mt: instance
fn: to_class_name
fs: to_class_name(name)
fd: Convert a name_with_underscores to CamelCase.
pt: RSS::Utils
mt: instance
fn: xmldecl
fs: xmldecl(version, encoding, standalone)
fd: 
pt: RSS::XMLParserListener
mt: instance
fn: new
fs: new()
fd: 
pt: RSS::XMLParserNotFound
mt: class
fn: listener
fs: listener()
fd: 
pt: RSS::XMLParserParser
mt: class
fn: on_attr_charref
fs: on_attr_charref(code)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_attr_charref_hex
fs: on_attr_charref_hex(code)
fd: "Alias for #on_attr_charref"
pt: RSS::XMLScanListener
mt: instance
fn: on_attr_entityref
fs: on_attr_entityref(ref)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_attr_value
fs: on_attr_value(str)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_attribute
fs: on_attribute(name)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_charref
fs: on_charref(code)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_charref_hex
fs: on_charref_hex(code)
fd: "Alias for #on_charref"
pt: RSS::XMLScanListener
mt: instance
fn: on_entityref
fs: on_entityref(ref)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_etag
fs: on_etag(name)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_stag
fs: on_stag(name)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_stag_end
fs: on_stag_end(name)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_stag_end_empty
fs: on_stag_end_empty(name)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_xmldecl_encoding
fs: on_xmldecl_encoding(str)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_xmldecl_end
fs: on_xmldecl_end()
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_xmldecl_standalone
fs: on_xmldecl_standalone(str)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: on_xmldecl_version
fs: on_xmldecl_version(str)
fd: 
pt: RSS::XMLScanListener
mt: instance
fn: listener
fs: listener()
fd: 
pt: RSS::XMLScanParser
mt: class
fn: alternate=
fs: alternate=(value)
fd: 
pt: RSS::XMLStyleSheet
mt: instance
fn: href=
fs: href=(value)
fd: 
pt: RSS::XMLStyleSheet
mt: instance
fn: new
fs: new(*attrs)
fd: 
pt: RSS::XMLStyleSheet
mt: class
fn: setup_maker
fs: setup_maker(maker)
fd: 
pt: RSS::XMLStyleSheet
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: RSS::XMLStyleSheet
mt: instance
fn: new
fs: new(*args)
fd: 
pt: RSS::XMLStyleSheetMixin
mt: class
fn: column
fs: column()
fd: 
pt: RubyLex::BufferedReader
mt: instance
fn: divert_read_from
fs: divert_read_from(reserve)
fd: 
pt: RubyLex::BufferedReader
mt: instance
fn: get_read
fs: get_read()
fd: 
pt: RubyLex::BufferedReader
mt: instance
fn: getc
fs: getc()
fd: 
pt: RubyLex::BufferedReader
mt: instance
fn: getc_already_read
fs: getc_already_read()
fd: 
pt: RubyLex::BufferedReader
mt: instance
fn: new
fs: new(content)
fd: 
pt: RubyLex::BufferedReader
mt: class
fn: peek
fs: peek(at)
fd: 
pt: RubyLex::BufferedReader
mt: instance
fn: peek_equal
fs: peek_equal(str)
fd: 
pt: RubyLex::BufferedReader
mt: instance
fn: ungetc
fs: ungetc(ch)
fd: 
pt: RubyLex::BufferedReader
mt: instance
fn: char_no
fs: char_no()
fd: 
pt: RubyLex
mt: instance
fn: debug?
fs: debug?()
fd: 
pt: RubyLex
mt: class
fn: each_top_level_statement
fs: each_top_level_statement()
fd: 
pt: RubyLex
mt: instance
fn: eof?
fs: eof?()
fd: 
pt: RubyLex
mt: instance
fn: get_read
fs: get_read()
fd: 
pt: RubyLex
mt: instance
fn: get_readed
fs: get_readed()
fd: 
pt: RubyLex
mt: instance
fn: getc
fs: getc()
fd: 
pt: RubyLex
mt: instance
fn: getc_of_rests
fs: getc_of_rests()
fd: 
pt: RubyLex
mt: instance
fn: gets
fs: gets()
fd: 
pt: RubyLex
mt: instance
fn: identify_comment
fs: identify_comment()
fd: 
pt: RubyLex
mt: instance
fn: identify_gvar
fs: identify_gvar()
fd: 
pt: RubyLex
mt: instance
fn: identify_here_document
fs: identify_here_document()
fd: 
pt: RubyLex
mt: instance
fn: identify_identifier
fs: identify_identifier()
fd: 
pt: RubyLex
mt: instance
fn: identify_number
fs: identify_number(start)
fd: 
pt: RubyLex
mt: instance
fn: identify_quotation
fs: identify_quotation()
fd: 
pt: RubyLex
mt: instance
fn: identify_string
fs: identify_string(ltype, quoted = ltype)
fd: 
pt: RubyLex
mt: instance
fn: initialize_input
fs: initialize_input()
fd: 
pt: RubyLex
mt: instance
fn: lex
fs: lex()
fd: 
pt: RubyLex
mt: instance
fn: lex_init
fs: lex_init()
fd: 
pt: RubyLex
mt: instance
fn: lex_int2
fs: lex_int2()
fd: 
pt: RubyLex
mt: instance
fn: line_no
fs: line_no()
fd: io functions
pt: RubyLex
mt: instance
fn: new
fs: new(content)
fd: 
pt: RubyLex
mt: class
fn: peek
fs: peek(i = 0)
fd: 
pt: RubyLex
mt: instance
fn: peek_equal?
fs: peek_equal?(str)
fd: 
pt: RubyLex
mt: instance
fn: peek_match?
fs: peek_match?(regexp)
fd: 
pt: RubyLex
mt: instance
fn: prompt
fs: prompt()
fd: 
pt: RubyLex
mt: instance
fn: read_escape
fs: read_escape()
fd: 
pt: RubyLex
mt: instance
fn: set_input
fs: set_input(io, p = nil, &block)
fd: io functions
pt: RubyLex
mt: instance
fn: set_prompt
fs: set_prompt(p = nil, &block)
fd: 
pt: RubyLex
mt: instance
fn: skip_inner_expression
fs: skip_inner_expression()
fd: 
pt: RubyLex
mt: instance
fn: token
fs: token()
fd: 
pt: RubyLex
mt: instance
fn: ungetc
fs: ungetc(c = nil)
fd: 
pt: RubyLex
mt: instance
fn: def_token
fs: def_token(token_n, super_token = Token, reading = nil, *opts)
fd: 
pt: RubyToken
mt: class
fn: set_token_position
fs: set_token_position(line, char)
fd: 
pt: RubyToken
mt: instance
fn: new
fs: new(line_no, char_no, name)
fd: 
pt: RubyToken::TkId
mt: class
fn: new
fs: new(seek, line_no, char_no)
fd: 
pt: RubyToken::TkNode
mt: class
fn: name
fs: name()
fd: 
pt: RubyToken::TkOp
mt: instance
fn: new
fs: new(line_no, char_no, op)
fd: 
pt: RubyToken::TkOPASGN
mt: class
fn: new
fs: new(line_no, char_no, id)
fd: 
pt: RubyToken::TkUnknownChar
mt: class
fn: new
fs: new(line_no, char_no, value = nil)
fd: 
pt: RubyToken::TkVal
mt: class
fn: new
fs: new(line_no, char_no)
fd: 
pt: RubyToken::Token
mt: class
fn: set_text
fs: set_text(text)
fd: Because we're used in contexts that expect to return a token, we set the text string and then return ourselves
pt: RubyToken::Token
mt: instance
fn: Token
fs: Token(token, value = nil)
fd: 
pt: RubyToken
mt: instance
fn: assert_equal_float
fs: assert_equal_float(expected, actual, delta, message="")
fd: 
pt: RUNIT::Assert
mt: instance
fn: assert_exception
fs: assert_exception(exception, message="", &block)
fd: 
pt: RUNIT::Assert
mt: instance
fn: assert_fail
fs: assert_fail(message="")
fd: 
pt: RUNIT::Assert
mt: instance
fn: assert_match
fs: assert_match(actual_string, expected_re, message="")
fd: To deal with the fact that RubyUnit does not check that the regular expression is, indeed, a regular expression, if it is not, we do our own assertion using the same semantics as RubyUnit
pt: RUNIT::Assert
mt: instance
fn: assert_matches
fs: assert_matches(*args)
fd: 
pt: RUNIT::Assert
mt: instance
fn: assert_no_exception
fs: assert_no_exception(*args, &block)
fd: 
pt: RUNIT::Assert
mt: instance
fn: assert_not_match
fs: assert_not_match(actual_string, expected_re, message="")
fd: 
pt: RUNIT::Assert
mt: instance
fn: assert_not_nil
fs: assert_not_nil(actual, message="")
fd: 
pt: RUNIT::Assert
mt: instance
fn: assert_respond_to
fs: assert_respond_to(method, object, message="")
fd: 
pt: RUNIT::Assert
mt: instance
fn: assert_send
fs: assert_send(object, method, *args)
fd: 
pt: RUNIT::Assert
mt: instance
fn: called_internally?
fs: called_internally?()
fd: 
pt: RUNIT::Assert
mt: instance
fn: setup_assert
fs: setup_assert()
fd: 
pt: RUNIT::Assert
mt: instance
fn: create_mediator
fs: create_mediator(suite)
fd: 
pt: RUNIT::CUI::TestRunner
mt: instance
fn: create_result
fs: create_result()
fd: 
pt: RUNIT::CUI::TestRunner
mt: instance
fn: new
fs: new()
fd: 
pt: RUNIT::CUI::TestRunner
mt: class
fn: quiet_mode=
fs: quiet_mode=(boolean)
fd: 
pt: RUNIT::CUI::TestRunner
mt: class
fn: run
fs: run(suite)
fd: 
pt: RUNIT::CUI::TestRunner
mt: class
fn: run
fs: run(suite, quiet_mode=@@quiet_mode)
fd: 
pt: RUNIT::CUI::TestRunner
mt: instance
fn: assert_equals
fs: assert_equals(*args)
fd: 
pt: RUNIT::TestCase
mt: instance
fn: name
fs: name()
fd: 
pt: RUNIT::TestCase
mt: instance
fn: new
fs: new(test_name, suite_name=self.class.name)
fd: 
pt: RUNIT::TestCase
mt: class
fn: run
fs: run(result, &progress_block)
fd: 
pt: RUNIT::TestCase
mt: instance
fn: suite
fs: suite()
fd: 
pt: RUNIT::TestCase
mt: class
fn: add_error
fs: add_error(error)
fd: 
pt: RUNIT::TestResult
mt: instance
fn: add_failure
fs: add_failure(failure)
fd: 
pt: RUNIT::TestResult
mt: instance
fn: error_size
fs: error_size()
fd: 
pt: RUNIT::TestResult
mt: instance
fn: failure_size
fs: failure_size()
fd: 
pt: RUNIT::TestResult
mt: instance
fn: run_asserts
fs: run_asserts()
fd: 
pt: RUNIT::TestResult
mt: instance
fn: run_tests
fs: run_tests()
fd: 
pt: RUNIT::TestResult
mt: instance
fn: succeed?
fs: succeed?()
fd: 
pt: RUNIT::TestResult
mt: instance
fn: add
fs: add(*args)
fd: 
pt: RUNIT::TestSuite
mt: instance
fn: add_test
fs: add_test(*args)
fd: 
pt: RUNIT::TestSuite
mt: instance
fn: count_test_cases
fs: count_test_cases()
fd: 
pt: RUNIT::TestSuite
mt: instance
fn: run
fs: run(result, &progress_block)
fd: 
pt: RUNIT::TestSuite
mt: instance
fn: count_space?
fs: count_space?()
fd: 
pt: Scanf::FormatSpecifier
mt: instance
fn: letter
fs: letter()
fd: 
pt: Scanf::FormatSpecifier
mt: instance
fn: match
fs: match(str)
fd: 
pt: Scanf::FormatSpecifier
mt: instance
fn: mid_match?
fs: mid_match?()
fd: 
pt: Scanf::FormatSpecifier
mt: instance
fn: new
fs: new(str)
fd: 
pt: Scanf::FormatSpecifier
mt: class
fn: to_re
fs: to_re()
fd: 
pt: Scanf::FormatSpecifier
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: Scanf::FormatSpecifier
mt: instance
fn: width
fs: width()
fd: 
pt: Scanf::FormatSpecifier
mt: instance
fn: last_spec
fs: last_spec()
fd: 
pt: Scanf::FormatString
mt: instance
fn: match
fs: match(str)
fd: 
pt: Scanf::FormatString
mt: instance
fn: new
fs: new(str)
fd: 
pt: Scanf::FormatString
mt: class
fn: prune
fs: prune(n=matched_count)
fd: 
pt: Scanf::FormatString
mt: instance
fn: spec_count
fs: spec_count()
fd: 
pt: Scanf::FormatString
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: Scanf::FormatString
mt: instance
fn: add?
fs: add?(o)
fd: Adds the given object to the set and returns self. If the object is already in the set, returns nil.
pt: Set
mt: instance
fn: add
fs: add(o)
fd: Adds the given object to the set and returns self. Use merge to add several elements at once.
pt: Set
mt: instance
fn: classify
fs: classify( {|o| ...}
fd: Classifies the set by the return value of the given block and returns a hash of {value =&gt; set of elements} pairs. The block is called once for each element of the set, passing the element as parameter.
pt: Set
mt: instance
fn: clear
fs: clear()
fd: Removes all elements and returns self.
pt: Set
mt: instance
fn: collect!
fs: collect!()
fd: Do collect() destructively.
pt: Set
mt: instance
fn: delete?
fs: delete?(o)
fd: Deletes the given object from the set and returns self. If the object is not in the set, returns nil.
pt: Set
mt: instance
fn: delete
fs: delete(o)
fd: Deletes the given object from the set and returns self. Use subtract to delete several items at once.
pt: Set
mt: instance
fn: delete_if
fs: delete_if()
fd: Deletes every element of the set for which block evaluates to true, and returns self.
pt: Set
mt: instance
fn: difference
fs: difference(enum)
fd: "Alias for #-"
pt: Set
mt: instance
fn: divide
fs: divide(&func)
fd: Divides the set into a set of subsets according to the commonality defined by the given block.
pt: Set
mt: instance
fn: each
fs: each()
fd: Calls the given block once for each element in the set, passing the element as parameter.
pt: Set
mt: instance
fn: empty?
fs: empty?()
fd: Returns true if the set contains no elements.
pt: Set
mt: instance
fn: flatten!
fs: flatten!()
fd: Equivalent to Set#flatten, but replaces the receiver with the result in place. Returns nil if no modifications were made.
pt: Set
mt: instance
fn: flatten
fs: flatten()
fd: Returns a new set that is a copy of the set, flattening each containing set recursively.
pt: Set
mt: instance
fn: include?
fs: include?(o)
fd: Returns true if the set contains the given object.
pt: Set
mt: instance
fn: initialize_copy
fs: initialize_copy(orig)
fd: Copy internal hash.
pt: Set
mt: instance
fn: inspect
fs: inspect()
fd: "Returns a string containing a human-readable representation of the set. (&quot;#&lt;Set: {element1, element2, ...}&gt;&quot;)"
pt: Set
mt: instance
fn: intersection
fs: intersection(enum)
fd: "Alias for #&amp;"
pt: Set
mt: instance
fn: length
fs: length()
fd: "Alias for #size"
pt: Set
mt: instance
fn: map!
fs: map!()
fd: "Alias for #collect!"
pt: Set
mt: instance
fn: member?
fs: member?(o)
fd: "Alias for #include?"
pt: Set
mt: instance
fn: merge
fs: merge(enum)
fd: Merges the elements of the given enumerable object to the set and returns self.
pt: Set
mt: instance
fn: new
fs: new(enum = nil)
fd: Creates a new set containing the elements of the given enumerable object.
pt: Set
mt: class
fn: proper_subset?
fs: proper_subset?(set)
fd: Returns true if the set is a proper subset of the given set.
pt: Set
mt: instance
fn: proper_superset?
fs: proper_superset?(set)
fd: Returns true if the set is a proper superset of the given set.
pt: Set
mt: instance
fn: reject!
fs: reject!()
fd: Equivalent to Set#delete_if, but returns nil if no changes were made.
pt: Set
mt: instance
fn: replace
fs: replace(enum)
fd: Replaces the contents of the set with the contents of the given enumerable object and returns self.
pt: Set
mt: instance
fn: size
fs: size()
fd: Returns the number of elements.
pt: Set
mt: instance
fn: subset?
fs: subset?(set)
fd: Returns true if the set is a subset of the given set.
pt: Set
mt: instance
fn: subtract
fs: subtract(enum)
fd: Deletes every element that appears in the given enumerable object and returns self.
pt: Set
mt: instance
fn: superset?
fs: superset?(set)
fd: Returns true if the set is a superset of the given set.
pt: Set
mt: instance
fn: to_a
fs: to_a()
fd: Converts the set to an array. The order of elements is uncertain.
pt: Set
mt: instance
fn: union
fs: union(enum)
fd: "Alias for #|"
pt: Set
mt: instance
fn: alias_command
fs: alias_command(ali, command, *opts, &block)
fd: 
pt: Shell
mt: class
fn: input=
fs: input=(filter)
fd: 
pt: Shell::AppendFile
mt: instance
fn: new
fs: new(sh, to_filename, filter)
fd: 
pt: Shell::AppendFile
mt: class
fn: input=
fs: input=(filter)
fd: 
pt: Shell::AppendIO
mt: instance
fn: new
fs: new(sh, io, filter)
fd: 
pt: Shell::AppendIO
mt: class
fn: active?
fs: active?()
fd: 
pt: Shell::BuiltInCommand
mt: instance
fn: wait?
fs: wait?()
fd: 
pt: Shell::BuiltInCommand
mt: instance
fn: each
fs: each(rs = nil)
fd: 
pt: Shell::Cat
mt: instance
fn: new
fs: new(sh, *filenames)
fd: 
pt: Shell::Cat
mt: class
fn: cd
fs: cd(path)
fd: 
pt: Shell
mt: class
fn: cd
fs: cd(path = nil)
fd: "Alias for #chdir"
pt: Shell
mt: instance
fn: chdir
fs: chdir(path = nil)
fd: If called as iterator, it restores the current directory when the block ends.
pt: Shell
mt: instance
fn: add_delegate_command_to_shell
fs: add_delegate_command_to_shell(id)
fd: 
pt: Shell::CommandProcessor
mt: class
fn: alias_command
fs: alias_command(ali, command, *opts, &block)
fd: 
pt: Shell::CommandProcessor
mt: class
fn: alias_map
fs: alias_map()
fd: 
pt: Shell::CommandProcessor
mt: class
fn: append
fs: append(to, filter)
fd: 
pt: Shell::CommandProcessor
mt: instance
fn: cat
fs: cat(*filenames)
fd: 
pt: Shell::CommandProcessor
mt: instance
fn: check_point
fs: check_point()
fd: ProcessCommand#transact
pt: Shell::CommandProcessor
mt: instance
fn: concat
fs: concat(*jobs)
fd: 
pt: Shell::CommandProcessor
mt: instance
fn: def_builtin_commands
fs: def_builtin_commands(delegation_class, command_specs)
fd: CommandProcessor.def_builtin_commands(delegation_class, command_specs)
pt: Shell::CommandProcessor
mt: class
fn: def_system_command
fs: def_system_command(command, path = command)
fd: CommandProcessor.def_system_command(command, path)
pt: Shell::CommandProcessor
mt: class
fn: echo
fs: echo(*strings)
fd: 
pt: Shell::CommandProcessor
mt: instance
fn: expand_path
fs: expand_path(path)
fd: CommandProcessor#expand_path(path)
pt: Shell::CommandProcessor
mt: instance
fn: find_system_command
fs: find_system_command(command)
fd: 
pt: Shell::CommandProcessor
mt: instance
fn: finish_all_jobs
fs: finish_all_jobs()
fd: "Alias for #check_point"
pt: Shell::CommandProcessor
mt: instance
fn: foreach
fs: foreach(path = nil, *rs)
fd: File related commands Shell#foreach Shell#open Shell#unlink Shell#test
pt: Shell::CommandProcessor
mt: instance
fn: glob
fs: glob(pattern)
fd: def sort(*filenames)
pt: Shell::CommandProcessor
mt: instance
fn: initialize
fs: initialize()
fd: 
pt: Shell::CommandProcessor
mt: class
fn: install_builtin_commands
fs: install_builtin_commands()
fd: define default builtin commands
pt: Shell::CommandProcessor
mt: class
fn: install_system_commands
fs: install_system_commands(pre = "sys_")
fd: CommandProcessor.install_system_commands(pre)
pt: Shell::CommandProcessor
mt: class
fn: method_added
fs: method_added(id)
fd: 
pt: Shell::CommandProcessor
mt: class
fn: mkdir
fs: mkdir(*path)
fd: Dir related methods
pt: Shell::CommandProcessor
mt: instance
fn: new
fs: new(shell)
fd: 
pt: Shell::CommandProcessor
mt: class
fn: notify
fs: notify(*opts, &block)
fd: "%pwd, %cwd -&gt; @pwd"
pt: Shell::CommandProcessor
mt: instance
fn: open
fs: open(path, mode)
fd: CommandProcessor#open(path, mode)
pt: Shell::CommandProcessor
mt: instance
fn: out
fs: out(dev = STDOUT, &block)
fd: internal commands
pt: Shell::CommandProcessor
mt: instance
fn: rehash
fs: rehash()
fd: ProcessCommand#rehash
pt: Shell::CommandProcessor
mt: instance
fn: rmdir
fs: rmdir(*path)
fd: CommandProcessor#rmdir(*path)
pt: Shell::CommandProcessor
mt: instance
fn: run_config
fs: run_config()
fd: include run file.
pt: Shell::CommandProcessor
mt: class
fn: system
fs: system(command, *opts)
fd: CommandProcessor#system(command, *opts)
pt: Shell::CommandProcessor
mt: instance
fn: tee
fs: tee(file)
fd: 
pt: Shell::CommandProcessor
mt: instance
fn: test
fs: test(command, file1, file2=nil)
fd: CommandProcessor#test(command, file1, file2) CommandProcessor#[command, file1, file2]
pt: Shell::CommandProcessor
mt: instance
fn: transact
fs: transact(&block)
fd: 
pt: Shell::CommandProcessor
mt: instance
fn: unalias_command
fs: unalias_command(ali)
fd: 
pt: Shell::CommandProcessor
mt: class
fn: undef_system_command
fs: undef_system_command(command)
fd: 
pt: Shell::CommandProcessor
mt: class
fn: unlink
fs: unlink(path)
fd: CommandProcessor#unlink(path)
pt: Shell::CommandProcessor
mt: instance
fn: each
fs: each(rs = nil)
fd: 
pt: Shell::Concat
mt: instance
fn: new
fs: new(sh, *jobs)
fd: 
pt: Shell::Concat
mt: class
fn: debug=
fs: debug=(val)
fd: 
pt: Shell
mt: class
fn: debug=
fs: debug=(val)
fd: 
pt: Shell
mt: instance
fn: def_system_command
fs: def_system_command(command, path = command)
fd: command definitions
pt: Shell
mt: class
fn: default_record_separator=
fs: default_record_separator=(rs)
fd: 
pt: Shell
mt: class
fn: default_record_separator
fs: default_record_separator()
fd: 
pt: Shell
mt: class
fn: default_system_path=
fs: default_system_path=(path)
fd: 
pt: Shell
mt: class
fn: default_system_path
fs: default_system_path()
fd: 
pt: Shell
mt: class
fn: each
fs: each(rs = nil)
fd: 
pt: Shell::Echo
mt: instance
fn: new
fs: new(sh, *strings)
fd: 
pt: Shell::Echo
mt: class
fn: expand_path
fs: expand_path(path)
fd: 
pt: Shell
mt: instance
fn: each
fs: each(rs = nil)
fd: 
pt: Shell::Filter
mt: instance
fn: input=
fs: input=(filter)
fd: 
pt: Shell::Filter
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: Shell::Filter
mt: instance
fn: new
fs: new(sh)
fd: 
pt: Shell::Filter
mt: class
fn: to_a
fs: to_a()
fd: 
pt: Shell::Filter
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: Shell::Filter
mt: instance
fn: each
fs: each(rs = nil)
fd: 
pt: Shell::Glob
mt: instance
fn: new
fs: new(sh, pattern)
fd: 
pt: Shell::Glob
mt: class
fn: inspect
fs: inspect()
fd: 
pt: Shell
mt: instance
fn: install_system_commands
fs: install_system_commands(pre = "sys_")
fd: 
pt: Shell
mt: class
fn: jobs
fs: jobs()
fd: process management
pt: Shell
mt: instance
fn: kill
fs: kill(sig, command)
fd: 
pt: Shell
mt: instance
fn: new
fs: new()
fd: 
pt: Shell
mt: class
fn: notify
fs: notify(*opts, &block)
fd: 
pt: Shell
mt: class
fn: popd
fs: popd()
fd: "Alias for #popdir"
pt: Shell
mt: instance
fn: popdir
fs: popdir()
fd: 
pt: Shell
mt: instance
fn: activate
fs: activate(pc)
fd: 
pt: Shell::ProcessController
mt: class
fn: active_job?
fs: active_job?(job)
fd: 
pt: Shell::ProcessController
mt: instance
fn: active_jobs
fs: active_jobs()
fd: 
pt: Shell::ProcessController
mt: instance
fn: active_jobs_exist?
fs: active_jobs_exist?()
fd: 
pt: Shell::ProcessController
mt: instance
fn: add_schedule
fs: add_schedule(command)
fd: schedule a command
pt: Shell::ProcessController
mt: instance
fn: each_active_object
fs: each_active_object()
fd: 
pt: Shell::ProcessController
mt: class
fn: inactivate
fs: inactivate(pc)
fd: 
pt: Shell::ProcessController
mt: class
fn: jobs
fs: jobs()
fd: 
pt: Shell::ProcessController
mt: instance
fn: jobs_exist?
fs: jobs_exist?()
fd: 
pt: Shell::ProcessController
mt: instance
fn: kill_job
fs: kill_job(sig, command)
fd: kill a job
pt: Shell::ProcessController
mt: instance
fn: new
fs: new(shell)
fd: 
pt: Shell::ProcessController
mt: class
fn: process_controllers_exclusive
fs: process_controllers_exclusive()
fd: 
pt: Shell::ProcessController
mt: class
fn: sfork
fs: sfork(command, &block)
fd: simple fork
pt: Shell::ProcessController
mt: instance
fn: start_job
fs: start_job(command = nil)
fd: start a job
pt: Shell::ProcessController
mt: instance
fn: terminate_job
fs: terminate_job(command)
fd: terminate a job
pt: Shell::ProcessController
mt: instance
fn: wait_all_jobs_execution
fs: wait_all_jobs_execution()
fd: wait for all jobs to terminate
pt: Shell::ProcessController
mt: instance
fn: waiting_job?
fs: waiting_job?(job)
fd: 
pt: Shell::ProcessController
mt: instance
fn: waiting_jobs
fs: waiting_jobs()
fd: 
pt: Shell::ProcessController
mt: instance
fn: waiting_jobs_exist?
fs: waiting_jobs_exist?()
fd: 
pt: Shell::ProcessController
mt: instance
fn: pushd
fs: pushd(path = nil)
fd: "Alias for #pushdir"
pt: Shell
mt: instance
fn: pushdir
fs: pushdir(path = nil)
fd: 
pt: Shell
mt: instance
fn: system_path=
fs: system_path=(path)
fd: 
pt: Shell
mt: instance
fn: active?
fs: active?()
fd: 
pt: Shell::SystemCommand
mt: instance
fn: each
fs: each(rs = nil)
fd: 
pt: Shell::SystemCommand
mt: instance
fn: flush
fs: flush()
fd: 
pt: Shell::SystemCommand
mt: instance
fn: input=
fs: input=(inp)
fd: 
pt: Shell::SystemCommand
mt: instance
fn: kill
fs: kill(sig)
fd: 
pt: Shell::SystemCommand
mt: instance
fn: new
fs: new(sh, command, *opts)
fd: 
pt: Shell::SystemCommand
mt: class
fn: notify
fs: notify(*opts, &block)
fd: ex)
pt: Shell::SystemCommand
mt: instance
fn: start
fs: start()
fd: 
pt: Shell::SystemCommand
mt: instance
fn: start_export
fs: start_export()
fd: 
pt: Shell::SystemCommand
mt: instance
fn: start_import
fs: start_import()
fd: 
pt: Shell::SystemCommand
mt: instance
fn: terminate
fs: terminate()
fd: 
pt: Shell::SystemCommand
mt: instance
fn: wait?
fs: wait?()
fd: 
pt: Shell::SystemCommand
mt: instance
fn: each
fs: each(rs = nil)
fd: 
pt: Shell::Tee
mt: instance
fn: new
fs: new(sh, filename)
fd: 
pt: Shell::Tee
mt: class
fn: unalias_command
fs: unalias_command(ali)
fd: 
pt: Shell
mt: class
fn: undef_system_command
fs: undef_system_command(command)
fd: 
pt: Shell
mt: class
fn: shellwords
fs: shellwords(line)
fd: Split text into an array of tokens in the same way the UNIX Bourne shell does.
pt: Shellwords
mt: instance
fn: list
fs: list
fd: Returns a list of signal names mapped to the corresponding underlying signal numbers.
pt: Signal
mt: class
fn: trap
fs: trap( signal, proc )
fd: Specifies the handling of signals. The first parameter is a signal name (a string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a signal number. The characters ``SIG'' may be omitted from the signal name. The command or block specifies code to be run when the signal is raised. If the command is the string ``IGNORE'' or ``SIG_IGN'', the signal will be ignored. If the command is ``DEFAULT'' or ``SIG_DFL'', the operating system's default handler will be invoked. If the command is ``EXIT'', the script will be terminated by the signal. Otherwise, the given command or block will be run. The special signal name ``EXIT'' or signal number zero will be invoked just prior to program termination. trap returns the previous handler for the given signal.
pt: Signal
mt: class
fn: clone
fs: clone()
fd: Clone support for the object returned by __getobj__.
pt: SimpleDelegator
mt: instance
fn: dup
fs: dup(obj)
fd: Duplication support for the object returned by __getobj__.
pt: SimpleDelegator
mt: instance
fn: new
fs: new(obj)
fd: Pass in the obj you would like to delegate method calls to.
pt: SimpleDelegator
mt: class
fn: def_delegator
fs: def_delegator(accessor, method, ali = method)
fd: "Alias for #def_singleton_delegator"
pt: SingleForwardable
mt: instance
fn: def_delegators
fs: def_delegators(accessor, *methods)
fd: "Alias for #def_singleton_delegators"
pt: SingleForwardable
mt: instance
fn: def_singleton_delegator
fs: def_singleton_delegator(accessor, method, ali = method)
fd: Defines a method method which delegates to obj (i.e. it calls the method of the same name in obj). If new_name is provided, it is used as the name for the delegate method.
pt: SingleForwardable
mt: instance
fn: def_singleton_delegators
fs: def_singleton_delegators(accessor, *methods)
fd: "Shortcut for defining multiple delegator methods, but with no provision for using a different name. The following two code samples have the same effect:"
pt: SingleForwardable
mt: instance
fn: clone
fs: clone()
fd: disable build-in copying methods
pt: Singleton
mt: instance
fn: dup
fs: dup()
fd: 
pt: Singleton
mt: instance
fn: clone
fs: clone()
fd: properly clone the Singleton pattern - did you know that duping doesn't copy class methods?
pt: SingletonClassMethods
mt: instance
fn: deq
fs: deq(*args)
fd: "Alias for #pop"
pt: SizedQueue
mt: instance
fn: enq
fs: enq(obj)
fd: "Alias for #push"
pt: SizedQueue
mt: instance
fn: max=
fs: max=(max)
fd: Sets the maximum size of the queue.
pt: SizedQueue
mt: instance
fn: max
fs: max()
fd: Returns the maximum size of the queue.
pt: SizedQueue
mt: instance
fn: new
fs: new(max)
fd: Creates a fixed-length queue with a maximum size of max.
pt: SizedQueue
mt: class
fn: num_waiting
fs: num_waiting()
fd: Returns the number of threads waiting on the queue.
pt: SizedQueue
mt: instance
fn: pop
fs: pop(*args)
fd: Retrieves data from the queue and runs a waiting thread, if any.
pt: SizedQueue
mt: instance
fn: push
fs: push(obj)
fd: Pushes obj to the queue. If there is no space left in the queue, waits until space becomes available.
pt: SizedQueue
mt: instance
fn: shift
fs: shift(*args)
fd: "Alias for #pop"
pt: SizedQueue
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: SM::AttrChanger
mt: instance
fn: as_string
fs: as_string(bitmap)
fd: 
pt: SM::Attribute
mt: class
fn: bitmap_for
fs: bitmap_for(name)
fd: 
pt: SM::Attribute
mt: class
fn: each_name_of
fs: each_name_of(bitmap)
fd: 
pt: SM::Attribute
mt: class
fn: add_html
fs: add_html(tag, name)
fd: 
pt: SM::AttributeManager
mt: instance
fn: add_special
fs: add_special(pattern, name)
fd: 
pt: SM::AttributeManager
mt: instance
fn: add_word_pair
fs: add_word_pair(start, stop, name)
fd: 
pt: SM::AttributeManager
mt: instance
fn: attribute
fs: attribute(turn_on, turn_off)
fd: Return an attribute object with the given turn_on and turn_off bits set
pt: SM::AttributeManager
mt: instance
fn: change_attribute
fs: change_attribute(current, new)
fd: 
pt: SM::AttributeManager
mt: instance
fn: changed_attribute_by_name
fs: changed_attribute_by_name(current_set, new_set)
fd: 
pt: SM::AttributeManager
mt: instance
fn: convert_attrs
fs: convert_attrs(str, attrs)
fd: Map attributes like <b>text</b>to the sequence \001\002&lt;char&gt;\001\003&lt;char&gt;, where &lt;char&gt; is a per-attribute specific character
pt: SM::AttributeManager
mt: instance
fn: convert_html
fs: convert_html(str, attrs)
fd: 
pt: SM::AttributeManager
mt: instance
fn: convert_specials
fs: convert_specials(str, attrs)
fd: 
pt: SM::AttributeManager
mt: instance
fn: copy_string
fs: copy_string(start_pos, end_pos)
fd: 
pt: SM::AttributeManager
mt: instance
fn: display_attributes
fs: display_attributes()
fd: 
pt: SM::AttributeManager
mt: instance
fn: flow
fs: flow(str)
fd: 
pt: SM::AttributeManager
mt: instance
fn: mask_protected_sequences
fs: mask_protected_sequences()
fd: 
pt: SM::AttributeManager
mt: instance
fn: new
fs: new()
fd: 
pt: SM::AttributeManager
mt: class
fn: split_into_flow
fs: split_into_flow()
fd: 
pt: SM::AttributeManager
mt: instance
fn: unmask_protected_sequences
fs: unmask_protected_sequences()
fd: 
pt: SM::AttributeManager
mt: instance
fn: new
fs: new(length)
fd: 
pt: SM::AttrSpan
mt: class
fn: set_attrs
fs: set_attrs(start, length, bits)
fd: 
pt: SM::AttrSpan
mt: instance
fn: new
fs: new(type)
fd: 
pt: SM::Flow::LIST
mt: class
fn: add_text
fs: add_text(txt)
fd: 
pt: SM::Fragment
mt: instance
fn: for
fs: for(line)
fd: 
pt: SM::Fragment
mt: class
fn: new
fs: new(level, param, type, txt)
fd: 
pt: SM::Fragment
mt: class
fn: to_s
fs: to_s()
fd: 
pt: SM::Fragment
mt: instance
fn: type_name
fs: type_name(name)
fd: 
pt: SM::Fragment
mt: class
fn: head_level
fs: head_level()
fd: 
pt: SM::Heading
mt: instance
fn: isBlank?
fs: isBlank?()
fd: Return true if this line is blank
pt: SM::Line
mt: instance
fn: new
fs: new(text)
fd: 
pt: SM::Line
mt: class
fn: stamp
fs: stamp(type, level, param="", flag=nil)
fd: stamp a line with a type, a level, a prefix, and a flag
pt: SM::Line
mt: instance
fn: strip_leading
fs: strip_leading(size)
fd: Strip off the leading margin
pt: SM::Line
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: SM::Line
mt: instance
fn: accept
fs: accept(am, visitor)
fd: 
pt: SM::LineCollection
mt: instance
fn: add
fs: add(fragment)
fd: 
pt: SM::LineCollection
mt: instance
fn: each
fs: each(&b)
fd: 
pt: SM::LineCollection
mt: instance
fn: fragment_for
fs: fragment_for(*args)
fd: Factory for different fragment types
pt: SM::LineCollection
mt: instance
fn: new
fs: new()
fd: 
pt: SM::LineCollection
mt: class
fn: normalize
fs: normalize()
fd: tidy up at the end
pt: SM::LineCollection
mt: instance
fn: to_a
fs: to_a()
fd: For testing
pt: SM::LineCollection
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: SM::LineCollection
mt: instance
fn: as_text
fs: as_text()
fd: 
pt: SM::Lines
mt: instance
fn: delete
fs: delete(a_line)
fd: 
pt: SM::Lines
mt: instance
fn: each
fs: each()
fd: 
pt: SM::Lines
mt: instance
fn: empty?
fs: empty?()
fd: 
pt: SM::Lines
mt: instance
fn: line_types
fs: line_types()
fd: 
pt: SM::Lines
mt: instance
fn: new
fs: new(lines)
fd: 
pt: SM::Lines
mt: class
fn: next
fs: next()
fd: 
pt: SM::Lines
mt: instance
fn: normalize
fs: normalize()
fd: 
pt: SM::Lines
mt: instance
fn: rewind
fs: rewind()
fd: def [](index)
pt: SM::Lines
mt: instance
fn: unget
fs: unget()
fd: 
pt: SM::Lines
mt: instance
fn: new
fs: new(level, type)
fd: 
pt: SM::ListEnd
mt: class
fn: new
fs: new(level, param, type)
fd: 
pt: SM::ListStart
mt: class
fn: handle
fs: handle(text)
fd: Look for common options in a chunk of text. Options that we don't handle are passed back to our caller as |directive, param|
pt: SM::PreProcess
mt: instance
fn: new
fs: new(input_file_name, include_path)
fd: 
pt: SM::PreProcess
mt: class
fn: add_html
fs: add_html(tag, name)
fd: Add to the sequences recognized as general markup
pt: SM::SimpleMarkup
mt: instance
fn: add_special
fs: add_special(pattern, name)
fd: "Add to other inline sequences. For example, we could add WikiWords using something like:"
pt: SM::SimpleMarkup
mt: instance
fn: add_word_pair
fs: add_word_pair(start, stop, name)
fd: Add to the sequences used to add formatting to an individual word (such as <b>bold</b>). Matching entries will generate attibutes that the output formatters can recognize by their name
pt: SM::SimpleMarkup
mt: instance
fn: content
fs: content()
fd: for debugging, we allow access to our line contents as text
pt: SM::SimpleMarkup
mt: instance
fn: convert
fs: convert(str, op)
fd: We take a string, split it into lines, work out the type of each line, and from there deduce groups of lines (for example all lines in a paragraph). We then invoke the output formatter using a Visitor to display the result
pt: SM::SimpleMarkup
mt: instance
fn: get_line_types
fs: get_line_types()
fd: for debugging, return the list of line types
pt: SM::SimpleMarkup
mt: instance
fn: new
fs: new()
fd: take a block of text and use various heuristics to determine it's structure (paragraphs, lists, and so on). Invoke an event handler as we identify significant chunks.
pt: SM::SimpleMarkup
mt: class
fn: new
fs: new(type, text)
fd: 
pt: SM::Special
mt: class
fn: to_s
fs: to_s()
fd: 
pt: SM::Special
mt: instance
fn: accept_blank_line
fs: accept_blank_line(am, fragment)
fd: 
pt: SM::ToFlow
mt: instance
fn: accept_heading
fs: accept_heading(am, fragment)
fd: 
pt: SM::ToFlow
mt: instance
fn: accept_list_end
fs: accept_list_end(am, fragment)
fd: 
pt: SM::ToFlow
mt: instance
fn: accept_list_item
fs: accept_list_item(am, fragment)
fd: 
pt: SM::ToFlow
mt: instance
fn: accept_list_start
fs: accept_list_start(am, fragment)
fd: 
pt: SM::ToFlow
mt: instance
fn: accept_paragraph
fs: accept_paragraph(am, fragment)
fd: 
pt: SM::ToFlow
mt: instance
fn: accept_rule
fs: accept_rule(am, fragment)
fd: 
pt: SM::ToFlow
mt: instance
fn: accept_verbatim
fs: accept_verbatim(am, fragment)
fd: 
pt: SM::ToFlow
mt: instance
fn: add_tag
fs: add_tag(name, start, stop)
fd: Add a new set of HTML tags for an attribute. We allow separate start and end tags for flexibility
pt: SM::ToFlow
mt: instance
fn: annotate
fs: annotate(tag)
fd: Given an HTML tag, decorate it with class information and the like if required. This is a no-op in the base class, but is overridden in HTML output classes that implement style sheets
pt: SM::ToFlow
mt: instance
fn: end_accepting
fs: end_accepting()
fd: 
pt: SM::ToFlow
mt: instance
fn: init_tags
fs: init_tags()
fd: Set up the standard mapping of attributes to HTML tags
pt: SM::ToFlow
mt: instance
fn: new
fs: new()
fd: 
pt: SM::ToFlow
mt: class
fn: start_accepting
fs: start_accepting()
fd: Here's the client side of the visitor pattern
pt: SM::ToFlow
mt: instance
fn: accept_blank_line
fs: accept_blank_line(am, fragment)
fd: 
pt: SM::ToHtml
mt: instance
fn: accept_heading
fs: accept_heading(am, fragment)
fd: 
pt: SM::ToHtml
mt: instance
fn: accept_list_end
fs: accept_list_end(am, fragment)
fd: 
pt: SM::ToHtml
mt: instance
fn: accept_list_item
fs: accept_list_item(am, fragment)
fd: 
pt: SM::ToHtml
mt: instance
fn: accept_list_start
fs: accept_list_start(am, fragment)
fd: 
pt: SM::ToHtml
mt: instance
fn: accept_paragraph
fs: accept_paragraph(am, fragment)
fd: 
pt: SM::ToHtml
mt: instance
fn: accept_rule
fs: accept_rule(am, fragment)
fd: 
pt: SM::ToHtml
mt: instance
fn: accept_verbatim
fs: accept_verbatim(am, fragment)
fd: 
pt: SM::ToHtml
mt: instance
fn: add_tag
fs: add_tag(name, start, stop)
fd: Add a new set of HTML tags for an attribute. We allow separate start and end tags for flexibility
pt: SM::ToHtml
mt: instance
fn: annotate
fs: annotate(tag)
fd: Given an HTML tag, decorate it with class information and the like if required. This is a no-op in the base class, but is overridden in HTML output classes that implement style sheets
pt: SM::ToHtml
mt: instance
fn: end_accepting
fs: end_accepting()
fd: 
pt: SM::ToHtml
mt: instance
fn: init_tags
fs: init_tags()
fd: Set up the standard mapping of attributes to HTML tags
pt: SM::ToHtml
mt: instance
fn: new
fs: new()
fd: 
pt: SM::ToHtml
mt: class
fn: start_accepting
fs: start_accepting()
fd: Here's the client side of the visitor pattern
pt: SM::ToHtml
mt: instance
fn: wrap
fs: wrap(txt, line_len = 76)
fd: This is a higher speed (if messier) version of wrap
pt: SM::ToHtml
mt: instance
fn: accept_blank_line
fs: accept_blank_line(am, fragment)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: accept_heading
fs: accept_heading(am, fragment)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: accept_list_end
fs: accept_list_end(am, fragment)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: accept_list_item
fs: accept_list_item(am, fragment)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: accept_list_start
fs: accept_list_start(am, fragment)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: accept_paragraph
fs: accept_paragraph(am, fragment)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: accept_rule
fs: accept_rule(am, fragment)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: accept_verbatim
fs: accept_verbatim(am, fragment)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: add_tag
fs: add_tag(name, start, stop)
fd: Add a new set of LaTeX tags for an attribute. We allow separate start and end tags for flexibility
pt: SM::ToLaTeX
mt: instance
fn: end_accepting
fs: end_accepting()
fd: 
pt: SM::ToLaTeX
mt: instance
fn: escape
fs: escape(str)
fd: Escape a LaTeX string
pt: SM::ToLaTeX
mt: instance
fn: init_tags
fs: init_tags()
fd: Set up the standard mapping of attributes to LaTeX
pt: SM::ToLaTeX
mt: instance
fn: l
fs: l(str)
fd: 
pt: SM::ToLaTeX
mt: class
fn: l
fs: l(arg)
fd: 
pt: SM::ToLaTeX
mt: instance
fn: new
fs: new()
fd: 
pt: SM::ToLaTeX
mt: class
fn: start_accepting
fs: start_accepting()
fd: Here's the client side of the visitor pattern
pt: SM::ToLaTeX
mt: instance
fn: wrap
fs: wrap(txt, line_len = 76)
fd: This is a higher speed (if messier) version of wrap
pt: SM::ToLaTeX
mt: instance
fn: add_text
fs: add_text(txt)
fd: 
pt: SM::Verbatim
mt: instance
fn: content
fs: content()
fd: 
pt: SOAP::Attachment
mt: instance
fn: contentid=
fs: contentid=(contentid)
fd: 
pt: SOAP::Attachment
mt: instance
fn: contentid
fs: contentid(obj)
fd: 
pt: SOAP::Attachment
mt: class
fn: contentid
fs: contentid()
fd: 
pt: SOAP::Attachment
mt: instance
fn: mime_contentid
fs: mime_contentid(obj)
fd: 
pt: SOAP::Attachment
mt: class
fn: mime_contentid
fs: mime_contentid()
fd: 
pt: SOAP::Attachment
mt: instance
fn: new
fs: new(string_or_readable = nil)
fd: 
pt: SOAP::Attachment
mt: class
fn: save
fs: save(filename)
fd: 
pt: SOAP::Attachment
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: SOAP::Attachment
mt: instance
fn: write
fs: write(out)
fd: 
pt: SOAP::Attachment
mt: instance
fn: decode_epilogue
fs: decode_epilogue()
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: instance
fn: decode_parent
fs: decode_parent(parent, node)
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: instance
fn: decode_prologue
fs: decode_prologue()
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: instance
fn: decode_tag
fs: decode_tag(ns, elename, attrs, parent)
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: instance
fn: decode_tag_end
fs: decode_tag_end(ns, node)
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: instance
fn: decode_text
fs: decode_text(ns, text)
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: instance
fn: encode_data
fs: encode_data(generator, ns, data, parent)
fd: encode interface.
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: instance
fn: encode_data_end
fs: encode_data_end(generator, ns, data, parent)
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: instance
fn: new
fs: new(charset = nil)
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler
mt: class
fn: new
fs: new()
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler::SOAPTemporalObject
mt: class
fn: as_nil
fs: as_nil()
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler::SOAPUnknown
mt: instance
fn: as_string
fs: as_string()
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler::SOAPUnknown
mt: instance
fn: as_struct
fs: as_struct()
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler::SOAPUnknown
mt: instance
fn: new
fs: new(handler, elename)
fd: 
pt: SOAP::EncodingStyle::ASPDotNetHandler::SOAPUnknown
mt: class
fn: decode_epilogue
fs: decode_epilogue()
fd: 
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: decode_prologue
fs: decode_prologue()
fd: 
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: decode_tag
fs: decode_tag(ns, name, attrs, parent)
fd: " decode interface.\n"
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: decode_tag_end
fs: decode_tag_end(ns, name)
fd: 
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: decode_text
fs: decode_text(ns, text)
fd: 
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: decode_typemap=
fs: decode_typemap=(definedtypes)
fd: 
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: each
fs: each()
fd: 
pt: SOAP::EncodingStyle::Handler
mt: class
fn: encode_data
fs: encode_data(generator, ns, data, parent)
fd: " encode interface.\n"
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: encode_data_end
fs: encode_data_end(generator, ns, data, parent)
fd: 
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: encode_epilogue
fs: encode_epilogue()
fd: 
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: encode_prologue
fs: encode_prologue()
fd: 
pt: SOAP::EncodingStyle::Handler
mt: instance
fn: handler
fs: handler(uri)
fd: 
pt: SOAP::EncodingStyle::Handler
mt: class
fn: new
fs: new(charset)
fd: 
pt: SOAP::EncodingStyle::Handler
mt: class
fn: uri
fs: uri()
fd: 
pt: SOAP::EncodingStyle::Handler
mt: class
fn: decode_attrs
fs: decode_attrs(ns, attrs)
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: decode_epilogue
fs: decode_epilogue()
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: decode_parent
fs: decode_parent(parent, node)
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: decode_prologue
fs: decode_prologue()
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: decode_tag
fs: decode_tag(ns, elename, attrs, parent)
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: decode_tag_end
fs: decode_tag_end(ns, node)
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: decode_text
fs: decode_text(ns, text)
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: encode_data
fs: encode_data(generator, ns, data, parent)
fd: encode interface.
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: encode_data_end
fs: encode_data_end(generator, ns, data, parent)
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: instance
fn: new
fs: new(charset = nil)
fd: 
pt: SOAP::EncodingStyle::LiteralHandler
mt: class
fn: new
fs: new()
fd: 
pt: SOAP::EncodingStyle::LiteralHandler::SOAPTemporalObject
mt: class
fn: as_element
fs: as_element()
fd: 
pt: SOAP::EncodingStyle::LiteralHandler::SOAPUnknown
mt: instance
fn: as_nil
fs: as_nil()
fd: 
pt: SOAP::EncodingStyle::LiteralHandler::SOAPUnknown
mt: instance
fn: as_string
fs: as_string()
fd: 
pt: SOAP::EncodingStyle::LiteralHandler::SOAPUnknown
mt: instance
fn: new
fs: new(handler, elename, extraattr)
fd: 
pt: SOAP::EncodingStyle::LiteralHandler::SOAPUnknown
mt: class
fn: decode_epilogue
fs: decode_epilogue()
fd: 
pt: SOAP::EncodingStyle::SOAPHandler
mt: instance
fn: decode_parent
fs: decode_parent(parent, node)
fd: 
pt: SOAP::EncodingStyle::SOAPHandler
mt: instance
fn: decode_prologue
fs: decode_prologue()
fd: 
pt: SOAP::EncodingStyle::SOAPHandler
mt: instance
fn: decode_tag
fs: decode_tag(ns, elename, attrs, parent)
fd: 
pt: SOAP::EncodingStyle::SOAPHandler
mt: instance
fn: decode_tag_end
fs: decode_tag_end(ns, node)
fd: 
pt: SOAP::EncodingStyle::SOAPHandler
mt: instance
fn: decode_text
fs: decode_text(ns, text)
fd: 
pt: SOAP::EncodingStyle::SOAPHandler
mt: instance
fn: encode_data
fs: encode_data(generator, ns, data, parent)
fd: encode interface.
pt: SOAP::EncodingStyle::SOAPHandler
mt: instance
fn: encode_data_end
fs: encode_data_end(generator, ns, data, parent)
fd: 
pt: SOAP::EncodingStyle::SOAPHandler
mt: instance
fn: new
fs: new(charset = nil)
fd: 
pt: SOAP::EncodingStyle::SOAPHandler
mt: class
fn: new
fs: new()
fd: 
pt: SOAP::EncodingStyle::SOAPHandler::SOAPTemporalObject
mt: class
fn: as_nil
fs: as_nil()
fd: 
pt: SOAP::EncodingStyle::SOAPHandler::SOAPUnknown
mt: instance
fn: as_string
fs: as_string()
fd: 
pt: SOAP::EncodingStyle::SOAPHandler::SOAPUnknown
mt: instance
fn: as_struct
fs: as_struct()
fd: 
pt: SOAP::EncodingStyle::SOAPHandler::SOAPUnknown
mt: instance
fn: new
fs: new(handler, elename, type, extraattr)
fd: 
pt: SOAP::EncodingStyle::SOAPHandler::SOAPUnknown
mt: class
fn: getenv
fs: getenv(name)
fd: 
pt: SOAP::Env
mt: class
fn: new
fs: new(fault)
fd: 
pt: SOAP::FaultError
mt: class
fn: to_s
fs: to_s()
fd: 
pt: SOAP::FaultError
mt: instance
fn: get_content
fs: get_content(url, header = {})
fd: 
pt: SOAP
mt: instance
fn: new
fs: new(elename)
fd: 
pt: SOAP::Header::Handler
mt: class
fn: on_inbound
fs: on_inbound(header, mustunderstand = false)
fd: Given header is a SOAPHeaderItem or nil.
pt: SOAP::Header::Handler
mt: instance
fn: on_inbound_headeritem
fs: on_inbound_headeritem(header)
fd: 
pt: SOAP::Header::Handler
mt: instance
fn: on_outbound
fs: on_outbound()
fd: Should return a SOAP/OM, a SOAPHeaderItem or nil.
pt: SOAP::Header::Handler
mt: instance
fn: on_outbound_headeritem
fs: on_outbound_headeritem()
fd: 
pt: SOAP::Header::Handler
mt: instance
fn: add
fs: add(handler)
fd: 
pt: SOAP::Header::HandlerSet
mt: instance
fn: delete
fs: delete(handler)
fd: 
pt: SOAP::Header::HandlerSet
mt: instance
fn: dup
fs: dup()
fd: 
pt: SOAP::Header::HandlerSet
mt: instance
fn: include?
fs: include?(handler)
fd: 
pt: SOAP::Header::HandlerSet
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::Header::HandlerSet
mt: class
fn: on_inbound
fs: on_inbound(headers)
fd: "headers: SOAPHeaderItem enumerable object"
pt: SOAP::Header::HandlerSet
mt: instance
fn: on_outbound
fs: on_outbound()
fd: "returns: Array of SOAPHeaderItem"
pt: SOAP::Header::HandlerSet
mt: instance
fn: new
fs: new(elename)
fd: 
pt: SOAP::Header::SimpleHandler
mt: class
fn: on_inbound
fs: on_inbound(header, mustunderstand)
fd: 
pt: SOAP::Header::SimpleHandler
mt: instance
fn: on_outbound
fs: on_outbound()
fd: 
pt: SOAP::Header::SimpleHandler
mt: instance
fn: on_simple_inbound
fs: on_simple_inbound(header, mustunderstand)
fd: Given header is a Hash, String or nil.
pt: SOAP::Header::SimpleHandler
mt: instance
fn: on_simple_outbound
fs: on_simple_outbound()
fd: Should return a Hash, String or nil.
pt: SOAP::Header::SimpleHandler
mt: instance
fn: cert_from_file
fs: cert_from_file(filename)
fd: 
pt: SOAP::HTTPConfigLoader
mt: instance
fn: key_from_file
fs: key_from_file(filename)
fd: 
pt: SOAP::HTTPConfigLoader
mt: instance
fn: set_basic_auth
fs: set_basic_auth(client, basic_auth)
fd: 
pt: SOAP::HTTPConfigLoader
mt: instance
fn: set_options
fs: set_options(client, options)
fd: 
pt: SOAP::HTTPConfigLoader
mt: instance
fn: set_ssl_config
fs: set_ssl_config(client, ssl_config)
fd: 
pt: SOAP::HTTPConfigLoader
mt: instance
fn: ssl_config_int
fs: ssl_config_int(value)
fd: 
pt: SOAP::HTTPConfigLoader
mt: instance
fn: accept_encoding_gzip=
fs: accept_encoding_gzip=(allow)
fd: 
pt: SOAP::HTTPStreamHandler
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: SOAP::HTTPStreamHandler
mt: instance
fn: new
fs: new(options)
fd: 
pt: SOAP::HTTPStreamHandler
mt: class
fn: reset
fs: reset(endpoint_url = nil)
fd: 
pt: SOAP::HTTPStreamHandler
mt: instance
fn: send
fs: send(endpoint_url, conn_data, soapaction = nil, charset = @charset)
fd: 
pt: SOAP::HTTPStreamHandler
mt: instance
fn: test_loopback_response
fs: test_loopback_response()
fd: 
pt: SOAP::HTTPStreamHandler
mt: instance
fn: new
fs: new(allow_original_mapping = false)
fd: 
pt: SOAP::Mapping::ArrayFactory_
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: is converted to Array of Array, not 2-D Array.
pt: SOAP::Mapping::ArrayFactory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::ArrayFactory_
mt: instance
fn: ary2md
fs: ary2md(ary, rank, type_ns = XSD::Namespace, typename = XSD::AnyTypeLiteral, registry = nil, opt = EMPTY_OPT)
fd: 
pt: SOAP::Mapping
mt: class
fn: ary2soap
fs: ary2soap(ary, type_ns = XSD::Namespace, typename = XSD::AnyTypeLiteral, registry = nil, opt = EMPTY_OPT)
fd: 
pt: SOAP::Mapping
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::AttachmentFactory
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::AttachmentFactory
mt: instance
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::Base64Factory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::Base64Factory_
mt: instance
fn: new
fs: new(allow_original_mapping = false)
fd: 
pt: SOAP::Mapping::BasetypeFactory_
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::BasetypeFactory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::BasetypeFactory_
mt: instance
fn: class2element
fs: class2element(klass)
fd: 
pt: SOAP::Mapping
mt: class
fn: class2qname
fs: class2qname(klass)
fd: 
pt: SOAP::Mapping
mt: class
fn: class_from_name
fs: class_from_name(name, lenient = false)
fd: 
pt: SOAP::Mapping
mt: class
fn: const_from_name
fs: const_from_name(name, lenient = false)
fd: 
pt: SOAP::Mapping
mt: class
fn: create_empty_object
fs: create_empty_object(klass)
fd: ruby/1.7 or later.
pt: SOAP::Mapping
mt: class
fn: new
fs: new(allow_original_mapping = false)
fd: 
pt: SOAP::Mapping::DateTimeFactory_
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::DateTimeFactory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::DateTimeFactory_
mt: instance
fn: define_attr_accessor
fs: define_attr_accessor(obj, name, getterproc, setterproc = nil)
fd: 
pt: SOAP::Mapping
mt: class
fn: define_singleton_method
fs: define_singleton_method(obj, name, &block)
fd: 
pt: SOAP::Mapping
mt: class
fn: elename2name
fs: elename2name(name)
fd: 
pt: SOAP::Mapping
mt: class
fn: new
fs: new()
fd: 
pt: SOAP::Mapping::Factory
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::Factory
mt: instance
fn: setiv2obj
fs: setiv2obj(obj, node, map)
fd: 
pt: SOAP::Mapping::Factory
mt: instance
fn: setiv2soap
fs: setiv2soap(node, obj, map)
fd: 
pt: SOAP::Mapping::Factory
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::Factory
mt: instance
fn: fault2exception
fs: fault2exception(fault, registry = nil)
fd: 
pt: SOAP::Mapping
mt: class
fn: get_attribute
fs: get_attribute(obj, attr_name)
fd: 
pt: SOAP::Mapping
mt: class
fn: new
fs: new(allow_original_mapping = false)
fd: 
pt: SOAP::Mapping::HashFactory_
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::HashFactory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::HashFactory_
mt: instance
fn: module_from_name
fs: module_from_name(name, lenient = false)
fd: 
pt: SOAP::Mapping
mt: class
fn: name2elename
fs: name2elename(name)
fd: "Allow only (Letter | '_') (Letter | Digit | '-' | '_')* here. Caution: '.' is not allowed here. To follow XML spec., it should be NCName."
pt: SOAP::Mapping
mt: class
fn: obj2element
fs: obj2element(obj)
fd: 
pt: SOAP::Mapping
mt: class
fn: obj2soap
fs: obj2soap(obj, registry = nil, type = nil, opt = EMPTY_OPT)
fd: 
pt: SOAP::Mapping
mt: class
fn: inspect
fs: inspect()
fd: 
pt: SOAP::Mapping::Object
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::Mapping::Object
mt: class
fn: add
fs: add(obj_class, soap_class, factory, info = nil)
fd: 
pt: SOAP::Mapping::Registry
mt: instance
fn: find_mapped_obj_class
fs: find_mapped_obj_class(soap_class)
fd: 
pt: SOAP::Mapping::Registry
mt: instance
fn: find_mapped_soap_class
fs: find_mapped_soap_class(obj_class)
fd: 
pt: SOAP::Mapping::Registry
mt: instance
fn: add
fs: add(obj_class, soap_class, factory, info)
fd: Give priority to latter entry.
pt: SOAP::Mapping::Registry::Map
mt: instance
fn: clear
fs: clear()
fd: 
pt: SOAP::Mapping::Registry::Map
mt: instance
fn: find_mapped_obj_class
fs: find_mapped_obj_class(target_soap_class)
fd: 
pt: SOAP::Mapping::Registry::Map
mt: instance
fn: find_mapped_soap_class
fs: find_mapped_soap_class(target_obj_class)
fd: 
pt: SOAP::Mapping::Registry::Map
mt: instance
fn: init
fs: init(init_map = [])
fd: Give priority to former entry.
pt: SOAP::Mapping::Registry::Map
mt: instance
fn: new
fs: new(registry)
fd: 
pt: SOAP::Mapping::Registry::Map
mt: class
fn: obj2soap
fs: obj2soap(obj)
fd: 
pt: SOAP::Mapping::Registry::Map
mt: instance
fn: soap2obj
fs: soap2obj(node, klass = nil)
fd: 
pt: SOAP::Mapping::Registry::Map
mt: instance
fn: new
fs: new(config = {})
fd: 
pt: SOAP::Mapping::Registry
mt: class
fn: obj2soap
fs: obj2soap(obj, type_qname = nil)
fd: general Registry ignores type_qname
pt: SOAP::Mapping::Registry
mt: instance
fn: set
fs: set(obj_class, soap_class, factory, info = nil)
fd: "Alias for #add"
pt: SOAP::Mapping::Registry
mt: instance
fn: soap2obj
fs: soap2obj(node, klass = nil)
fd: 
pt: SOAP::Mapping::Registry
mt: instance
fn: new
fs: new(config = {})
fd: 
pt: SOAP::Mapping::RubytypeFactory
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::RubytypeFactory
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::RubytypeFactory
mt: instance
fn: schema_attribute_definition
fs: schema_attribute_definition(klass)
fd: 
pt: SOAP::Mapping
mt: class
fn: schema_element_definition
fs: schema_element_definition(klass)
fd: 
pt: SOAP::Mapping
mt: class
fn: schema_ns_definition
fs: schema_ns_definition(klass)
fd: 
pt: SOAP::Mapping
mt: class
fn: schema_type_definition
fs: schema_type_definition(klass)
fd: 
pt: SOAP::Mapping
mt: class
fn: set_attributes
fs: set_attributes(obj, values)
fd: 
pt: SOAP::Mapping
mt: class
fn: soap2obj
fs: soap2obj(node, registry = nil, klass = nil, opt = EMPTY_OPT)
fd: 
pt: SOAP::Mapping
mt: class
fn: new
fs: new(e)
fd: 
pt: SOAP::Mapping::SOAPException
mt: class
fn: to_e
fs: to_e()
fd: 
pt: SOAP::Mapping::SOAPException
mt: instance
fn: new
fs: new(allow_original_mapping = false)
fd: 
pt: SOAP::Mapping::StringFactory_
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::StringFactory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::StringFactory_
mt: instance
fn: mark_marshalled_obj
fs: mark_marshalled_obj(obj, soap_obj)
fd: 
pt: SOAP::Mapping::TraverseSupport
mt: instance
fn: mark_unmarshalled_obj
fs: mark_unmarshalled_obj(node, obj)
fd: 
pt: SOAP::Mapping::TraverseSupport
mt: instance
fn: new
fs: new(allow_original_mapping = false)
fd: 
pt: SOAP::Mapping::TypedArrayFactory_
mt: class
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::TypedArrayFactory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::TypedArrayFactory_
mt: instance
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::TypedStructFactory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::TypedStructFactory_
mt: instance
fn: obj2soap
fs: obj2soap(soap_class, obj, info, map)
fd: 
pt: SOAP::Mapping::URIFactory_
mt: instance
fn: soap2obj
fs: soap2obj(obj_class, node, info, map)
fd: 
pt: SOAP::Mapping::URIFactory_
mt: instance
fn: new
fs: new(definedtypes = XSD::NamedElements::Empty)
fd: 
pt: SOAP::Mapping::WSDLEncodedRegistry
mt: class
fn: obj2soap
fs: obj2soap(obj, qname = nil)
fd: 
pt: SOAP::Mapping::WSDLEncodedRegistry
mt: instance
fn: soap2obj
fs: soap2obj(node, obj_class = nil)
fd: "map anything for now: must refer WSDL while mapping. [ToDo]"
pt: SOAP::Mapping::WSDLEncodedRegistry
mt: instance
fn: new
fs: new(definedtypes = XSD::NamedElements::Empty, definedelements = XSD::NamedElements::Empty)
fd: 
pt: SOAP::Mapping::WSDLLiteralRegistry
mt: class
fn: obj2soap
fs: obj2soap(obj, qname)
fd: 
pt: SOAP::Mapping::WSDLLiteralRegistry
mt: instance
fn: soap2obj
fs: soap2obj(node, obj_class = nil)
fd: node should be a SOAPElement
pt: SOAP::Mapping::WSDLLiteralRegistry
mt: instance
fn: dump
fs: dump(obj, io = nil)
fd: 
pt: SOAP::Marshal
mt: class
fn: load
fs: load(stream)
fd: 
pt: SOAP::Marshal
mt: class
fn: marshal
fs: marshal(obj, mapping_registry = MarshalMappingRegistry, io = nil)
fd: 
pt: SOAP::Marshal
mt: class
fn: unmarshal
fs: unmarshal(stream, mapping_registry = MarshalMappingRegistry)
fd: 
pt: SOAP::Marshal
mt: class
fn: add_attachment
fs: add_attachment(attach)
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: add_part
fs: add_part(content)
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: boundary
fs: boundary()
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: close
fs: close()
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: content_str
fs: content_str()
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: has_parts?
fs: has_parts?()
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::MIMEMessage::Header
mt: class
fn: to_s
fs: to_s()
fd: 
pt: SOAP::MIMEMessage::Header
mt: instance
fn: add
fs: add(key, value)
fd: 
pt: SOAP::MIMEMessage::Headers
mt: instance
fn: parse
fs: parse(str)
fd: 
pt: SOAP::MIMEMessage::Headers
mt: class
fn: parse
fs: parse(str)
fd: 
pt: SOAP::MIMEMessage::Headers
mt: instance
fn: parse_line
fs: parse_line(line)
fd: 
pt: SOAP::MIMEMessage::Headers
mt: instance
fn: parse_rhs
fs: parse_rhs(str)
fd: 
pt: SOAP::MIMEMessage::Headers
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: SOAP::MIMEMessage::Headers
mt: instance
fn: headers_str
fs: headers_str()
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::MIMEMessage
mt: class
fn: parse
fs: parse(head, str)
fd: 
pt: SOAP::MIMEMessage
mt: class
fn: parse
fs: parse(head, str)
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: contentid
fs: contentid()
fd: 
pt: SOAP::MIMEMessage::Part
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::MIMEMessage::Part
mt: class
fn: parse
fs: parse(str)
fd: 
pt: SOAP::MIMEMessage::Part
mt: class
fn: parse
fs: parse(str)
fd: 
pt: SOAP::MIMEMessage::Part
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: SOAP::MIMEMessage::Part
mt: instance
fn: root
fs: root()
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: SOAP::MIMEMessage
mt: instance
fn: new
fs: new(proxy = nil, agent = nil)
fd: 
pt: SOAP
mt: class
fn: characters
fs: characters(text)
fd: 
pt: SOAP::Parser
mt: instance
fn: charset
fs: charset()
fd: 
pt: SOAP::Parser
mt: instance
fn: end_element
fs: end_element(name)
fd: 
pt: SOAP::Parser
mt: instance
fn: new
fs: new(opt = {})
fd: 
pt: SOAP::Parser
mt: class
fn: parse
fs: parse(string_or_readable)
fd: 
pt: SOAP::Parser
mt: instance
fn: new
fs: new(ns, name, node, encodingstyle)
fd: 
pt: SOAP::Parser::ParseFrame
mt: class
fn: node=
fs: node=(node)
fd: 
pt: SOAP::Parser::ParseFrame
mt: instance
fn: new
fs: new(node)
fd: 
pt: SOAP::Parser::ParseFrame::NodeContainer
mt: class
fn: node
fs: node()
fd: 
pt: SOAP::Parser::ParseFrame::NodeContainer
mt: instance
fn: replace_node
fs: replace_node(node)
fd: 
pt: SOAP::Parser::ParseFrame::NodeContainer
mt: instance
fn: start_element
fs: start_element(name, attrs)
fd: 
pt: SOAP::Parser
mt: instance
fn: post
fs: post(url, req_body, header = {})
fd: 
pt: SOAP
mt: instance
fn: default_parser_option=
fs: default_parser_option=(rhs)
fd: 
pt: SOAP::Processor
mt: class
fn: default_parser_option
fs: default_parser_option()
fd: 
pt: SOAP::Processor
mt: class
fn: marshal
fs: marshal(env, opt = {}, io = nil)
fd: 
pt: SOAP::Processor
mt: class
fn: unmarshal
fs: unmarshal(stream, opt = {})
fd: 
pt: SOAP::Processor
mt: class
fn: add_hook
fs: add_hook(name = nil, cascade = false, &hook)
fd: "name: a Symbol, String or an Array; nil means hook to the root cascade: true/false; for cascading hook of sub key hook: block which will be called with 2 args, name and value"
pt: SOAP::Property
mt: instance
fn: each
fs: each()
fd: 
pt: SOAP::Property
mt: instance
fn: empty?
fs: empty?()
fd: 
pt: SOAP::Property
mt: instance
fn: keys
fs: keys()
fd: 
pt: SOAP::Property
mt: instance
fn: load
fs: load(stream)
fd: 
pt: SOAP::Property
mt: class
fn: load
fs: load(stream)
fd: 
pt: SOAP::Property
mt: instance
fn: loadproperty
fs: loadproperty(propname)
fd: 
pt: SOAP::Property
mt: class
fn: loadproperty
fs: loadproperty(propname)
fd: find property from $:.
pt: SOAP::Property
mt: instance
fn: lock
fs: lock(cascade = false)
fd: 
pt: SOAP::Property
mt: instance
fn: locked?
fs: locked?()
fd: 
pt: SOAP::Property
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::Property
mt: class
fn: unlock
fs: unlock(cascade = false)
fd: 
pt: SOAP::Property
mt: instance
fn: const_from_name
fs: const_from_name(fqname)
fd: 
pt: SOAP::Property::Util
mt: instance
fn: require_from_name
fs: require_from_name(fqname)
fd: 
pt: SOAP::Property::Util
mt: instance
fn: values
fs: values()
fd: 
pt: SOAP::Property
mt: instance
fn: proxy=
fs: proxy=(proxy)
fd: 
pt: SOAP
mt: instance
fn: reset
fs: reset(url)
fd: 
pt: SOAP
mt: instance
fn: reset_all
fs: reset_all()
fd: 
pt: SOAP
mt: instance
fn: new
fs: new(res)
fd: 
pt: SOAP::Response
mt: class
fn: add_document_operation
fs: add_document_operation(receiver, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_headerhandler
fs: add_headerhandler(obj)
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_method
fs: add_method(obj, name, *param)
fd: "Alias for #add_rpc_method"
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_method_as
fs: add_method_as(obj, name, name_as, *param)
fd: "Alias for #add_rpc_method_as"
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_method_with_namespace
fs: add_method_with_namespace(namespace, obj, name, *param)
fd: "Alias for #add_rpc_method_with_namespace"
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_method_with_namespace_as
fs: add_method_with_namespace_as(namespace, obj, name, name_as, *param)
fd: "Alias for #add_rpc_method_with_namespace_as"
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_rpc_headerhandler
fs: add_rpc_headerhandler(obj)
fd: "Alias for #add_headerhandler"
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_rpc_method
fs: add_rpc_method(obj, name, *param)
fd: method entry interface
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_rpc_method_as
fs: add_rpc_method_as(obj, name, name_as, *param)
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_rpc_method_with_namespace
fs: add_rpc_method_with_namespace(namespace, obj, name, *param)
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_rpc_method_with_namespace_as
fs: add_rpc_method_with_namespace_as(namespace, obj, name, name_as, *param)
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_rpc_operation
fs: add_rpc_operation(receiver, qname, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_rpc_servant
fs: add_rpc_servant(obj, namespace = @default_namespace)
fd: servant entry interface
pt: SOAP::RPC::CGIStub
mt: instance
fn: add_servant
fs: add_servant(obj, namespace = @default_namespace)
fd: "Alias for #add_rpc_servant"
pt: SOAP::RPC::CGIStub
mt: instance
fn: generate_explicit_type=
fs: generate_explicit_type=(generate_explicit_type)
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: generate_explicit_type
fs: generate_explicit_type()
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: mapping_registry=
fs: mapping_registry=(value)
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: mapping_registry
fs: mapping_registry()
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: new
fs: new(appname, default_namespace)
fd: 
pt: SOAP::RPC::CGIStub
mt: class
fn: on_init
fs: on_init()
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: set_fcgi_request
fs: set_fcgi_request(request)
fd: 
pt: SOAP::RPC::CGIStub
mt: instance
fn: meta_vars
fs: meta_vars()
fd: 
pt: SOAP::RPC::CGIStub::SOAPFCGIRequest
mt: instance
fn: new
fs: new(request)
fd: 
pt: SOAP::RPC::CGIStub::SOAPFCGIRequest
mt: class
fn: meta_vars
fs: meta_vars()
fd: 
pt: SOAP::RPC::CGIStub::SOAPRequest
mt: instance
fn: meta_vars
fs: meta_vars()
fd: 
pt: SOAP::RPC::CGIStub::SOAPStdinRequest
mt: instance
fn: new
fs: new(stream)
fd: 
pt: SOAP::RPC::CGIStub::SOAPStdinRequest
mt: class
fn: defined_methods
fs: defined_methods(obj)
fd: 
pt: SOAP::RPC
mt: class
fn: add_document_method
fs: add_document_method(name, soapaction, req_qname, res_qname)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: add_document_operation
fs: add_document_operation(soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: add_method
fs: add_method(name, *params)
fd: "Alias for #add_rpc_method"
pt: SOAP::RPC::Driver
mt: instance
fn: add_method_as
fs: add_method_as(name, name_as, *params)
fd: "Alias for #add_rpc_method_as"
pt: SOAP::RPC::Driver
mt: instance
fn: add_method_with_soapaction
fs: add_method_with_soapaction(name, soapaction, *params)
fd: "Alias for #add_rpc_method_with_soapaction"
pt: SOAP::RPC::Driver
mt: instance
fn: add_method_with_soapaction_as
fs: add_method_with_soapaction_as(name, name_as, soapaction, *params)
fd: "Alias for #add_rpc_method_with_soapaction_as"
pt: SOAP::RPC::Driver
mt: instance
fn: add_rpc_method
fs: add_rpc_method(name, *params)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: add_rpc_method_as
fs: add_rpc_method_as(name, name_as, *params)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: add_rpc_method_with_soapaction
fs: add_rpc_method_with_soapaction(name, soapaction, *params)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: add_rpc_method_with_soapaction_as
fs: add_rpc_method_with_soapaction_as(name, name_as, soapaction, *params)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: add_rpc_operation
fs: add_rpc_operation(qname, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: call
fs: call(name, *params)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: httpproxy=
fs: httpproxy=(httpproxy)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: httpproxy
fs: httpproxy()
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: invoke
fs: invoke(headers, body)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: loadproperty
fs: loadproperty(propertyname)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: mandatorycharset=
fs: mandatorycharset=(mandatorycharset)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: mandatorycharset
fs: mandatorycharset()
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: new
fs: new(endpoint_url, namespace = nil, soapaction = nil)
fd: 
pt: SOAP::RPC::Driver
mt: class
fn: wiredump_dev=
fs: wiredump_dev=(wiredump_dev)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: wiredump_dev
fs: wiredump_dev()
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: wiredump_file_base=
fs: wiredump_file_base=(wiredump_file_base)
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: wiredump_file_base
fs: wiredump_file_base()
fd: 
pt: SOAP::RPC::Driver
mt: instance
fn: add_document_method
fs: add_document_method(obj, soapaction, name, req_qnames, res_qnames)
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_document_operation
fs: add_document_operation(receiver, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_document_request_operation
fs: add_document_request_operation(factory, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_headerhandler
fs: add_headerhandler(obj)
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_method
fs: add_method(obj, name, *param)
fd: "Alias for #add_rpc_method"
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_method_as
fs: add_method_as(obj, name, name_as, *param)
fd: "Alias for #add_rpc_method_as"
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_request_headerhandler
fs: add_request_headerhandler(factory)
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_rpc_headerhandler
fs: add_rpc_headerhandler(obj)
fd: "Alias for #add_headerhandler"
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_rpc_method
fs: add_rpc_method(obj, name, *param)
fd: method entry interface
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_rpc_method_as
fs: add_rpc_method_as(obj, name, name_as, *param)
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_rpc_operation
fs: add_rpc_operation(receiver, qname, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_rpc_request_operation
fs: add_rpc_request_operation(factory, qname, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_rpc_request_servant
fs: add_rpc_request_servant(factory, namespace = @default_namespace)
fd: servant entry interface
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_rpc_servant
fs: add_rpc_servant(obj, namespace = @default_namespace)
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: generate_explicit_type=
fs: generate_explicit_type=(generate_explicit_type)
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: generate_explicit_type
fs: generate_explicit_type()
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: mapping_registry=
fs: mapping_registry=(mapping_registry)
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: mapping_registry
fs: mapping_registry()
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: new
fs: new(config)
fd: 
pt: SOAP::RPC::HTTPServer
mt: class
fn: on_init
fs: on_init()
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: shutdown
fs: shutdown()
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: status
fs: status()
fd: 
pt: SOAP::RPC::HTTPServer
mt: instance
fn: add_document_method
fs: add_document_method(soapaction, name, param_def, opt = {})
fd: "Alias for #add_document_operation"
pt: SOAP::RPC::Proxy
mt: instance
fn: add_document_operation
fs: add_document_operation(soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: add_method
fs: add_method(qname, soapaction, name, param_def, opt = {})
fd: "Alias for #add_rpc_operation"
pt: SOAP::RPC::Proxy
mt: instance
fn: add_rpc_method
fs: add_rpc_method(qname, soapaction, name, param_def, opt = {})
fd: "Alias for #add_rpc_operation"
pt: SOAP::RPC::Proxy
mt: instance
fn: add_rpc_operation
fs: add_rpc_operation(qname, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: call
fs: call(name, *params)
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: check_fault
fs: check_fault(body)
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: endpoint_url=
fs: endpoint_url=(endpoint_url)
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: endpoint_url
fs: endpoint_url()
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: invoke
fs: invoke(req_header, req_body, opt = nil)
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: new
fs: new(endpoint_url, soapaction, options)
fd: 
pt: SOAP::RPC::Proxy
mt: class
fn: new
fs: new(soapaction, param_def, opt)
fd: 
pt: SOAP::RPC::Proxy::Operation
mt: class
fn: raise_fault
fs: raise_fault(e, mapping_registry, literal_mapping_registry)
fd: 
pt: SOAP::RPC::Proxy::Operation
mt: instance
fn: request_body
fs: request_body(values, mapping_registry, literal_mapping_registry, opt)
fd: 
pt: SOAP::RPC::Proxy::Operation
mt: instance
fn: request_default_encodingstyle
fs: request_default_encodingstyle()
fd: 
pt: SOAP::RPC::Proxy::Operation
mt: instance
fn: response_default_encodingstyle
fs: response_default_encodingstyle()
fd: 
pt: SOAP::RPC::Proxy::Operation
mt: instance
fn: response_obj
fs: response_obj(body, mapping_registry, literal_mapping_registry, opt)
fd: 
pt: SOAP::RPC::Proxy::Operation
mt: instance
fn: reset_stream
fs: reset_stream()
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: route
fs: route(req_header, req_body, reqopt, resopt)
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: set_wiredump_file_base
fs: set_wiredump_file_base(wiredump_file_base)
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: test_loopback_response
fs: test_loopback_response()
fd: 
pt: SOAP::RPC::Proxy
mt: instance
fn: add_document_method
fs: add_document_method(receiver, soapaction, name, param_def, opt = {})
fd: "Alias for #add_document_operation"
pt: SOAP::RPC::Router
mt: instance
fn: add_document_operation
fs: add_document_operation(receiver, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::Router
mt: instance
fn: add_document_request_operation
fs: add_document_request_operation(factory, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::Router
mt: instance
fn: add_headerhandler
fs: add_headerhandler(handler)
fd: 
pt: SOAP::RPC::Router
mt: instance
fn: add_method
fs: add_method(receiver, qname, soapaction, name, param_def, opt = {})
fd: "Alias for #add_rpc_operation"
pt: SOAP::RPC::Router
mt: instance
fn: add_request_headerhandler
fs: add_request_headerhandler(factory)
fd: header handler interface
pt: SOAP::RPC::Router
mt: instance
fn: add_rpc_method
fs: add_rpc_method(receiver, qname, soapaction, name, param_def, opt = {})
fd: "Alias for #add_rpc_operation"
pt: SOAP::RPC::Router
mt: instance
fn: add_rpc_operation
fs: add_rpc_operation(receiver, qname, soapaction, name, param_def, opt = {})
fd: operation definition interface
pt: SOAP::RPC::Router
mt: instance
fn: add_rpc_request_operation
fs: add_rpc_request_operation(factory, qname, soapaction, name, param_def, opt = {})
fd: 
pt: SOAP::RPC::Router
mt: instance
fn: add_rpc_request_servant
fs: add_rpc_request_servant(factory, namespace)
fd: servant definition interface
pt: SOAP::RPC::Router
mt: instance
fn: add_rpc_servant
fs: add_rpc_servant(obj, namespace)
fd: 
pt: SOAP::RPC::Router
mt: instance
fn: add_servant
fs: add_servant(obj, namespace)
fd: "Alias for #add_rpc_servant"
pt: SOAP::RPC::Router
mt: instance
fn: new
fs: new(soapaction, receiver, name, param_def, opt)
fd: 
pt: SOAP::RPC::Router::ApplicationScopeOperation
mt: class
fn: create_fault_response
fs: create_fault_response(e)
fd: Create fault response string.
pt: SOAP::RPC::Router
mt: instance
fn: new
fs: new(actor)
fd: 
pt: SOAP::RPC::Router
mt: class
fn: call
fs: call(body, mapping_registry, literal_mapping_registry, opt)
fd: 
pt: SOAP::RPC::Router::Operation
mt: instance
fn: new
fs: new(soapaction, name, param_def, opt)
fd: 
pt: SOAP::RPC::Router::Operation
mt: class
fn: request_default_encodingstyle
fs: request_default_encodingstyle()
fd: 
pt: SOAP::RPC::Router::Operation
mt: instance
fn: response_default_encodingstyle
fs: response_default_encodingstyle()
fd: 
pt: SOAP::RPC::Router::Operation
mt: instance
fn: new
fs: new(soapaction, receiver_factory, name, param_def, opt)
fd: 
pt: SOAP::RPC::Router::RequestScopeOperation
mt: class
fn: route
fs: route(conn_data)
fd: 
pt: SOAP::RPC::Router
mt: instance
fn: add_servant
fs: add_servant(obj, namespace)
fd: for backward compatibility
pt: SOAP::RPC::SOAPlet
mt: instance
fn: allow_content_encoding_gzip=
fs: allow_content_encoding_gzip=(allow)
fd: 
pt: SOAP::RPC::SOAPlet
mt: instance
fn: app_scope_router
fs: app_scope_router()
fd: for backward compatibility
pt: SOAP::RPC::SOAPlet
mt: instance
fn: do_GET
fs: do_GET(req, res)
fd: 
pt: SOAP::RPC::SOAPlet
mt: instance
fn: do_POST
fs: do_POST(req, res)
fd: 
pt: SOAP::RPC::SOAPlet
mt: instance
fn: get_instance
fs: get_instance(config, *options)
fd: Servlet interfaces for WEBrick.
pt: SOAP::RPC::SOAPlet
mt: instance
fn: new
fs: new(router = nil)
fd: 
pt: SOAP::RPC::SOAPlet
mt: class
fn: require_path_info?
fs: require_path_info?()
fd: 
pt: SOAP::RPC::SOAPlet
mt: instance
fn: create_doc_param_def
fs: create_doc_param_def(req_qnames, res_qnames)
fd: 
pt: SOAP::RPC::SOAPMethod
mt: class
fn: create_rpc_param_def
fs: create_rpc_param_def(param_names)
fd: 
pt: SOAP::RPC::SOAPMethod
mt: class
fn: derive_rpc_param_def
fs: derive_rpc_param_def(obj, name, *param)
fd: 
pt: SOAP::RPC::SOAPMethod
mt: class
fn: have_outparam?
fs: have_outparam?()
fd: 
pt: SOAP::RPC::SOAPMethod
mt: instance
fn: input_params
fs: input_params()
fd: 
pt: SOAP::RPC::SOAPMethod
mt: instance
fn: new
fs: new(qname, param_def = nil)
fd: 
pt: SOAP::RPC::SOAPMethod
mt: class
fn: output_params
fs: output_params()
fd: 
pt: SOAP::RPC::SOAPMethod
mt: instance
fn: param_count
fs: param_count(param_def, *type)
fd: 
pt: SOAP::RPC::SOAPMethod
mt: class
fn: set_outparam
fs: set_outparam(params)
fd: 
pt: SOAP::RPC::SOAPMethod
mt: instance
fn: set_param
fs: set_param(params)
fd: 
pt: SOAP::RPC::SOAPMethod
mt: instance
fn: create_method_response
fs: create_method_response(response_name = nil)
fd: 
pt: SOAP::RPC::SOAPMethodRequest
mt: instance
fn: create_request
fs: create_request(qname, *params)
fd: 
pt: SOAP::RPC::SOAPMethodRequest
mt: class
fn: dup
fs: dup()
fd: 
pt: SOAP::RPC::SOAPMethodRequest
mt: instance
fn: each
fs: each()
fd: 
pt: SOAP::RPC::SOAPMethodRequest
mt: instance
fn: new
fs: new(qname, param_def = nil, soapaction = nil)
fd: 
pt: SOAP::RPC::SOAPMethodRequest
mt: class
fn: each
fs: each()
fd: 
pt: SOAP::RPC::SOAPMethodResponse
mt: instance
fn: new
fs: new(qname, param_def = nil)
fd: 
pt: SOAP::RPC::SOAPMethodResponse
mt: class
fn: retval=
fs: retval=(retval)
fd: 
pt: SOAP::RPC::SOAPMethodResponse
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::RPC::SOAPVoid
mt: class
fn: new
fs: new(appname, default_namespace, host = "0.0.0.0", port = 8080)
fd: 
pt: SOAP::RPC::StandaloneServer
mt: class
fn: save_cookie_store
fs: save_cookie_store(filename)
fd: 
pt: SOAP
mt: instance
fn: set_basic_auth
fs: set_basic_auth(uri, user_id, passwd)
fd: 
pt: SOAP
mt: instance
fn: set_cookie_store
fs: set_cookie_store(filename)
fd: 
pt: SOAP
mt: instance
fn: add
fs: add(value)
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: decode
fs: decode(elename, type, arytype)
fd: Module function
pt: SOAP::SOAPArray
mt: class
fn: deep_map
fs: deep_map(ary, &block)
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: each
fs: each()
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: include?
fs: include?(var)
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: new
fs: new(type = nil, rank = 1, arytype = nil)
fd: 
pt: SOAP::SOAPArray
mt: class
fn: offset=
fs: offset=(var)
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: position
fs: position()
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: replace
fs: replace()
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: soap2array
fs: soap2array(ary)
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: to_a
fs: to_a()
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: traverse
fs: traverse()
fd: 
pt: SOAP::SOAPArray
mt: instance
fn: new
fs: new(value)
fd: 
pt: SOAP::SOAPAttachment
mt: class
fn: as_xsd
fs: as_xsd()
fd: 
pt: SOAP::SOAPBase64
mt: instance
fn: new
fs: new(value = nil)
fd: Override the definition in SOAPBasetype.
pt: SOAP::SOAPBase64
mt: class
fn: new
fs: new(*arg)
fd: 
pt: SOAP::SOAPBasetype
mt: class
fn: encode
fs: encode(generator, ns, attrs = {})
fd: 
pt: SOAP::SOAPBody
mt: instance
fn: fault=
fs: fault=(fault)
fd: 
pt: SOAP::SOAPBody
mt: instance
fn: fault
fs: fault()
fd: 
pt: SOAP::SOAPBody
mt: instance
fn: new
fs: new(data = nil, is_fault = false)
fd: 
pt: SOAP::SOAPBody
mt: class
fn: outparams
fs: outparams()
fd: 
pt: SOAP::SOAPBody
mt: instance
fn: request
fs: request()
fd: 
pt: SOAP::SOAPBody
mt: instance
fn: response
fs: response()
fd: 
pt: SOAP::SOAPBody
mt: instance
fn: root_node
fs: root_node()
fd: 
pt: SOAP::SOAPBody
mt: instance
fn: new
fs: new(*arg)
fd: 
pt: SOAP::SOAPCompoundtype
mt: class
fn: add
fs: add(value)
fd: Element interfaces.
pt: SOAP::SOAPElement
mt: instance
fn: decode
fs: decode(elename)
fd: 
pt: SOAP::SOAPElement
mt: class
fn: each
fs: each()
fd: 
pt: SOAP::SOAPElement
mt: instance
fn: from_obj
fs: from_obj(obj, namespace = nil)
fd: 
pt: SOAP::SOAPElement
mt: class
fn: inspect
fs: inspect()
fd: 
pt: SOAP::SOAPElement
mt: instance
fn: key?
fs: key?(name)
fd: 
pt: SOAP::SOAPElement
mt: instance
fn: members
fs: members()
fd: 
pt: SOAP::SOAPElement
mt: instance
fn: new
fs: new(elename, text = nil)
fd: 
pt: SOAP::SOAPElement
mt: class
fn: to_elename
fs: to_elename(obj, namespace = nil)
fd: 
pt: SOAP::SOAPElement
mt: class
fn: to_obj
fs: to_obj()
fd: 
pt: SOAP::SOAPElement
mt: instance
fn: body=
fs: body=(body)
fd: 
pt: SOAP::SOAPEnvelope
mt: instance
fn: encode
fs: encode(generator, ns, attrs = {})
fd: 
pt: SOAP::SOAPEnvelope
mt: instance
fn: header=
fs: header=(header)
fd: 
pt: SOAP::SOAPEnvelope
mt: instance
fn: new
fs: new(header = nil, body = nil)
fd: 
pt: SOAP::SOAPEnvelope
mt: class
fn: to_ary
fs: to_ary()
fd: 
pt: SOAP::SOAPEnvelope
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::SOAPExternalReference
mt: class
fn: referred
fs: referred()
fd: 
pt: SOAP::SOAPExternalReference
mt: instance
fn: refidstr
fs: refidstr()
fd: 
pt: SOAP::SOAPExternalReference
mt: instance
fn: detail=
fs: detail=(rhs)
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: detail
fs: detail()
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: encode
fs: encode(generator, ns, attrs = {})
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: faultactor=
fs: faultactor=(rhs)
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: faultactor
fs: faultactor()
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: faultcode=
fs: faultcode=(rhs)
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: faultcode
fs: faultcode()
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: faultstring=
fs: faultstring=(rhs)
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: faultstring
fs: faultstring()
fd: 
pt: SOAP::SOAPFault
mt: instance
fn: new
fs: new(faultcode = nil, faultstring = nil, faultactor = nil, detail = nil)
fd: 
pt: SOAP::SOAPFault
mt: class
fn: add_reftarget
fs: add_reftarget(name, node)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: assign_ns
fs: assign_ns(attrs, ns, namespace, tag = nil)
fd: 
pt: SOAP::SOAPGenerator
mt: class
fn: element_local?
fs: element_local?(element)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: element_qualified?
fs: element_qualified?(element)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_child
fs: encode_child(ns, child, parent)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_data
fs: encode_data(ns, obj, parent)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_element
fs: encode_element(ns, obj, parent)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_name
fs: encode_name(ns, data, attrs)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_name_end
fs: encode_name_end(ns, data)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_rawstring
fs: encode_rawstring(str)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_string
fs: encode_string(str)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_tag
fs: encode_tag(elename, attrs = nil)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: encode_tag_end
fs: encode_tag_end(elename, cr = nil)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: generate
fs: generate(obj, io = nil)
fd: 
pt: SOAP::SOAPGenerator
mt: instance
fn: new
fs: new(opt = {})
fd: 
pt: SOAP::SOAPGenerator
mt: class
fn: add
fs: add(name, value)
fd: 
pt: SOAP::SOAPHeader
mt: instance
fn: encode
fs: encode(generator, ns, attrs = {})
fd: 
pt: SOAP::SOAPHeader
mt: instance
fn: length
fs: length()
fd: 
pt: SOAP::SOAPHeader
mt: instance
fn: new
fs: new()
fd: 
pt: SOAP::SOAPHeader
mt: class
fn: size
fs: size()
fd: "Alias for #length"
pt: SOAP::SOAPHeader
mt: instance
fn: encode
fs: encode(generator, ns, attrs = {})
fd: 
pt: SOAP::SOAPHeaderItem
mt: instance
fn: new
fs: new(element, mustunderstand = true, encodingstyle = nil)
fd: 
pt: SOAP::SOAPHeaderItem
mt: class
fn: decode
fs: decode(elename)
fd: 
pt: SOAP::SOAPModuleUtils
mt: instance
fn: create_refid
fs: create_refid(obj)
fd: 
pt: SOAP::SOAPReference
mt: class
fn: decode
fs: decode(elename, refidstr)
fd: 
pt: SOAP::SOAPReference
mt: class
fn: method_missing
fs: method_missing(msg_id, *params)
fd: Why don't I use delegate.rb? -&gt; delegate requires target object type at initialize time. Why don't I use forwardable.rb? -&gt; forwardable requires a list of forwarding methods.
pt: SOAP::SOAPReference
mt: instance
fn: new
fs: new(obj = nil)
fd: Override the definition in SOAPBasetype.
pt: SOAP::SOAPReference
mt: class
fn: refidstr
fs: refidstr()
fd: 
pt: SOAP::SOAPReference
mt: instance
fn: add
fs: add(name, value)
fd: 
pt: SOAP::SOAPStruct
mt: instance
fn: decode
fs: decode(elename, type)
fd: 
pt: SOAP::SOAPStruct
mt: class
fn: each
fs: each()
fd: 
pt: SOAP::SOAPStruct
mt: instance
fn: key?
fs: key?(name)
fd: 
pt: SOAP::SOAPStruct
mt: instance
fn: members
fs: members()
fd: 
pt: SOAP::SOAPStruct
mt: instance
fn: new
fs: new(type = nil)
fd: 
pt: SOAP::SOAPStruct
mt: class
fn: replace
fs: replace()
fd: 
pt: SOAP::SOAPStruct
mt: instance
fn: to_obj
fs: to_obj()
fd: 
pt: SOAP::SOAPStruct
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: SOAP::SOAPStruct
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: SOAP::SOAPType
mt: instance
fn: new
fs: new(*arg)
fd: 
pt: SOAP::SOAPType
mt: class
fn: rootnode
fs: rootnode()
fd: 
pt: SOAP::SOAPType
mt: instance
fn: new
fs: new(send_string = nil)
fd: 
pt: SOAP::StreamHandler::ConnectionData
mt: class
fn: create_media_type
fs: create_media_type(charset)
fd: 
pt: SOAP::StreamHandler
mt: class
fn: parse_media_type
fs: parse_media_type(str)
fd: 
pt: SOAP::StreamHandler
mt: class
fn: test_loopback_response
fs: test_loopback_response()
fd: 
pt: SOAP
mt: instance
fn: httpproxy=
fs: httpproxy=(httpproxy)
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: httpproxy
fs: httpproxy()
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: mandatorycharset=
fs: mandatorycharset=(mandatorycharset)
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: mandatorycharset
fs: mandatorycharset()
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: new
fs: new(wsdl, port, logdev)
fd: 
pt: SOAP::WSDLDriver
mt: class
fn: reset_stream
fs: reset_stream()
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: document_send
fs: document_send(name, header_obj, body_obj)
fd: "req_header: [[element, mustunderstand, encodingstyle(QName/String)], ...] req_body: SOAPBasetype/SOAPCompoundtype"
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: endpoint_url=
fs: endpoint_url=(endpoint_url)
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: endpoint_url
fs: endpoint_url()
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: headerhandler
fs: headerhandler()
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: new
fs: new(host, wsdl, port, logdev)
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: class
fn: reset_stream
fs: reset_stream()
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: rpc_call
fs: rpc_call(name, *values)
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: streamhandler
fs: streamhandler()
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: test_loopback_response
fs: test_loopback_response()
fd: 
pt: SOAP::WSDLDriver::Servant__
mt: instance
fn: wiredump_dev=
fs: wiredump_dev=(wiredump_dev)
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: wiredump_dev
fs: wiredump_dev()
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: wiredump_file_base=
fs: wiredump_file_base=(wiredump_file_base)
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: wiredump_file_base
fs: wiredump_file_base()
fd: 
pt: SOAP::WSDLDriver
mt: instance
fn: create_driver
fs: create_driver(servicename = nil, portname = nil)
fd: depricated old interface
pt: SOAP::WSDLDriverFactory
mt: instance
fn: create_rpc_driver
fs: create_rpc_driver(servicename = nil, portname = nil)
fd: 
pt: SOAP::WSDLDriverFactory
mt: instance
fn: createDriver
fs: createDriver(servicename = nil, portname = nil)
fd: "Alias for #create_driver"
pt: SOAP::WSDLDriverFactory
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: SOAP::WSDLDriverFactory
mt: instance
fn: new
fs: new(wsdl)
fd: 
pt: SOAP::WSDLDriverFactory
mt: class
fn: accept
fs: accept
fd: Accepts an incoming connection returning an array containing a new Socket object and a string holding the struct sockaddr information about the caller.
pt: Socket
mt: instance
fn: accept_nonblock
fs: accept_nonblock
fd: Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an array containg the accpeted socket for the incoming connection, client_socket, and a string that contains the struct sockaddr information about the caller, client_sockaddr.
pt: Socket
mt: instance
fn: bind
fs: bind(server_sockaddr)
fd: Binds to the given struct sockaddr.
pt: Socket
mt: instance
fn: connect
fs: connect(server_sockaddr)
fd: Requests a connection to be made on the given server_sockaddr. Returns 0 if successful, otherwise an exception is raised.
pt: Socket
mt: instance
fn: connect_nonblock
fs: connect_nonblock(server_sockaddr)
fd: Requests a connection to be made on the given server_sockaddr after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful, otherwise an exception is raised.
pt: Socket
mt: instance
fn: getaddrinfo
fs: getaddrinfo" Socket.getaddrinfo(host, service, family=nil, socktype=nil, protocol=nil, flags=nil)
fd: Return address information for host and port. The remaining arguments are hints that limit the address information returned.
pt: Socket
mt: class
fn: gethostbyname
fs: gethostbyname" Socket.gethostbyname(host)
fd: Resolve host and return name and address information for it, similarly to gethostbyname(3). host can be a domain name or the presentation format of an address.
pt: Socket
mt: class
fn: getservbyname
fs: getservbyname" Socket.getservbyname(name, proto=\"tcp\")
fd: name is a service name (&quot;ftp&quot;, &quot;telnet&quot;, ...) and proto is a protocol name (&quot;udp&quot;, &quot;tcp&quot;, ...). '/etc/services' (or your system's equivalent) is searched for a service for name and proto, and the port number is returned.
pt: Socket
mt: class
fn: listen
fs: listen( int )
fd: Listens for connections, using the specified int as the backlog. A call to listen only applies if the socket is of type SOCK_STREAM or SOCK_SEQPACKET.
pt: Socket
mt: instance
fn: recvfrom
fs: recvfrom(maxlen)
fd: Receives up to maxlen bytes from socket. flags is zero or more of the MSG_ options. The first element of the results, mesg, is the data received. The second element, sender_sockaddr, contains protocol-specific information on the sender.
pt: Socket
mt: instance
fn: recvfrom_nonblock
fs: recvfrom_nonblock(maxlen)
fd: Receives up to maxlen bytes from socket using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. flags is zero or more of the MSG_ options. The first element of the results, mesg, is the data received. The second element, sender_sockaddr, contains protocol-specific information on the sender.
pt: Socket
mt: instance
fn: sysaccept
fs: sysaccept
fd: Accepts an incoming connection returnings an array containg the (integer) file descriptor for the incoming connection, client_socket_fd, and a string that contains the struct sockaddr information about the caller, client_sockaddr.
pt: Socket
mt: instance
fn: new
fs: new(host, serv)
fd: 
pt: SOCKSSocket
mt: class
fn: block_scanf
fs: block_scanf(fstr,&b)
fd: 
pt: String
mt: instance
fn: capitalize!
fs: capitalize!
fd: Modifies str by converting the first character to uppercase and the remainder to lowercase. Returns nil if no changes are made.
pt: String
mt: instance
fn: capitalize
fs: capitalize
fd: Returns a copy of str with the first character converted to uppercase and the remainder to lowercase.
pt: String
mt: instance
fn: casecmp
fs: casecmp(other_str)
fd: Case-insensitive version of String#&lt;=&gt;.
pt: String
mt: instance
fn: center
fs: center(integer, padstr)
fd: If integer is greater than the length of str, returns a new String of length integer with str centered and padded with padstr; otherwise, returns str.
pt: String
mt: instance
fn: chomp!
fs: chomp!(separator=$/)
fd: Modifies str in place as described for String#chomp, returning str, or nil if no modifications were made.
pt: String
mt: instance
fn: chomp
fs: chomp(separator=$/)
fd: Returns a new String with the given record separator removed from the end of str (if present). If $/ has not been changed from the default Ruby record separator, then chomp also removes carriage return characters (that is it will remove \n, \r, and \r\n).
pt: String
mt: instance
fn: chop!
fs: chop!()
fd: 
pt: String
mt: instance
fn: chop
fs: chop
fd: Returns a new String with the last character removed. If the string ends with \r\n, both characters are removed. Applying chop to an empty string returns an empty string. String#chomp is often a safer alternative, as it leaves the string unchanged if it doesn't end in a record separator.
pt: String
mt: instance
fn: concat
fs: concat(fixnum)
fd: Append---Concatenates the given object to str. If the object is a Fixnum between 0 and 255, it is converted to a character before concatenation.
pt: String
mt: instance
fn: count
fs: count([other_str]+)
fd: Each other_str parameter defines a set of characters to count. The intersection of these sets defines the characters to count in str. Any other_str that starts with a caret (^) is negated. The sequence c1--c2 means all characters between c1 and c2.
pt: String
mt: instance
fn: crypt
fs: crypt(other_str)
fd: Applies a one-way cryptographic hash to str by invoking the standard library function crypt. The argument is the salt string, which should be two characters long, each character drawn from [a-zA-Z0-9./].
pt: String
mt: instance
fn: delete!
fs: delete!([other_str]+>)
fd: Performs a delete operation in place, returning str, or nil if str was not modified.
pt: String
mt: instance
fn: delete
fs: delete([other_str]+)
fd: Returns a copy of str with all characters in the intersection of its arguments deleted. Uses the same rules for building the set of characters as String#count.
pt: String
mt: instance
fn: downcase!
fs: downcase!
fd: Downcases the contents of str, returning nil if no changes were made.
pt: String
mt: instance
fn: downcase
fs: downcase
fd: Returns a copy of str with all uppercase letters replaced with their lowercase counterparts. The operation is locale insensitive---only characters ``A'' to ``Z'' are affected.
pt: String
mt: instance
fn: dump
fs: dump
fd: Produces a version of str with all nonprinting characters replaced by \nnn notation and all special characters escaped.
pt: String
mt: instance
fn: each
fs: each(separator=$/)
fd: Splits str using the supplied parameter as the record separator ($/ by default), passing each substring in turn to the supplied block. If a zero-length record separator is supplied, the string is split on \n characters, except that multiple successive newlines are appended together.
pt: String
mt: instance
fn: each_byte
fs: each_byte
fd: Passes each byte in str to the given block.
pt: String
mt: instance
fn: each_char
fs: each_char()
fd: 
pt: String
mt: instance
fn: each_line
fs: each_line(separator=$/)
fd: Splits str using the supplied parameter as the record separator ($/ by default), passing each substring in turn to the supplied block. If a zero-length record separator is supplied, the string is split on \n characters, except that multiple successive newlines are appended together.
pt: String
mt: instance
fn: empty?
fs: empty?
fd: Returns true if str has a length of zero.
pt: String
mt: instance
fn: end_regexp
fs: end_regexp()
fd: 
pt: String
mt: instance
fn: eql?
fs: eql?(other)
fd: Two strings are equal if the have the same length and content.
pt: String
mt: instance
fn: gsub!
fs: gsub!(pattern, replacement)
fd: Performs the substitutions of String#gsub in place, returning str, or nil if no substitutions were performed.
pt: String
mt: instance
fn: gsub
fs: gsub(pattern, replacement)
fd: Returns a copy of str with all occurrences of pattern replaced with either replacement or the value of the block. The pattern will typically be a Regexp; if it is a String then no regular expression metacharacters will be interpreted (that is /\d/ will match a digit, but '\d' will match a backslash followed by a 'd').
pt: String
mt: instance
fn: hash
fs: hash
fd: Return a hash based on the string's length and content.
pt: String
mt: instance
fn: hex
fs: hex
fd: Treats leading characters from str as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the corresponding number. Zero is returned on error.
pt: String
mt: instance
fn: include?
fs: include?
fd: Returns true if str contains the given string or character.
pt: String
mt: instance
fn: index
fs: index(substring [, offset])
fd: Returns the index of the first occurrence of the given substring, character (fixnum), or pattern (regexp) in str. Returns nil if not found. If the second parameter is present, it specifies the position in the string to begin the search.
pt: String
mt: instance
fn: initialize_copy
fs: initialize_copy  str.replace(other_str)
fd: Replaces the contents and taintedness of str with the corresponding values in other_str.
pt: String
mt: instance
fn: insert
fs: insert(index, other_str)
fd: Inserts other_str before the character at the given index, modifying str. Negative indices count from the end of the string, and insert after the given character. The intent is insert aString so that it starts at the given index.
pt: String
mt: instance
fn: inspect
fs: inspect
fd: Returns a printable version of str, with special characters escaped.
pt: String
mt: instance
fn: intern
fs: intern
fd: Returns the Symbol corresponding to str, creating the symbol if it did not previously exist. See Symbol#id2name.
pt: String
mt: instance
fn: is_binary_data?
fs: is_binary_data?()
fd: 
pt: String
mt: instance
fn: is_complex_yaml?
fs: is_complex_yaml?()
fd: 
pt: String
mt: instance
fn: iseuc
fs: iseuc
fd: Returns whether self's encoding is EUC-JP or not.
pt: String
mt: instance
fn: issjis
fs: issjis
fd: Returns whether self's encoding is Shift_JIS or not.
pt: String
mt: instance
fn: isutf8
fs: isutf8
fd: Returns whether self's encoding is UTF-8 or not.
pt: String
mt: instance
fn: jcount
fs: jcount(str)
fd: 
pt: String
mt: instance
fn: jlength
fs: jlength()
fd: 
pt: String
mt: instance
fn: jsize
fs: jsize()
fd: "Alias for #jlength"
pt: String
mt: instance
fn: kconv
fs: kconv  String#kconv(out_code, in_code = Kconv::AUTO)
fd: Convert self to out_code. out_code and in_code are given as constants of Kconv.
pt: String
mt: instance
fn: length
fs: length
fd: Returns the length of str.
pt: String
mt: instance
fn: ljust
fs: ljust(integer, padstr=' ')
fd: If integer is greater than the length of str, returns a new String of length integer with str left justified and padded with padstr; otherwise, returns str.
pt: String
mt: instance
fn: lstrip!
fs: lstrip!
fd: Removes leading whitespace from str, returning nil if no change was made. See also String#rstrip! and String#strip!.
pt: String
mt: instance
fn: lstrip
fs: lstrip
fd: Returns a copy of str with leading whitespace removed. See also String#rstrip and String#strip.
pt: String
mt: instance
fn: match
fs: match(pattern)
fd: Converts pattern to a Regexp (if it isn't already one), then invokes its match method on str.
pt: String
mt: instance
fn: mbchar?
fs: mbchar?()
fd: 
pt: String
mt: instance
fn: new
fs: new(str="")
fd: Returns a new string object containing a copy of str.
pt: String
mt: class
fn: next!
fs: next!
fd: Equivalent to String#succ, but modifies the receiver in place.
pt: String
mt: instance
fn: next
fs: next
fd: Returns the successor to str. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. Incrementing nonalphanumerics uses the underlying character set's collating sequence.
pt: String
mt: instance
fn: oct
fs: oct
fd: Treats leading characters of str as a string of octal digits (with an optional sign) and returns the corresponding number. Returns 0 if the conversion fails.
pt: String
mt: instance
fn: quote
fs: quote()
fd: 
pt: String
mt: instance
fn: replace
fs: replace(other_str)
fd: Replaces the contents and taintedness of str with the corresponding values in other_str.
pt: String
mt: instance
fn: reverse!
fs: reverse!
fd: Reverses str in place.
pt: String
mt: instance
fn: reverse
fs: reverse
fd: Returns a new string with the characters from str in reverse order.
pt: String
mt: instance
fn: rindex
fs: rindex(substring [, fixnum])
fd: Returns the index of the last occurrence of the given substring, character (fixnum), or pattern (regexp) in str. Returns nil if not found. If the second parameter is present, it specifies the position in the string to end the search---characters beyond this point will not be considered.
pt: String
mt: instance
fn: rjust
fs: rjust(integer, padstr=' ')
fd: If integer is greater than the length of str, returns a new String of length integer with str right justified and padded with padstr; otherwise, returns str.
pt: String
mt: instance
fn: rstrip!
fs: rstrip!
fd: Removes trailing whitespace from str, returning nil if no change was made. See also String#lstrip! and String#strip!.
pt: String
mt: instance
fn: rstrip
fs: rstrip
fd: Returns a copy of str with trailing whitespace removed. See also String#lstrip and String#strip.
pt: String
mt: instance
fn: scan
fs: scan(pattern)
fd: Both forms iterate through str, matching the pattern (which may be a Regexp or a String). For each match, a result is generated and either added to the result array or passed to the block. If the pattern contains no groups, each individual result consists of the matched string, $&amp;. If the pattern contains groups, each individual result is itself an array containing one entry per group.
pt: String
mt: instance
fn: scanf
fs: scanf(fstr,&b)
fd: 
pt: String
mt: instance
fn: size
fs: size
fd: Returns the length of str.
pt: String
mt: instance
fn: slice!
fs: slice!(fixnum)
fd: Deletes the specified portion from str, and returns the portion deleted. The forms that take a Fixnum will raise an IndexError if the value is out of range; the Range form will raise a RangeError, and the Regexp and String forms will silently ignore the assignment.
pt: String
mt: instance
fn: slice
fs: slice(fixnum)
fd: Element Reference---If passed a single Fixnum, returns the code of the character at that position. If passed two Fixnum objects, returns a substring starting at the offset given by the first, and a length given by the second. If given a range, a substring containing characters at offsets given by the range is returned. In all three cases, if an offset is negative, it is counted from the end of str. Returns nil if the initial offset falls outside the string, the length is negative, or the beginning of the range is greater than the end.
pt: String
mt: instance
fn: split
fs: split(pattern=$;, [limit])
fd: Divides str into substrings based on a delimiter, returning an array of these substrings.
pt: String
mt: instance
fn: squeeze!
fs: squeeze!(del=nil)
fd: 
pt: String
mt: instance
fn: squeeze
fs: squeeze([other_str]*)
fd: Builds a set of characters from the other_str parameter(s) using the procedure described for String#count. Returns a new string where runs of the same character that occur in this set are replaced by a single character. If no arguments are given, all runs of identical characters are replaced by a single character.
pt: String
mt: instance
fn: strip!
fs: strip!
fd: Removes leading and trailing whitespace from str. Returns nil if str was not altered.
pt: String
mt: instance
fn: strip
fs: strip
fd: Returns a copy of str with leading and trailing whitespace removed.
pt: String
mt: instance
fn: sub!
fs: sub!(pattern, replacement)
fd: Performs the substitutions of String#sub in place, returning str, or nil if no substitutions were performed.
pt: String
mt: instance
fn: sub
fs: sub(pattern, replacement)
fd: Returns a copy of str with the first occurrence of pattern replaced with either replacement or the value of the block. The pattern will typically be a Regexp; if it is a String then no regular expression metacharacters will be interpreted (that is /\d/ will match a digit, but '\d' will match a backslash followed by a 'd').
pt: String
mt: instance
fn: succ!
fs: succ!
fd: Equivalent to String#succ, but modifies the receiver in place.
pt: String
mt: instance
fn: succ
fs: succ
fd: Returns the successor to str. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. Incrementing nonalphanumerics uses the underlying character set's collating sequence.
pt: String
mt: instance
fn: sum
fs: sum(n=16)
fd: Returns a basic n-bit checksum of the characters in str, where n is the optional Fixnum parameter, defaulting to 16. The result is simply the sum of the binary value of each character in str modulo 2n - 1. This is not a particularly good checksum.
pt: String
mt: instance
fn: swapcase!
fs: swapcase!
fd: Equivalent to String#swapcase, but modifies the receiver in place, returning str, or nil if no changes were made.
pt: String
mt: instance
fn: swapcase
fs: swapcase
fd: Returns a copy of str with uppercase alphabetic characters converted to lowercase and lowercase characters converted to uppercase.
pt: String
mt: instance
fn: to_f
fs: to_f
fd: Returns the result of interpreting leading characters in str as a floating point number. Extraneous characters past the end of a valid number are ignored. If there is not a valid number at the start of str, 0.0 is returned. This method never raises an exception.
pt: String
mt: instance
fn: to_i
fs: to_i(base=10)
fd: Returns the result of interpreting leading characters in str as an integer base base (2, 8, 10, or 16). Extraneous characters past the end of a valid number are ignored. If there is not a valid number at the start of str, 0 is returned. This method never raises an exception.
pt: String
mt: instance
fn: to_s
fs: to_s
fd: Returns the receiver.
pt: String
mt: instance
fn: to_str
fs: to_str
fd: Returns the receiver.
pt: String
mt: instance
fn: to_sym
fs: to_sym
fd: Returns the Symbol corresponding to str, creating the symbol if it did not previously exist. See Symbol#id2name.
pt: String
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: String
mt: instance
fn: toeuc
fs: toeuc
fd: Convert self to EUC-JP
pt: String
mt: instance
fn: tojis
fs: tojis
fd: Convert self to ISO-2022-JP
pt: String
mt: instance
fn: tosjis
fs: tosjis
fd: Convert self to Shift_JIS
pt: String
mt: instance
fn: toutf16
fs: toutf16
fd: Convert self to UTF-16
pt: String
mt: instance
fn: toutf8
fs: toutf8
fd: Convert self to UTF-8
pt: String
mt: instance
fn: tr!
fs: tr!(from, to)
fd: 
pt: String
mt: instance
fn: tr
fs: tr(from, to)
fd: 
pt: String
mt: instance
fn: tr_s!
fs: tr_s!(from, to)
fd: 
pt: String
mt: instance
fn: tr_s
fs: tr_s(from_str, to_str)
fd: Processes a copy of str as described under String#tr, then removes duplicate characters in regions that were affected by the translation.
pt: String
mt: instance
fn: unpack
fs: unpack(format)
fd: Decodes str (which may contain binary data) according to the format string, returning an array of each value extracted. The format string consists of a sequence of single-character directives, summarized in the table at the end of this entry. Each directive may be followed by a number, indicating the number of times to repeat with this directive. An asterisk (``*'') will use up all remaining elements. The directives sSiIlL may each be followed by an underscore (``_'') to use the underlying platform's native size for the specified type; otherwise, it uses a platform-independent consistent size. Spaces are ignored in the format string. See also Array#pack.
pt: String
mt: instance
fn: upcase!
fs: upcase!
fd: Upcases the contents of str, returning nil if no changes were made.
pt: String
mt: instance
fn: upcase
fs: upcase
fd: Returns a copy of str with all lowercase letters replaced with their uppercase counterparts. The operation is locale insensitive---only characters ``a'' to ``z'' are affected.
pt: String
mt: instance
fn: upto
fs: upto(other_str)
fd: Iterates through successive values, starting at str and ending at other_str inclusive, passing each value in turn to the block. The String#succ method is used to generate each value.
pt: String
mt: instance
fn: yaml_new
fs: yaml_new( klass, tag, val )
fd: 
pt: String
mt: class
fn: binmode
fs: binmode
fd: Returns <b>strio</b> itself. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: close
fs: close
fd: Closes strio. The <b>strio</b> is unavailable for any further data operations; an IOError is raised if such an attempt is made.
pt: StringIO
mt: instance
fn: close_read
fs: close_read
fd: Closes the read end of a StringIO. Will raise an IOError if the <b>strio</b> is not readable.
pt: StringIO
mt: instance
fn: close_write
fs: close_write
fd: Closes the write end of a StringIO. Will raise an IOError if the <b>strio</b> is not writeable.
pt: StringIO
mt: instance
fn: closed?
fs: closed?
fd: Returns true if <b>strio</b> is completely closed, false otherwise.
pt: StringIO
mt: instance
fn: closed_read?
fs: closed_read?
fd: Returns true if <b>strio</b> is not readable, false otherwise.
pt: StringIO
mt: instance
fn: closed_write?
fs: closed_write?
fd: Returns true if <b>strio</b> is not writable, false otherwise.
pt: StringIO
mt: instance
fn: each
fs: each(sep_string=$/)
fd: See IO#each.
pt: StringIO
mt: instance
fn: each_byte
fs: each_byte
fd: See IO#each_byte.
pt: StringIO
mt: instance
fn: each_line
fs: each_line(sep_string=$/)
fd: See IO#each.
pt: StringIO
mt: instance
fn: eof?
fs: eof?
fd: Returns true if <b>strio</b> is at end of file. The stringio must be opened for reading or an IOError will be raised.
pt: StringIO
mt: instance
fn: eof
fs: eof
fd: Returns true if <b>strio</b> is at end of file. The stringio must be opened for reading or an IOError will be raised.
pt: StringIO
mt: instance
fn: fcntl
fs: fcntl
fd: Raises NotImplementedError.
pt: StringIO
mt: instance
fn: fileno
fs: fileno
fd: Returns nil. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: flush
fs: flush
fd: Returns <b>strio</b> itself. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: fsync
fs: fsync
fd: Returns 0. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: getc
fs: getc
fd: See IO#getc.
pt: StringIO
mt: instance
fn: gets
fs: gets(sep_string=$/)
fd: See IO#gets.
pt: StringIO
mt: instance
fn: isatty
fs: isatty
fd: Returns false. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: length
fs: length
fd: Returns the size of the buffer string.
pt: StringIO
mt: instance
fn: lineno=
fs: lineno=
fd: Manually sets the current line number to the given value. $. is updated only on the next read.
pt: StringIO
mt: instance
fn: lineno
fs: lineno
fd: Returns the current line number in <b>strio</b>. The stringio must be opened for reading. lineno counts the number of times gets is called, rather than the number of newlines encountered. The two values will differ if gets is called with a separator other than newline. See also the $. variable.
pt: StringIO
mt: instance
fn: new
fs: new" StringIO.new(string=\"\"[, mode])
fd: Creates new StringIO instance from with string and mode.
pt: StringIO
mt: class
fn: open
fs: open" StringIO.open(string=\"\"[, mode])
fd: Equivalent to StringIO.new except that when it is called with a block, it yields with the new instance and closes it, and returns the result which returned from the block.
pt: StringIO
mt: class
fn: path
fs: path
fd: Returns nil. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: pid
fs: pid
fd: Returns nil. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: pos=
fs: pos=
fd: Seeks to the given position (in bytes) in <b>strio</b>.
pt: StringIO
mt: instance
fn: pos
fs: pos
fd: Returns the current offset (in bytes) of <b>strio</b>.
pt: StringIO
mt: instance
fn: print
fs: print()
fd: See IO#print.
pt: StringIO
mt: instance
fn: printf
fs: printf(format_string [, obj, ...] )
fd: See IO#printf.
pt: StringIO
mt: instance
fn: putc
fs: putc(obj)
fd: See IO#putc.
pt: StringIO
mt: instance
fn: puts
fs: puts(obj, ...)
fd: See IO#puts.
pt: StringIO
mt: instance
fn: read
fs: read([length [, buffer]])
fd: See IO#read.
pt: StringIO
mt: instance
fn: readchar
fs: readchar
fd: See IO#readchar.
pt: StringIO
mt: instance
fn: readline
fs: readline(sep_string=$/)
fd: See IO#readline.
pt: StringIO
mt: instance
fn: readlines
fs: readlines(sep_string=$/)
fd: See IO#readlines.
pt: StringIO
mt: instance
fn: reopen
fs: reopen(other_StrIO)
fd: Reinitializes <b>strio</b> with the given other_StrIO or string and mode (see StringIO#new).
pt: StringIO
mt: instance
fn: rewind
fs: rewind()
fd: 
pt: StringIO
mt: instance
fn: seek
fs: seek(amount, whence=SEEK_SET)
fd: Seeks to a given offset amount in the stream according to the value of whence (see IO#seek).
pt: StringIO
mt: instance
fn: size
fs: size
fd: Returns the size of the buffer string.
pt: StringIO
mt: instance
fn: string=
fs: string=
fd: Changes underlying String object, the subject of IO.
pt: StringIO
mt: instance
fn: string
fs: string
fd: Returns underlying String object, the subject of IO.
pt: StringIO
mt: instance
fn: sync=
fs: sync=
fd: Returns the argument unchanged. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: sync
fs: sync
fd: Returns true always.
pt: StringIO
mt: instance
fn: sysread
fs: sysread(integer[, outbuf])
fd: "Similar to #read, but raises EOFError at end of string instead of returning nil, as well as IO#sysread does."
pt: StringIO
mt: instance
fn: syswrite
fs: syswrite(string)
fd: Appends the given string to the underlying buffer string of <b>strio</b>. The stream must be opened for writing. If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written. See IO#write.
pt: StringIO
mt: instance
fn: tell
fs: tell
fd: Returns the current offset (in bytes) of <b>strio</b>.
pt: StringIO
mt: instance
fn: truncate
fs: truncate(integer)
fd: Truncates the buffer string to at most integer bytes. The <b>strio</b> must be opened for writing.
pt: StringIO
mt: instance
fn: tty?
fs: tty?
fd: Returns false. Just for compatibility to IO.
pt: StringIO
mt: instance
fn: ungetc
fs: ungetc(integer)
fd: Pushes back one character (passed as a parameter) onto <b>strio</b> such that a subsequent buffered read will return it. Pushing back behind the beginning of the buffer string is not possible. Nothing will be done if such an attempt is made. In other case, there is no limitation for multiple pushbacks.
pt: StringIO
mt: instance
fn: write
fs: write(string)
fd: Appends the given string to the underlying buffer string of <b>strio</b>. The stream must be opened for writing. If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written. See IO#write.
pt: StringIO
mt: instance
fn: beginning_of_line?
fs: beginning_of_line?()
fd: Returns true iff the scan pointer is at the beginning of the line.
pt: StringScanner
mt: instance
fn: check
fs: check" check(pattern)
fd: "This returns the value that #scan would return, without advancing the scan pointer. The match register is affected, though."
pt: StringScanner
mt: instance
fn: check_until
fs: check_until" check_until(pattern)
fd: "This returns the value that #scan_until would return, without advancing the scan pointer. The match register is affected, though."
pt: StringScanner
mt: instance
fn: clear
fs: clear()
fd: "Equivalent to #terminate. This method is obsolete; use #terminate instead."
pt: StringScanner
mt: instance
fn: concat
fs: concat  concat(str)
fd: Appends str to the string being scanned. This method does not affect scan pointer.
pt: StringScanner
mt: instance
fn: empty?
fs: empty?()
fd: "Equivalent to #eos?. This method is obsolete, use #eos? instead."
pt: StringScanner
mt: instance
fn: eos?
fs: eos?()
fd: Returns true if the scan pointer is at the end of the string.
pt: StringScanner
mt: instance
fn: exist?
fs: exist?" exist?(pattern)
fd: "Looks ahead to see if the pattern exists anywhere in the string, without advancing the scan pointer. This predicates whether a #scan_until will return a value."
pt: StringScanner
mt: instance
fn: get_byte
fs: get_byte()
fd: "Scans one byte and returns it. This method is NOT multi-byte character sensitive. See also #getch."
pt: StringScanner
mt: instance
fn: getbyte
fs: getbyte()
fd: "Equivalent to #get_byte. This method is obsolete; use #get_byte instead."
pt: StringScanner
mt: instance
fn: getch
fs: getch()
fd: "Scans one character and returns it. This method is multi-byte character sensitive. See also #get_byte."
pt: StringScanner
mt: instance
fn: initialize_copy
fs: initialize_copy
fd: Duplicates a StringScanner object.
pt: StringScanner
mt: instance
fn: inspect
fs: inspect()
fd: "Returns a string that represents the StringScanner object, showing:"
pt: StringScanner
mt: instance
fn: match?
fs: match?" match?(pattern)
fd: Tests whether the given pattern is matched from the current scan pointer. Returns the length of the match, or nil. The scan pointer is not advanced.
pt: StringScanner
mt: instance
fn: matched?
fs: matched?()
fd: Returns true iff the last match was successful.
pt: StringScanner
mt: instance
fn: matched
fs: matched()
fd: Returns the last matched string.
pt: StringScanner
mt: instance
fn: matched_size
fs: matched_size()
fd: "Returns the size of the most recent match (see #matched), or nil if there was no recent match."
pt: StringScanner
mt: instance
fn: matchedsize
fs: matchedsize()
fd: "Equivalent to #matched_size. This method is obsolete; use #matched_size instead."
pt: StringScanner
mt: instance
fn: must_C_version
fs: must_C_version
fd: This method is defined for backward compatibility.
pt: StringScanner
mt: class
fn: new
fs: new" StringScanner.new(string, dup = false)
fd: Creates a new StringScanner object to scan over the given string. dup argument is obsolete and not used now.
pt: StringScanner
mt: class
fn: peek
fs: peek" peek(len)
fd: Extracts a string corresponding to string[pos,len], without advancing the scan pointer.
pt: StringScanner
mt: instance
fn: peep
fs: peep(p1)
fd: "Equivalent to #peek. This method is obsolete; use #peek instead."
pt: StringScanner
mt: instance
fn: pointer=
fs: pointer=" pos=(n)
fd: Modify the scan pointer.
pt: StringScanner
mt: instance
fn: pointer
fs: pointer()
fd: Returns the position of the scan pointer. In the 'reset' position, this value is zero. In the 'terminated' position (i.e. the string is exhausted), this value is the length of the string.
pt: StringScanner
mt: instance
fn: pos=
fs: pos=" pos=(n)
fd: Modify the scan pointer.
pt: StringScanner
mt: instance
fn: pos
fs: pos()
fd: Returns the position of the scan pointer. In the 'reset' position, this value is zero. In the 'terminated' position (i.e. the string is exhausted), this value is the length of the string.
pt: StringScanner
mt: instance
fn: post_match
fs: post_match()
fd: Return the <b>post</b>-match (in the regular expression sense) of the last scan.
pt: StringScanner
mt: instance
fn: pre_match
fs: pre_match()
fd: Return the <b>pre</b>-match (in the regular expression sense) of the last scan.
pt: StringScanner
mt: instance
fn: reset
fs: reset()
fd: Reset the scan pointer (index 0) and clear matching data.
pt: StringScanner
mt: instance
fn: rest?
fs: rest?()
fd: "Returns true iff there is more data in the string. See #eos?. This method is obsolete; use #eos? instead."
pt: StringScanner
mt: instance
fn: rest
fs: rest()
fd: Returns the &quot;rest&quot; of the string (i.e. everything after the scan pointer). If there is no more data (eos? = true), it returns &quot;&quot;.
pt: StringScanner
mt: instance
fn: rest_size
fs: rest_size()
fd: s.rest_size is equivalent to s.rest.size.
pt: StringScanner
mt: instance
fn: restsize
fs: restsize()
fd: "s.restsize is equivalent to s.rest_size. This method is obsolete; use #rest_size instead."
pt: StringScanner
mt: instance
fn: scan
fs: scan" scan(pattern)
fd: Tries to match with pattern at the current position. If there's a match, the scanner advances the &quot;scan pointer&quot; and returns the matched string. Otherwise, the scanner returns nil.
pt: StringScanner
mt: instance
fn: scan_full
fs: scan_full" scan_full(pattern, return_string_p, advance_pointer_p)
fd: Tests whether the given pattern is matched from the current scan pointer. Returns the matched string if return_string_p is true. Advances the scan pointer if advance_pointer_p is true. The match register is affected.
pt: StringScanner
mt: instance
fn: scan_until
fs: scan_until" scan_until(pattern)
fd: Scans the string until the pattern is matched. Returns the substring up to and including the end of the match, advancing the scan pointer to that location. If there is no match, nil is returned.
pt: StringScanner
mt: instance
fn: search_full
fs: search_full" search_full(pattern, return_string_p, advance_pointer_p)
fd: Scans the string until the pattern is matched. Returns the matched string if return_string_p is true, otherwise returns the number of bytes advanced. Advances the scan pointer if advance_pointer_p, otherwise not. This method does affect the match register.
pt: StringScanner
mt: instance
fn: skip
fs: skip" skip(pattern)
fd: Attempts to skip over the given pattern beginning with the scan pointer. If it matches, the scan pointer is advanced to the end of the match, and the length of the match is returned. Otherwise, nil is returned.
pt: StringScanner
mt: instance
fn: skip_until
fs: skip_until" skip_until(pattern)
fd: Advances the scan pointer until pattern is matched and consumed. Returns the number of bytes advanced, or nil if no match was found.
pt: StringScanner
mt: instance
fn: string=
fs: string=" string=(str)
fd: Changes the string being scanned to str and resets the scanner. Returns str.
pt: StringScanner
mt: instance
fn: string
fs: string()
fd: Returns the string being scanned.
pt: StringScanner
mt: instance
fn: terminate
fs: terminate
fd: Set the scan pointer to the end of the string and clear matching data.
pt: StringScanner
mt: instance
fn: unscan
fs: unscan()
fd: Set the scan pointer to the previous position. Only one previous position is remembered, and it changes with each scanning operation.
pt: StringScanner
mt: instance
fn: each
fs: each
fd: Calls block once for each instance variable, passing the value as a parameter.
pt: Struct
mt: instance
fn: each_pair
fs: each_pair
fd: Calls block once for each instance variable, passing the name (as a symbol) and the value as parameters.
pt: Struct
mt: instance
fn: eql?
fs: eql?(p1)
fd: "code-seq:"
pt: Struct
mt: instance
fn: hash
fs: hash
fd: Return a hash value based on this struct's contents.
pt: Struct
mt: instance
fn: inspect
fs: inspect
fd: Describe the contents of this struct in a string.
pt: Struct
mt: instance
fn: length
fs: length
fd: Returns the number of instance variables.
pt: Struct
mt: instance
fn: members
fs: members
fd: Returns an array of strings representing the names of the instance variables.
pt: Struct
mt: instance
fn: new
fs: new(...)
fd: 
pt: Struct
mt: class
fn: pretty_print
fs: pretty_print(q)
fd: 
pt: Struct
mt: instance
fn: pretty_print_cycle
fs: pretty_print_cycle(q)
fd: 
pt: Struct
mt: instance
fn: select
fs: select
fd: Invokes the block passing in successive elements from struct, returning an array containing those elements for which the block returns a true value (equivalent to Enumerable#select).
pt: Struct
mt: instance
fn: size
fs: size
fd: Returns the number of instance variables.
pt: Struct
mt: instance
fn: to_a
fs: to_a
fd: Returns the values for this instance as an array.
pt: Struct
mt: instance
fn: to_s
fs: to_s
fd: Describe the contents of this struct in a string.
pt: Struct
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Struct
mt: instance
fn: values
fs: values
fd: Returns the values for this instance as an array.
pt: Struct
mt: instance
fn: values_at
fs: values_at(selector,... )
fd: Returns an array containing the elements in self corresponding to the given selector(s). The selectors may be either integer indices or ranges. See also &lt;/code&gt;.select&lt;code&gt;.
pt: Struct
mt: instance
fn: yaml_new
fs: yaml_new( klass, tag, val )
fd: 
pt: Struct
mt: class
fn: yaml_tag_class_name
fs: yaml_tag_class_name()
fd: 
pt: Struct
mt: class
fn: yaml_tag_read_class
fs: yaml_tag_read_class( name )
fd: 
pt: Struct
mt: class
fn: all_symbols
fs: all_symbols
fd: Returns an array of all the symbols currently in Ruby's symbol table.
pt: Symbol
mt: class
fn: dclone
fs: dclone()
fd: 
pt: Symbol
mt: instance
fn: id2name
fs: id2name
fd: Returns the name or string corresponding to sym.
pt: Symbol
mt: instance
fn: inspect
fs: inspect
fd: Returns the representation of sym as a symbol literal.
pt: Symbol
mt: instance
fn: new
fs: new
fd: 
pt: Symbol
mt: class
fn: to_i
fs: to_i
fd: Returns an integer that is unique for each symbol within a particular execution of a program.
pt: Symbol
mt: instance
fn: to_int
fs: to_int()
fd: ":nodoc:"
pt: Symbol
mt: instance
fn: to_s
fs: to_s
fd: Returns the name or string corresponding to sym.
pt: Symbol
mt: instance
fn: to_sym
fs: to_sym
fd: In general, to_sym returns the Symbol corresponding to an object. As sym is already a symbol, self is returned in this case.
pt: Symbol
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Symbol
mt: instance
fn: yaml_new
fs: yaml_new( klass, tag, val )
fd: 
pt: Symbol
mt: class
fn: new
fs: new()
fd: 
pt: Sync
mt: class
fn: append_features
fs: append_features(cl)
fd: 
pt: Sync_m
mt: class
fn: define_aliases
fs: define_aliases(cl)
fd: 
pt: Sync_m
mt: class
fn: Fail
fs: Fail(*opt)
fd: 
pt: Sync_m::Err
mt: class
fn: Fail
fs: Fail(mode)
fd: 
pt: Sync_m::Err::LockModeFailer
mt: class
fn: Fail
fs: Fail(th)
fd: 
pt: Sync_m::Err::UnknownLocker
mt: class
fn: extend_object
fs: extend_object(obj)
fd: 
pt: Sync_m
mt: class
fn: new
fs: new(*args)
fd: 
pt: Sync_m
mt: class
fn: sync_exclusive?
fs: sync_exclusive?()
fd: 
pt: Sync_m
mt: instance
fn: sync_extended
fs: sync_extended()
fd: 
pt: Sync_m
mt: instance
fn: sync_lock
fs: sync_lock(m = EX)
fd: 
pt: Sync_m
mt: instance
fn: sync_locked?
fs: sync_locked?()
fd: accessing
pt: Sync_m
mt: instance
fn: sync_shared?
fs: sync_shared?()
fd: 
pt: Sync_m
mt: instance
fn: sync_synchronize
fs: sync_synchronize(mode = EX)
fd: 
pt: Sync_m
mt: instance
fn: sync_try_lock
fs: sync_try_lock(mode = EX)
fd: locking methods.
pt: Sync_m
mt: instance
fn: sync_unlock
fs: sync_unlock(m = EX)
fd: 
pt: Sync_m
mt: instance
fn: each
fs: each()
fd: Enumerates rows of the Enumerable objects.
pt: SyncEnumerator
mt: instance
fn: end?
fs: end?(i = nil)
fd: Returns true if the given nth Enumerable object has reached the end. If no argument is given, returns true if any of the Enumerable objects has reached the end.
pt: SyncEnumerator
mt: instance
fn: length
fs: length()
fd: Returns the number of enumerated Enumerable objects, i.e. the size of each row.
pt: SyncEnumerator
mt: instance
fn: new
fs: new(*enums)
fd: Creates a new SyncEnumerator which enumerates rows of given Enumerable objects.
pt: SyncEnumerator
mt: class
fn: size
fs: size()
fd: Returns the number of enumerated Enumerable objects, i.e. the size of each row.
pt: SyncEnumerator
mt: instance
fn: errno
fs: errno
fd: Return this SystemCallError's error number.
pt: SystemCallError
mt: instance
fn: new
fs: new(msg, errno)
fd: If errno corresponds to a known system error code, constructs the appropriate Errno class for that error, otherwise constructs a generic SystemCallError object. The error number is subsequently available via the errno method.
pt: SystemCallError
mt: class
fn: new
fs: new(status=0)
fd: Create a new SystemExit exception with the given status.
pt: SystemExit
mt: class
fn: status
fs: status
fd: Return the status value associated with this system exit.
pt: SystemExit
mt: instance
fn: success?
fs: success?
fd: Returns true if exiting successful, false if not.
pt: SystemExit
mt: instance
fn: accept_nonblock
fs: accept_nonblock
fd: Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an accepted TCPSocket for the incoming connection.
pt: TCPServer
mt: instance
fn: listen
fs: listen( int )
fd: Listens for connections, using the specified int as the backlog. A call to listen only applies if the socket is of type SOCK_STREAM or SOCK_SEQPACKET.
pt: TCPServer
mt: instance
fn: gethostbyname
fs: gethostbyname" Socket.gethostbyname(host)
fd: Resolve host and return name and address information for it, similarly to gethostbyname(3). host can be a domain name or the presentation format of an address.
pt: TCPSocket
mt: class
fn: new
fs: new(remote_host, remote_port, local_host=nil, local_port=nil)
fd: Opens a TCP connection to remote_host on remote_port. If local_host and local_port are specified, then those parameters are used on the local end to establish the connection.
pt: TCPSocket
mt: class
fn: close!
fs: close!()
fd: Closes and unlinks the file.
pt: Tempfile
mt: instance
fn: close
fs: close(unlink_now=false)
fd: Closes the file. If the optional flag is true, unlinks the file after closing.
pt: Tempfile
mt: instance
fn: delete
fs: delete()
fd: "Alias for #unlink"
pt: Tempfile
mt: instance
fn: length
fs: length()
fd: "Alias for #size"
pt: Tempfile
mt: instance
fn: new
fs: new(basename, tmpdir=Dir::tmpdir)
fd: Creates a temporary file of mode 0600 in the temporary directory whose name is basename.pid.n and opens with mode &quot;w+&quot;. A Tempfile object works just like a File object.
pt: Tempfile
mt: class
fn: open
fs: open(*args)
fd: If no block is given, this is a synonym for new().
pt: Tempfile
mt: class
fn: open
fs: open()
fd: Opens or reopens the file with mode &quot;r+&quot;.
pt: Tempfile
mt: instance
fn: path
fs: path()
fd: Returns the full path name of the temporary file.
pt: Tempfile
mt: instance
fn: size
fs: size()
fd: Returns the size of the temporary file. As a side effect, the IO buffer is flushed before determining the size.
pt: Tempfile
mt: instance
fn: unlink
fs: unlink()
fd: Unlinks the file. On UNIX-like systems, it is often a good idea to unlink a temporary file immediately after creating and opening it, because it leaves other programs zero chance to access the file.
pt: Tempfile
mt: instance
fn: find_scalar
fs: find_scalar(key)
fd: Find a scalar value, throwing an exception if not found. This method is used when substituting the %xxx% constructs
pt: TemplatePage::Context
mt: instance
fn: lookup
fs: lookup(key)
fd: Lookup any key in the stack of hashes
pt: TemplatePage::Context
mt: instance
fn: new
fs: new()
fd: 
pt: TemplatePage::Context
mt: class
fn: pop
fs: pop()
fd: 
pt: TemplatePage::Context
mt: instance
fn: push
fs: push(hash)
fd: 
pt: TemplatePage::Context
mt: instance
fn: expand_line
fs: expand_line(line)
fd: "Given an individual line, we look for %xxx% constructs and HREF:ref:name: constructs, substituting for each."
pt: TemplatePage
mt: instance
fn: dup
fs: dup()
fd: Return a copy of ourselves that can be modified without affecting us
pt: TemplatePage::LineReader
mt: instance
fn: new
fs: new(lines)
fd: we're initialized with an array of lines
pt: TemplatePage::LineReader
mt: class
fn: read
fs: read()
fd: read the next line
pt: TemplatePage::LineReader
mt: instance
fn: read_up_to
fs: read_up_to(pattern)
fd: Return a list of lines up to the line that matches a pattern. That last line is discarded.
pt: TemplatePage::LineReader
mt: instance
fn: new
fs: new(*templates)
fd: templates is an array of strings containing the templates. We start at the first, and substitute in subsequent ones where the string !INCLUDE! occurs. For example, we could have the overall page template containing
pt: TemplatePage
mt: class
fn: substitute_into
fs: substitute_into(lines, values)
fd: Substitute a set of key/value pairs into the given template. Keys with scalar values have them substituted directly into the page. Those with array values invoke substitute_array (below), which examples a block of the template once for each row in the array.
pt: TemplatePage
mt: instance
fn: write_html_on
fs: write_html_on(op, value_hash)
fd: Render the templates into HTML, storing the result on op using the method &lt;&lt;. The value_hash contains key/value pairs used to drive the substitution (as described above)
pt: TemplatePage
mt: instance
fn: assert
fs: assert(boolean, message=nil)
fd: Asserts that boolean is not false or nil.
pt: Test::Unit::Assertions
mt: instance
fn: assert_block
fs: assert_block(message="assert_block failed.")
fd: The assertion upon which all other assertions are based. Passes if the block yields true.
pt: Test::Unit::Assertions
mt: instance
fn: assert_equal
fs: assert_equal(expected, actual, message=nil)
fd: Passes if expected == +actual.
pt: Test::Unit::Assertions
mt: instance
fn: assert_in_delta
fs: assert_in_delta(expected_float, actual_float, delta, message="")
fd: Passes if expected_float and actual_float are equal within delta tolerance.
pt: Test::Unit::Assertions
mt: instance
fn: assert_instance_of
fs: assert_instance_of(klass, object, message="")
fd: Passes if object .instance_of? klass
pt: Test::Unit::Assertions
mt: instance
fn: assert_kind_of
fs: assert_kind_of(klass, object, message="")
fd: Passes if object .kind_of? klass
pt: Test::Unit::Assertions
mt: instance
fn: assert_match
fs: assert_match(pattern, string, message="")
fd: Passes if string =~ pattern.
pt: Test::Unit::Assertions
mt: instance
fn: assert_nil
fs: assert_nil(object, message="")
fd: Passes if object is nil.
pt: Test::Unit::Assertions
mt: instance
fn: assert_no_match
fs: assert_no_match(regexp, string, message="")
fd: Passes if regexp !~ string
pt: Test::Unit::Assertions
mt: instance
fn: assert_not_equal
fs: assert_not_equal(expected, actual, message="")
fd: Passes if expected != actual
pt: Test::Unit::Assertions
mt: instance
fn: assert_not_nil
fs: assert_not_nil(object, message="")
fd: Passes if ! object .nil?
pt: Test::Unit::Assertions
mt: instance
fn: assert_not_same
fs: assert_not_same(expected, actual, message="")
fd: Passes if ! actual .equal? expected
pt: Test::Unit::Assertions
mt: instance
fn: assert_nothing_raised
fs: assert_nothing_raised(*args)
fd: Passes if block does not raise an exception.
pt: Test::Unit::Assertions
mt: instance
fn: assert_nothing_thrown
fs: assert_nothing_thrown(message="", &proc)
fd: Passes if block does not throw anything.
pt: Test::Unit::Assertions
mt: instance
fn: assert_operator
fs: assert_operator(object1, operator, object2, message="")
fd: Compares the +object1+ with +object2+ using operator.
pt: Test::Unit::Assertions
mt: instance
fn: assert_raise
fs: assert_raise(*args)
fd: Passes if the block raises one of the given exceptions.
pt: Test::Unit::Assertions
mt: instance
fn: assert_raises
fs: assert_raises(*args, &block)
fd: Alias of assert_raise.
pt: Test::Unit::Assertions
mt: instance
fn: assert_respond_to
fs: assert_respond_to(object, method, message="")
fd: Passes if object .respond_to? method
pt: Test::Unit::Assertions
mt: instance
fn: assert_same
fs: assert_same(expected, actual, message="")
fd: Passes if actual .equal? expected (i.e. they are the same instance).
pt: Test::Unit::Assertions
mt: instance
fn: assert_send
fs: assert_send(send_array, message="")
fd: Passes if the method send returns a true value.
pt: Test::Unit::Assertions
mt: instance
fn: assert_throws
fs: assert_throws(expected_symbol, message="", &proc)
fd: Passes if the block throws expected_symbol
pt: Test::Unit::Assertions
mt: instance
fn: build_message
fs: build_message(head, template=nil, *arguments)
fd: Builds a failure message. head is added before the template and arguments replaces the '?'s positionally in the template.
pt: Test::Unit::Assertions
mt: instance
fn: flunk
fs: flunk(message="Flunked")
fd: Flunk always fails.
pt: Test::Unit::Assertions
mt: instance
fn: use_pp=
fs: use_pp=(value)
fd: Select whether or not to use the pretty-printer. If this option is set to false before any assertions are made, pp.rb will not be required.
pt: Test::Unit::Assertions
mt: class
fn: run
fs: run(force_standalone=false, default_dir=nil, argv=ARGV, &block)
fd: 
pt: Test::Unit::AutoRunner
mt: class
fn: standalone?
fs: standalone?()
fd: 
pt: Test::Unit::AutoRunner
mt: class
fn: add_suite
fs: add_suite(destination, suite)
fd: 
pt: Test::Unit::Collector
mt: instance
fn: collect
fs: collect(*from)
fd: 
pt: Test::Unit::Collector::Dir
mt: instance
fn: collect_file
fs: collect_file(name, suites, already_gathered)
fd: 
pt: Test::Unit::Collector::Dir
mt: instance
fn: find_test_cases
fs: find_test_cases(ignore=[])
fd: 
pt: Test::Unit::Collector::Dir
mt: instance
fn: new
fs: new(dir=::Dir, file=::File, object_space=::ObjectSpace, req=nil)
fd: 
pt: Test::Unit::Collector::Dir
mt: class
fn: realdir
fs: realdir(path)
fd: 
pt: Test::Unit::Collector::Dir
mt: instance
fn: recursive_collect
fs: recursive_collect(name, already_gathered)
fd: 
pt: Test::Unit::Collector::Dir
mt: instance
fn: filter=
fs: filter=(filters)
fd: 
pt: Test::Unit::Collector
mt: instance
fn: include?
fs: include?(test)
fd: 
pt: Test::Unit::Collector
mt: instance
fn: new
fs: new()
fd: 
pt: Test::Unit::Collector
mt: class
fn: collect
fs: collect(name=NAME)
fd: 
pt: Test::Unit::Collector::ObjectSpace
mt: instance
fn: new
fs: new(source=::ObjectSpace)
fd: 
pt: Test::Unit::Collector::ObjectSpace
mt: class
fn: sort
fs: sort(suites)
fd: 
pt: Test::Unit::Collector
mt: instance
fn: long_display
fs: long_display()
fd: Returns a verbose version of the error description.
pt: Test::Unit::Error
mt: instance
fn: message
fs: message()
fd: Returns the message associated with the error.
pt: Test::Unit::Error
mt: instance
fn: new
fs: new(test_name, exception)
fd: Creates a new Error with the given test_name and exception.
pt: Test::Unit::Error
mt: class
fn: short_display
fs: short_display()
fd: Returns a brief version of the error description.
pt: Test::Unit::Error
mt: instance
fn: single_character_display
fs: single_character_display()
fd: Returns a single character representation of an error.
pt: Test::Unit::Error
mt: instance
fn: to_s
fs: to_s()
fd: Overridden to return long_display.
pt: Test::Unit::Error
mt: instance
fn: long_display
fs: long_display()
fd: Returns a verbose version of the error description.
pt: Test::Unit::Failure
mt: instance
fn: new
fs: new(test_name, location, message)
fd: Creates a new Failure with the given location and message.
pt: Test::Unit::Failure
mt: class
fn: short_display
fs: short_display()
fd: Returns a brief version of the error description.
pt: Test::Unit::Failure
mt: instance
fn: single_character_display
fs: single_character_display()
fd: Returns a single character representation of a failure.
pt: Test::Unit::Failure
mt: instance
fn: to_s
fs: to_s()
fd: Overridden to return long_display.
pt: Test::Unit::Failure
mt: instance
fn: run=
fs: run=(flag)
fd: If set to false Test::Unit will not automatically run at exit.
pt: Test::Unit
mt: class
fn: run?
fs: run?()
fd: Automatically run tests at exit?
pt: Test::Unit
mt: class
fn: default_test
fs: default_test()
fd: 
pt: Test::Unit::TestCase
mt: instance
fn: name
fs: name()
fd: Returns a human-readable name for the specific test that this instance of TestCase represents.
pt: Test::Unit::TestCase
mt: instance
fn: new
fs: new(test_method_name)
fd: Creates a new instance of the fixture for running the test represented by test_method_name.
pt: Test::Unit::TestCase
mt: class
fn: run
fs: run(result)
fd: Runs the individual test method represented by this instance of the fixture, collecting statistics, failures and errors in result.
pt: Test::Unit::TestCase
mt: instance
fn: setup
fs: setup()
fd: Called before every test method runs. Can be used to set up fixture information.
pt: Test::Unit::TestCase
mt: instance
fn: size
fs: size()
fd: 
pt: Test::Unit::TestCase
mt: instance
fn: suite
fs: suite()
fd: Rolls up all of the test* methods in the fixture into one suite, creating a new instance of the fixture for each method.
pt: Test::Unit::TestCase
mt: class
fn: teardown
fs: teardown()
fd: Called after every test method runs. Can be used to tear down fixture information.
pt: Test::Unit::TestCase
mt: instance
fn: to_s
fs: to_s()
fd: "Overridden to return #name."
pt: Test::Unit::TestCase
mt: instance
fn: add_assertion
fs: add_assertion()
fd: Records an individual assertion.
pt: Test::Unit::TestResult
mt: instance
fn: add_error
fs: add_error(error)
fd: Records a Test::Unit::Error.
pt: Test::Unit::TestResult
mt: instance
fn: add_failure
fs: add_failure(failure)
fd: Records a Test::Unit::Failure.
pt: Test::Unit::TestResult
mt: instance
fn: add_run
fs: add_run()
fd: Records a test run.
pt: Test::Unit::TestResult
mt: instance
fn: error_count
fs: error_count()
fd: Returns the number of errors this TestResult has recorded.
pt: Test::Unit::TestResult
mt: instance
fn: failure_count
fs: failure_count()
fd: Returns the number of failures this TestResult has recorded.
pt: Test::Unit::TestResult
mt: instance
fn: new
fs: new()
fd: Constructs a new, empty TestResult.
pt: Test::Unit::TestResult
mt: class
fn: passed?
fs: passed?()
fd: Returns whether or not this TestResult represents successful completion.
pt: Test::Unit::TestResult
mt: instance
fn: to_s
fs: to_s()
fd: Returns a string contain the recorded runs, assertions, failures and errors in this TestResult.
pt: Test::Unit::TestResult
mt: instance
fn: delete
fs: delete(test)
fd: 
pt: Test::Unit::TestSuite
mt: instance
fn: empty?
fs: empty?()
fd: 
pt: Test::Unit::TestSuite
mt: instance
fn: new
fs: new(name="Unnamed TestSuite")
fd: Creates a new TestSuite with the given name.
pt: Test::Unit::TestSuite
mt: class
fn: run
fs: run(result, &progress_block)
fd: Runs the tests and/or suites contained in this TestSuite.
pt: Test::Unit::TestSuite
mt: instance
fn: size
fs: size()
fd: Retuns the rolled up number of tests in this suite; i.e. if the suite contains other suites, it counts the tests within those suites, not the suites themselves.
pt: Test::Unit::TestSuite
mt: instance
fn: to_s
fs: to_s()
fd: Overridden to return the name given the suite at creation.
pt: Test::Unit::TestSuite
mt: instance
fn: new
fs: new(suite, output_level=NORMAL, io=STDOUT)
fd: Creates a new TestRunner for running the passed suite. If quiet_mode is true, the output while running is limited to progress dots, errors and failures, and the final result. io specifies where runner output should go to; defaults to STDOUT.
pt: Test::Unit::UI::Console::TestRunner
mt: class
fn: start
fs: start()
fd: Begins the test run.
pt: Test::Unit::UI::Console::TestRunner
mt: instance
fn: new
fs: new(fault)
fd: 
pt: Test::Unit::UI::Fox::FaultListItem
mt: class
fn: add_fault
fs: add_fault(fault)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: attach_to_mediator
fs: attach_to_mediator()
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: clear_fault
fs: clear_fault()
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_application
fs: create_application()
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_button
fs: create_button(parent, text, action)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_detail_panel
fs: create_detail_panel(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_entry
fs: create_entry(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_fault_list
fs: create_fault_list(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_info_panel
fs: create_info_panel(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_label
fs: create_label(parent, text)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_list_panel
fs: create_list_panel(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_main_panel
fs: create_main_panel(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_progress_bar
fs: create_progress_bar(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_suite_panel
fs: create_suite_panel(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_text
fs: create_text(parent)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_tooltip
fs: create_tooltip(app)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: create_window
fs: create_window(app)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: finished
fs: finished(elapsed_time)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: new
fs: new(suite, output_level = NORMAL)
fd: Creates a new TestRunner for running the passed suite.
pt: Test::Unit::UI::Fox::TestRunner
mt: class
fn: output_status
fs: output_status(string)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: raw_show_fault
fs: raw_show_fault(string)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: reset_ui
fs: reset_ui(count)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: result_changed
fs: result_changed(result)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: setup_mediator
fs: setup_mediator()
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: setup_ui
fs: setup_ui()
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: show_fault
fs: show_fault(fault)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: start
fs: start()
fd: Begins the test run.
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: start_ui
fs: start_ui()
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: started
fs: started(result)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: stop
fs: stop()
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: test_started
fs: test_started(test_name)
fd: 
pt: Test::Unit::UI::Fox::TestRunner
mt: instance
fn: set_text
fs: set_text(text)
fd: 
pt: Test::Unit::UI::GTK::EnhancedLabel
mt: instance
fn: set_style
fs: set_style(style)
fd: 
pt: Test::Unit::UI::GTK::EnhancedProgressBar
mt: instance
fn: new
fs: new(fault)
fd: 
pt: Test::Unit::UI::GTK::FaultListItem
mt: class
fn: new
fs: new(suite, output_level = NORMAL)
fd: Creates a new TestRunner for running the passed suite.
pt: Test::Unit::UI::GTK::TestRunner
mt: class
fn: start
fs: start()
fd: Begins the test run.
pt: Test::Unit::UI::GTK::TestRunner
mt: instance
fn: set_text
fs: set_text(text)
fd: 
pt: Test::Unit::UI::GTK2::EnhancedLabel
mt: instance
fn: add_fault
fs: add_fault(fault)
fd: 
pt: Test::Unit::UI::GTK2::FaultList
mt: instance
fn: clear
fs: clear()
fd: 
pt: Test::Unit::UI::GTK2::FaultList
mt: instance
fn: get_fault
fs: get_fault(iter)
fd: 
pt: Test::Unit::UI::GTK2::FaultList
mt: instance
fn: new
fs: new()
fd: 
pt: Test::Unit::UI::GTK2::FaultList
mt: class
fn: new
fs: new(suite, output_level = NORMAL)
fd: 
pt: Test::Unit::UI::GTK2::TestRunner
mt: class
fn: progress_panel
fs: progress_panel()
fd: 
pt: Test::Unit::UI::GTK2::TestRunner
mt: instance
fn: run_button
fs: run_button()
fd: 
pt: Test::Unit::UI::GTK2::TestRunner
mt: instance
fn: start
fs: start()
fd: 
pt: Test::Unit::UI::GTK2::TestRunner
mt: instance
fn: test_finished
fs: test_finished(result)
fd: 
pt: Test::Unit::UI::GTK2::TestRunner
mt: instance
fn: new
fs: new(suite)
fd: Creates a new TestRunnerMediator initialized to run the passed suite.
pt: Test::Unit::UI::TestRunnerMediator
mt: class
fn: run_suite
fs: run_suite()
fd: Runs the suite the TestRunnerMediator was created with.
pt: Test::Unit::UI::TestRunnerMediator
mt: instance
fn: run
fs: run(suite, output_level=NORMAL)
fd: Creates a new TestRunner and runs the suite.
pt: Test::Unit::UI::TestRunnerUtilities
mt: instance
fn: start_command_line_test
fs: start_command_line_test()
fd: Takes care of the ARGV parsing and suite determination necessary for running one of the TestRunners from the command line.
pt: Test::Unit::UI::TestRunnerUtilities
mt: instance
fn: new
fs: new(suite, output_level = NORMAL)
fd: Creates a new TestRunner for running the passed suite.
pt: Test::Unit::UI::Tk::TestRunner
mt: class
fn: start
fs: start()
fd: Begins the test run.
pt: Test::Unit::UI::Tk::TestRunner
mt: instance
fn: filter_backtrace
fs: filter_backtrace(backtrace, prefix=nil)
fd: 
pt: Test::Unit::Util::BacktraceFilter
mt: instance
fn: add_listener
fs: add_listener(channel_name, listener_key=NOTHING)
fd: Adds the passed proc as a listener on the channel indicated by channel_name. listener_key is used to remove the listener later; if none is specified, the proc itself is used.
pt: Test::Unit::Util::Observable
mt: instance
fn: notify_listeners
fs: notify_listeners(channel_name, *arguments)
fd: Calls all the procs registered on the channel indicated by channel_name. If value is specified, it is passed in to the procs, otherwise they are called with no arguments.
pt: Test::Unit::Util::Observable
mt: instance
fn: remove_listener
fs: remove_listener(channel_name, listener_key)
fd: Removes the listener indicated by listener_key from the channel indicated by channel_name. Returns the registered proc, or nil if none was found.
pt: Test::Unit::Util::Observable
mt: instance
fn: eql?
fs: eql?(other)
fd: "Alias for #=="
pt: Test::Unit::Util::ProcWrapper
mt: instance
fn: hash
fs: hash()
fd: 
pt: Test::Unit::Util::ProcWrapper
mt: instance
fn: new
fs: new(a_proc)
fd: Creates a new wrapper for a_proc.
pt: Test::Unit::Util::ProcWrapper
mt: class
fn: to_proc
fs: to_proc()
fd: 
pt: Test::Unit::Util::ProcWrapper
mt: instance
fn: abort_on_exception=
fs: abort_on_exception=
fd: When set to true, all threads will abort if an exception is raised. Returns the new state.
pt: Thread
mt: class
fn: abort_on_exception=
fs: abort_on_exception=
fd: When set to true, causes all threads (including the main program) to abort if an exception is raised in thr. The process will effectively exit(0).
pt: Thread
mt: instance
fn: abort_on_exception
fs: abort_on_exception
fd: Returns the status of the global ``abort on exception'' condition. The default is false. When set to true, or if the global $DEBUG flag is true (perhaps because the command line option -d was specified) all threads will abort (the process will exit(0)) if an exception is raised in any thread. See also Thread::abort_on_exception=.
pt: Thread
mt: class
fn: abort_on_exception
fs: abort_on_exception
fd: Returns the status of the thread-local ``abort on exception'' condition for thr. The default is false. See also Thread::abort_on_exception=.
pt: Thread
mt: instance
fn: alive?
fs: alive?
fd: Returns true if thr is running or sleeping.
pt: Thread
mt: instance
fn: critical=
fs: critical=
fd: "Sets the status of the global ``thread critical'' condition and returns it. When set to true, prohibits scheduling of any existing thread. Does not block new threads from being created and run. Certain thread operations (such as stopping or killing a thread, sleeping in the current thread, and raising an exception) may cause a thread to be scheduled even when in a critical section. Thread::critical is not intended for daily use: it is primarily there to support folks writing threading libraries."
pt: Thread
mt: class
fn: critical
fs: critical
fd: Returns the status of the global ``thread critical'' condition.
pt: Thread
mt: class
fn: current
fs: current
fd: Returns the currently executing thread.
pt: Thread
mt: class
fn: exclusive
fs: exclusive()
fd: Wraps a block in Thread.critical, restoring the original value upon exit from the critical section.
pt: Thread
mt: class
fn: exit!
fs: exit!
fd: Terminates thr without calling ensure clauses and schedules another thread to be run, returning the terminated Thread. If this is the main thread, or the last thread, exits the process.
pt: Thread
mt: instance
fn: exit
fs: exit
fd: Terminates the currently running thread and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exit the process.
pt: Thread
mt: class
fn: exit
fs: exit
fd: Terminates thr and schedules another thread to be run, returning the terminated Thread. If this is the main thread, or the last thread, exits the process.
pt: Thread
mt: instance
fn: fork
fs: fork([args]*)
fd: Basically the same as Thread::new. However, if class Thread is subclassed, then calling start in that subclass will not invoke the subclass's initialize method.
pt: Thread
mt: class
fn: group
fs: group
fd: Returns the ThreadGroup which contains thr, or nil if the thread is not a member of any group.
pt: Thread
mt: instance
fn: inspect
fs: inspect
fd: Dump the name, id, and status of thr to a string.
pt: Thread
mt: instance
fn: join
fs: join(limit)
fd: The calling thread will suspend execution and run thr. Does not return until thr exits or until limit seconds have passed. If the time limit expires, nil will be returned, otherwise thr is returned.
pt: Thread
mt: instance
fn: key?
fs: key?(sym)
fd: Returns true if the given string (or symbol) exists as a thread-local variable.
pt: Thread
mt: instance
fn: keys
fs: keys
fd: Returns an an array of the names of the thread-local variables (as Symbols).
pt: Thread
mt: instance
fn: kill!
fs: kill!
fd: Terminates thr without calling ensure clauses and schedules another thread to be run, returning the terminated Thread. If this is the main thread, or the last thread, exits the process.
pt: Thread
mt: instance
fn: kill
fs: kill(thread)
fd: Causes the given thread to exit (see Thread::exit).
pt: Thread
mt: class
fn: kill
fs: kill
fd: Terminates thr and schedules another thread to be run, returning the terminated Thread. If this is the main thread, or the last thread, exits the process.
pt: Thread
mt: instance
fn: list
fs: list
fd: Returns an array of Thread objects for all threads that are either runnable or stopped.
pt: Thread
mt: class
fn: main
fs: main
fd: Returns the main thread for the process.
pt: Thread
mt: class
fn: new
fs: new([arg]*)
fd: Creates and runs a new thread to execute the instructions given in block. Any arguments passed to Thread::new are passed into the block.
pt: Thread
mt: class
fn: pass
fs: pass
fd: Invokes the thread scheduler to pass execution to another thread.
pt: Thread
mt: class
fn: priority=
fs: priority=
fd: Sets the priority of thr to integer. Higher-priority threads will run before lower-priority threads.
pt: Thread
mt: instance
fn: priority
fs: priority
fd: Returns the priority of thr. Default is inherited from the current thread which creating the new thread, or zero for the initial main thread; higher-priority threads will run before lower-priority threads.
pt: Thread
mt: instance
fn: raise
fs: raise(exception)
fd: Raises an exception (see Kernel::raise) from thr. The caller does not have to be thr.
pt: Thread
mt: instance
fn: run
fs: run
fd: Wakes up thr, making it eligible for scheduling. If not in a critical section, then invokes the scheduler.
pt: Thread
mt: instance
fn: safe_level
fs: safe_level
fd: Returns the safe level in effect for thr. Setting thread-local safe levels can help when implementing sandboxes which run insecure code.
pt: Thread
mt: instance
fn: start
fs: start([args]*)
fd: Basically the same as Thread::new. However, if class Thread is subclassed, then calling start in that subclass will not invoke the subclass's initialize method.
pt: Thread
mt: class
fn: status
fs: status
fd: "Returns the status of thr: ``sleep'' if thr is sleeping or waiting on I/O, ``run'' if thr is executing, ``aborting'' if thr is aborting, false if thr terminated normally, and nil if thr terminated with an exception."
pt: Thread
mt: instance
fn: stop?
fs: stop?
fd: Returns true if thr is dead or sleeping.
pt: Thread
mt: instance
fn: stop
fs: stop
fd: Stops execution of the current thread, putting it into a ``sleep'' state, and schedules execution of another thread. Resets the ``critical'' condition to false.
pt: Thread
mt: class
fn: terminate!
fs: terminate!
fd: Terminates thr without calling ensure clauses and schedules another thread to be run, returning the terminated Thread. If this is the main thread, or the last thread, exits the process.
pt: Thread
mt: instance
fn: terminate
fs: terminate
fd: Terminates thr and schedules another thread to be run, returning the terminated Thread. If this is the main thread, or the last thread, exits the process.
pt: Thread
mt: instance
fn: value
fs: value
fd: Waits for thr to complete (via Thread#join) and returns its value.
pt: Thread
mt: instance
fn: wakeup
fs: wakeup
fd: Marks thr as eligible for scheduling (it may still remain blocked on I/O, however). Does not invoke the scheduler (see Thread#run).
pt: Thread
mt: instance
fn: add
fs: add(thread)
fd: Adds the given thread to this group, removing it from any other group to which it may have previously belonged.
pt: ThreadGroup
mt: instance
fn: enclose
fs: enclose
fd: Prevents threads from being added to or removed from the receiving ThreadGroup. New threads can still be started in an enclosed ThreadGroup.
pt: ThreadGroup
mt: instance
fn: enclosed?
fs: enclosed?
fd: Returns true if thgrp is enclosed. See also ThreadGroup#enclose.
pt: ThreadGroup
mt: instance
fn: list
fs: list
fd: Returns an array of all existing Thread objects that belong to this group.
pt: ThreadGroup
mt: instance
fn: all_waits
fs: all_waits(*threads)
fd: Waits until all specified threads have terminated. If a block is provided, it is executed for each thread termination.
pt: ThreadsWait
mt: class
fn: all_waits
fs: all_waits()
fd: Waits until all of the specified threads are terminated. If a block is supplied for the method, it is executed for each thread termination.
pt: ThreadsWait
mt: instance
fn: empty?
fs: empty?()
fd: Returns true if there are no threads to be synchronized.
pt: ThreadsWait
mt: instance
fn: finished?
fs: finished?()
fd: Returns true if any thread has terminated.
pt: ThreadsWait
mt: instance
fn: join
fs: join(*threads)
fd: Waits for specified threads to terminate.
pt: ThreadsWait
mt: instance
fn: join_nowait
fs: join_nowait(*threads)
fd: Specifies the threads that this object will wait for, but does not actually wait.
pt: ThreadsWait
mt: instance
fn: new
fs: new(*threads)
fd: Creates a ThreadsWait object, specifying the threads to wait on. Non-blocking.
pt: ThreadsWait
mt: class
fn: next_wait
fs: next_wait(nonblock = nil)
fd: Waits until any of the specified threads has terminated, and returns the one that does.
pt: ThreadsWait
mt: instance
fn: asctime
fs: asctime
fd: Returns a canonical string representation of time.
pt: Time
mt: instance
fn: at
fs: at( aTime )
fd: Creates a new time object with the value given by aTime, or the given number of seconds (and optional microseconds) from epoch. A non-portable feature allows the offset to be negative on some systems.
pt: Time
mt: class
fn: ctime
fs: ctime
fd: Returns a canonical string representation of time.
pt: Time
mt: instance
fn: day
fs: day
fd: Returns the day of the month (1..n) for time.
pt: Time
mt: instance
fn: dst?
fs: dst?
fd: Returns true if time occurs during Daylight Saving Time in its time zone.
pt: Time
mt: instance
fn: eql?
fs: eql?(other_time)
fd: Return true if time and other_time are both Time objects with the same seconds and fractional seconds.
pt: Time
mt: instance
fn: getgm
fs: getgm
fd: Returns a new new_time object representing time in UTC.
pt: Time
mt: instance
fn: getlocal
fs: getlocal
fd: Returns a new new_time object representing time in local time (using the local time zone in effect for this process).
pt: Time
mt: instance
fn: getutc
fs: getutc
fd: Returns a new new_time object representing time in UTC.
pt: Time
mt: instance
fn: gm
fs: gm( year [, month, day, hour, min, sec, usec] )
fd: Creates a time based on given values, interpreted as UTC (GMT). The year must be specified. Other values default to the minimum value for that field (and may be nil or omitted). Months may be specified by numbers from 1 to 12, or by the three-letter English month names. Hours are specified on a 24-hour clock (0..23). Raises an ArgumentError if any values are out of range. Will also accept ten arguments in the order output by Time#to_a.
pt: Time
mt: class
fn: gmt?
fs: gmt?
fd: Returns true if time represents a time in UTC (GMT).
pt: Time
mt: instance
fn: gmt_offset
fs: gmt_offset
fd: Returns the offset in seconds between the timezone of time and UTC.
pt: Time
mt: instance
fn: gmtime
fs: gmtime
fd: Converts time to UTC (GMT), modifying the receiver.
pt: Time
mt: instance
fn: gmtoff
fs: gmtoff
fd: Returns the offset in seconds between the timezone of time and UTC.
pt: Time
mt: instance
fn: hash
fs: hash
fd: Return a hash code for this time object.
pt: Time
mt: instance
fn: hour
fs: hour
fd: Returns the hour of the day (0..23) for time.
pt: Time
mt: instance
fn: httpdate
fs: httpdate(date)
fd: Parses date as HTTP-date defined by RFC 2616 and converts it to a Time object.
pt: Time
mt: class
fn: httpdate
fs: httpdate()
fd: "Returns a string which represents the time as rfc1123-date of HTTP-date defined by RFC 2616:"
pt: Time
mt: instance
fn: inspect
fs: inspect
fd: Returns a string representing time. Equivalent to calling Time#strftime with a format string of ``%a %b %d %H:%M:%S %Z %Y''.
pt: Time
mt: instance
fn: isdst
fs: isdst
fd: Returns true if time occurs during Daylight Saving Time in its time zone.
pt: Time
mt: instance
fn: iso8601
fs: iso8601(fraction_digits=0)
fd: "Alias for #xmlschema"
pt: Time
mt: instance
fn: local
fs: local( year [, month, day, hour, min, sec, usec] )
fd: Same as Time::gm, but interprets the values in the local time zone.
pt: Time
mt: class
fn: localtime
fs: localtime
fd: Converts time to local time (using the local time zone in effect for this process) modifying the receiver.
pt: Time
mt: instance
fn: marshal_dump
fs: marshal_dump()
fd: undocumented
pt: Time
mt: instance
fn: marshal_load
fs: marshal_load(p1)
fd: undocumented
pt: Time
mt: instance
fn: mday
fs: mday
fd: Returns the day of the month (1..n) for time.
pt: Time
mt: instance
fn: min
fs: min
fd: Returns the minute of the hour (0..59) for time.
pt: Time
mt: instance
fn: mktime
fs: mktime( year, month, day, hour, min, sec, usec )
fd: Same as Time::gm, but interprets the values in the local time zone.
pt: Time
mt: class
fn: mon
fs: mon
fd: Returns the month of the year (1..12) for time.
pt: Time
mt: instance
fn: month
fs: month
fd: Returns the month of the year (1..12) for time.
pt: Time
mt: instance
fn: new
fs: new
fd: "Document-method: now"
pt: Time
mt: class
fn: now
fs: now
fd: Synonym for Time.new. Returns a Time object initialized tot he current system time.
pt: Time
mt: class
fn: parse
fs: parse(date, now=Time.now)
fd: Parses date using Date._parse and converts it to a Time object.
pt: Time
mt: class
fn: rfc2822
fs: rfc2822(date)
fd: Parses date as date-time defined by RFC 2822 and converts it to a Time object. The format is identical to the date format defined by RFC 822 and updated by RFC 1123.
pt: Time
mt: class
fn: rfc2822
fs: rfc2822()
fd: "Returns a string which represents the time as date-time defined by RFC 2822:"
pt: Time
mt: instance
fn: rfc822
fs: rfc822()
fd: "Alias for #rfc2822"
pt: Time
mt: instance
fn: sec
fs: sec
fd: Returns the second of the minute (0..60)[Yes, seconds really can range from zero to 60. This allows the system to inject leap seconds every now and then to correct for the fact that years are not really a convenient number of hours long.] for time.
pt: Time
mt: instance
fn: strftime
fs: strftime( string )
fd: Formats time according to the directives in the given format string. Any text not listed as a directive will be passed through to the output string.
pt: Time
mt: instance
fn: succ
fs: succ
fd: Return a new time object, one second later than time.
pt: Time
mt: instance
fn: times
fs: times
fd: Deprecated in favor of Process::times
pt: Time
mt: class
fn: to_a
fs: to_a
fd: "Returns a ten-element array of values for time: {[ sec, min, hour, day, month, year, wday, yday, isdst, zone ]}. See the individual methods for an explanation of the valid ranges of each value. The ten elements can be passed directly to Time::utc or Time::local to create a new Time."
pt: Time
mt: instance
fn: to_f
fs: to_f
fd: Returns the value of time as a floating point number of seconds since epoch.
pt: Time
mt: instance
fn: to_i
fs: to_i
fd: Returns the value of time as an integer number of seconds since epoch.
pt: Time
mt: instance
fn: to_s
fs: to_s
fd: Returns a string representing time. Equivalent to calling Time#strftime with a format string of ``%a %b %d %H:%M:%S %Z %Y''.
pt: Time
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: Time
mt: instance
fn: tv_sec
fs: tv_sec
fd: Returns the value of time as an integer number of seconds since epoch.
pt: Time
mt: instance
fn: tv_usec
fs: tv_usec
fd: Returns just the number of microseconds for time.
pt: Time
mt: instance
fn: usec
fs: usec
fd: Returns just the number of microseconds for time.
pt: Time
mt: instance
fn: utc?
fs: utc?
fd: Returns true if time represents a time in UTC (GMT).
pt: Time
mt: instance
fn: utc
fs: utc( year [, month, day, hour, min, sec, usec] )
fd: Creates a time based on given values, interpreted as UTC (GMT). The year must be specified. Other values default to the minimum value for that field (and may be nil or omitted). Months may be specified by numbers from 1 to 12, or by the three-letter English month names. Hours are specified on a 24-hour clock (0..23). Raises an ArgumentError if any values are out of range. Will also accept ten arguments in the order output by Time#to_a.
pt: Time
mt: class
fn: utc
fs: utc
fd: Converts time to UTC (GMT), modifying the receiver.
pt: Time
mt: instance
fn: utc_offset
fs: utc_offset
fd: Returns the offset in seconds between the timezone of time and UTC.
pt: Time
mt: instance
fn: w3cdtf
fs: w3cdtf(date)
fd: 
pt: Time
mt: class
fn: wday
fs: wday
fd: Returns an integer representing the day of the week, 0..6, with Sunday == 0.
pt: Time
mt: instance
fn: xmlschema
fs: xmlschema(date)
fd: Parses date as dateTime defined by XML Schema and converts it to a Time object. The format is restricted version of the format defined by ISO 8601.
pt: Time
mt: class
fn: xmlschema
fs: xmlschema(fraction_digits=0)
fd: "Returns a string which represents the time as dateTime defined by XML Schema:"
pt: Time
mt: instance
fn: yaml_new
fs: yaml_new( klass, tag, val )
fd: 
pt: Time
mt: class
fn: yday
fs: yday
fd: Returns an integer representing the day of the year, 1..366.
pt: Time
mt: instance
fn: year
fs: year
fd: Returns the year for time (including the century).
pt: Time
mt: instance
fn: zone
fs: zone
fd: Returns the name of the time zone used for time. As of Ruby 1.8, returns ``UTC'' rather than ``GMT'' for UTC times.
pt: Time
mt: instance
fn: zone_offset
fs: zone_offset(zone, year=Time.now.year)
fd: 
pt: Time
mt: class
fn: timeout
fs: timeout(sec, exception=Error)
fd: Executes the method's block. If the block execution terminates before sec seconds has passed, it returns true. If not, it terminates the execution and raises exception (which defaults to Timeout::Error).
pt: Timeout
mt: instance
fn: add_token
fs: add_token(tk)
fd: 
pt: TokenStream
mt: instance
fn: add_tokens
fs: add_tokens(tks)
fd: 
pt: TokenStream
mt: instance
fn: pop_token
fs: pop_token()
fd: 
pt: TokenStream
mt: instance
fn: start_collecting_tokens
fs: start_collecting_tokens()
fd: 
pt: TokenStream
mt: instance
fn: token_stream
fs: token_stream()
fd: 
pt: TokenStream
mt: instance
fn: add_filter
fs: add_filter(p = proc)
fd: 
pt: Tracer
mt: class
fn: add_filter
fs: add_filter(p = proc)
fd: 
pt: Tracer
mt: instance
fn: get_line
fs: get_line(file, line)
fd: 
pt: Tracer
mt: instance
fn: get_thread_no
fs: get_thread_no()
fd: 
pt: Tracer
mt: instance
fn: new
fs: new()
fd: 
pt: Tracer
mt: class
fn: "off"
fs: "off"()
fd: 
pt: Tracer
mt: class
fn: "off"
fs: "off"()
fd: 
pt: Tracer
mt: instance
fn: "on"
fs: "on"()
fd: 
pt: Tracer
mt: class
fn: "on"
fs: "on"()
fd: 
pt: Tracer
mt: instance
fn: set_get_line_procs
fs: set_get_line_procs(file_name, p = proc)
fd: 
pt: Tracer
mt: class
fn: set_get_line_procs
fs: set_get_line_procs(file, p = proc)
fd: 
pt: Tracer
mt: instance
fn: stdout
fs: stdout()
fd: 
pt: Tracer
mt: instance
fn: trace_func
fs: trace_func(*vars)
fd: 
pt: Tracer
mt: class
fn: trace_func
fs: trace_func(event, file, line, id, binding, klass, *)
fd: 
pt: Tracer
mt: instance
fn: new
fs: new
fd: 
pt: TrueClass
mt: class
fn: to_s
fs: to_s
fd: The string representation of true is &quot;true&quot;.
pt: TrueClass
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: TrueClass
mt: instance
fn: each_strongly_connected_component
fs: each_strongly_connected_component( {|nodes| ...}
fd: "The iterator version of the #strongly_connected_components method. obj.each_strongly_connected_component is similar to obj.strongly_connected_components.each, but modification of obj during the iteration may lead to unexpected results."
pt: TSort
mt: instance
fn: each_strongly_connected_component_from
fs: each_strongly_connected_component_from(node, id_map={}, stack=[])
fd: Iterates over strongly connected component in the subgraph reachable from node.
pt: TSort
mt: instance
fn: strongly_connected_components
fs: strongly_connected_components()
fd: Returns strongly connected components as an array of arrays of nodes. The array is sorted from children to parents. Each elements of the array represents a strongly connected component.
pt: TSort
mt: instance
fn: tsort
fs: tsort()
fd: Returns a topologically sorted array of nodes. The array is sorted from children to parents, i.e. the first element has no child and the last node has no parent.
pt: TSort
mt: instance
fn: tsort_each
fs: tsort_each( {|node| ...}
fd: "The iterator version of the #tsort method. obj.tsort_each is similar to obj.tsort.each, but modification of obj during the iteration may lead to unexpected results."
pt: TSort
mt: instance
fn: tsort_each_child
fs: tsort_each_child(node)
fd: Should be implemented by a extended class.
pt: TSort
mt: instance
fn: tsort_each_node
fs: tsort_each_node( {|node| ...}
fd: Should be implemented by a extended class.
pt: TSort
mt: instance
fn: bind
fs: bind(host, port)
fd: 
pt: UDPSocket
mt: instance
fn: connect
fs: connect(host, port)
fd: 
pt: UDPSocket
mt: instance
fn: recvfrom_nonblock
fs: recvfrom_nonblock(maxlen)
fd: Receives up to maxlen bytes from udpsocket using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. flags is zero or more of the MSG_ options. The first element of the results, mesg, is the data received. The second element, sender_inet_addr, is an array to represent the sender address.
pt: UDPSocket
mt: instance
fn: send
fs: send(mesg, flags, *rest)
fd: 
pt: UDPSocket
mt: instance
fn: arity
fs: arity
fd: Returns an indication of the number of arguments accepted by a method. Returns a nonnegative integer for methods that take a fixed number of arguments. For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. For methods written in C, returns -1 if the call takes a variable number of arguments.
pt: UnboundMethod
mt: instance
fn: bind
fs: bind(obj)
fd: Bind umeth to obj. If Klass was the class from which umeth was obtained, obj.kind_of?(Klass) must be true.
pt: UnboundMethod
mt: instance
fn: clone
fs: clone()
fd: "MISSING: documentation"
pt: UnboundMethod
mt: instance
fn: inspect
fs: inspect
fd: Show the name of the underlying method.
pt: UnboundMethod
mt: instance
fn: to_s
fs: to_s
fd: Show the name of the underlying method.
pt: UnboundMethod
mt: instance
fn: accept_nonblock
fs: accept_nonblock
fd: Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an accepted UNIXSocket for the incoming connection.
pt: UNIXServer
mt: instance
fn: listen
fs: listen( int )
fd: Listens for connections, using the specified int as the backlog. A call to listen only applies if the socket is of type SOCK_STREAM or SOCK_SEQPACKET.
pt: UNIXServer
mt: instance
fn: decode
fs: decode(str)
fd: "Alias for #unescape"
pt: URI::Escape
mt: instance
fn: encode
fs: encode(str, unsafe = UNSAFE)
fd: "Alias for #escape"
pt: URI::Escape
mt: instance
fn: escape
fs: escape(str, unsafe = UNSAFE)
fd: "  URI.escape(str [, unsafe])\n"
pt: URI::Escape
mt: instance
fn: unescape
fs: unescape(str)
fd: "  URI.unescape(str)\n"
pt: URI::Escape
mt: instance
fn: extract
fs: extract(str, schemes = nil, &block)
fd: "  URI::extract(str[, schemes][,&amp;blk])\n"
pt: URI
mt: class
fn: build
fs: build(args)
fd: Creates a new URI::FTP object from components of URI::FTP with check. It is scheme, userinfo, host, port, path and typecode. It provided by an Array or a Hash. typecode is &quot;a&quot;, &quot;i&quot; or &quot;d&quot;.
pt: URI::FTP
mt: class
fn: new
fs: new(*arg)
fd: Create a new URI::FTP object from ``generic'' components with no check.
pt: URI::FTP
mt: class
fn: new2
fs: new2(user, password, host, port, path, typecode = nil, arg_check = true)
fd: 
pt: URI::FTP
mt: class
fn: to_s
fs: to_s()
fd: 
pt: URI::FTP
mt: instance
fn: typecode=
fs: typecode=(typecode)
fd: 
pt: URI::FTP
mt: instance
fn: absolute?
fs: absolute?()
fd: Checks if URI is an absolute one
pt: URI::Generic
mt: instance
fn: absolute
fs: absolute()
fd: "Alias for #absolute?"
pt: URI::Generic
mt: instance
fn: build
fs: build(args)
fd: "See #new"
pt: URI::Generic
mt: class
fn: build2
fs: build2(args)
fd: "See #new"
pt: URI::Generic
mt: class
fn: coerce
fs: coerce(oth)
fd: 
pt: URI::Generic
mt: instance
fn: component
fs: component()
fd: Components of the URI in the order.
pt: URI::Generic
mt: class
fn: component
fs: component()
fd: 
pt: URI::Generic
mt: instance
fn: default_port
fs: default_port()
fd: Returns default port
pt: URI::Generic
mt: class
fn: default_port
fs: default_port()
fd: 
pt: URI::Generic
mt: instance
fn: eql?
fs: eql?(oth)
fd: 
pt: URI::Generic
mt: instance
fn: find_proxy
fs: find_proxy()
fd: returns a proxy URI. The proxy URI is obtained from environment variables such as http_proxy, ftp_proxy, no_proxy, etc. If there is no proper proxy, nil is returned.
pt: URI::Generic
mt: instance
fn: fragment=
fs: fragment=(v)
fd: 
pt: URI::Generic
mt: instance
fn: hash
fs: hash()
fd: 
pt: URI::Generic
mt: instance
fn: hierarchical?
fs: hierarchical?()
fd: Checks if URI has a path
pt: URI::Generic
mt: instance
fn: host=
fs: host=(v)
fd: 
pt: URI::Generic
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: URI::Generic
mt: instance
fn: merge!
fs: merge!(oth)
fd: URI or String
pt: URI::Generic
mt: instance
fn: merge
fs: merge(oth)
fd: URI or String
pt: URI::Generic
mt: instance
fn: new
fs: new(scheme, userinfo, host, port, registry, path, opaque, query, fragment, arg_check = false)
fd: Protocol scheme, i.e. 'http','ftp','mailto' and so on.
pt: URI::Generic
mt: class
fn: normalize!
fs: normalize!()
fd: "Destructive version of #normalize"
pt: URI::Generic
mt: instance
fn: normalize
fs: normalize()
fd: Returns normalized URI
pt: URI::Generic
mt: instance
fn: opaque=
fs: opaque=(v)
fd: 
pt: URI::Generic
mt: instance
fn: password=
fs: password=(password)
fd: 
pt: URI::Generic
mt: instance
fn: password
fs: password()
fd: 
pt: URI::Generic
mt: instance
fn: path=
fs: path=(v)
fd: 
pt: URI::Generic
mt: instance
fn: port=
fs: port=(v)
fd: 
pt: URI::Generic
mt: instance
fn: query=
fs: query=(v)
fd: 
pt: URI::Generic
mt: instance
fn: registry=
fs: registry=(v)
fd: 
pt: URI::Generic
mt: instance
fn: relative?
fs: relative?()
fd: Checks if URI is relative
pt: URI::Generic
mt: instance
fn: route_from
fs: route_from(oth)
fd: URI or String
pt: URI::Generic
mt: instance
fn: route_to
fs: route_to(oth)
fd: URI or String
pt: URI::Generic
mt: instance
fn: scheme=
fs: scheme=(v)
fd: 
pt: URI::Generic
mt: instance
fn: select
fs: select(*components)
fd: Multiple Symbol arguments defined in URI::HTTP
pt: URI::Generic
mt: instance
fn: to_s
fs: to_s()
fd: Constructs String from URI
pt: URI::Generic
mt: instance
fn: use_registry
fs: use_registry()
fd: "DOC: FIXME!"
pt: URI::Generic
mt: class
fn: user=
fs: user=(user)
fd: 
pt: URI::Generic
mt: instance
fn: user
fs: user()
fd: 
pt: URI::Generic
mt: instance
fn: userinfo=
fs: userinfo=(userinfo)
fd: Sets userinfo, argument is string like 'name:pass'
pt: URI::Generic
mt: instance
fn: userinfo
fs: userinfo()
fd: 
pt: URI::Generic
mt: instance
fn: build
fs: build(args)
fd: Create a new URI::HTTP object from components, with syntax checking.
pt: URI::HTTP
mt: class
fn: new
fs: new(*arg)
fd: Create a new URI::HTTP object from generic URI components as per RFC 2396. No HTTP-specific syntax checking (as per RFC 1738) is performed.
pt: URI::HTTP
mt: class
fn: request_uri
fs: request_uri()
fd: Returns the full path for an HTTP request, as required by Net::HTTP::Get.
pt: URI::HTTP
mt: instance
fn: join
fs: join(*str)
fd: "  URI::join(str[, str, ...])\n"
pt: URI
mt: class
fn: attributes=
fs: attributes=(val)
fd: 
pt: URI::LDAP
mt: instance
fn: attributes
fs: attributes()
fd: 
pt: URI::LDAP
mt: instance
fn: build
fs: build(args)
fd: 
pt: URI::LDAP
mt: class
fn: dn=
fs: dn=(val)
fd: 
pt: URI::LDAP
mt: instance
fn: dn
fs: dn()
fd: 
pt: URI::LDAP
mt: instance
fn: extensions=
fs: extensions=(val)
fd: 
pt: URI::LDAP
mt: instance
fn: extensions
fs: extensions()
fd: 
pt: URI::LDAP
mt: instance
fn: filter=
fs: filter=(val)
fd: 
pt: URI::LDAP
mt: instance
fn: filter
fs: filter()
fd: 
pt: URI::LDAP
mt: instance
fn: hierarchical?
fs: hierarchical?()
fd: 
pt: URI::LDAP
mt: instance
fn: new
fs: new(*arg)
fd: 
pt: URI::LDAP
mt: class
fn: scope=
fs: scope=(val)
fd: 
pt: URI::LDAP
mt: instance
fn: scope
fs: scope()
fd: 
pt: URI::LDAP
mt: instance
fn: build
fs: build(args)
fd: Creates a new URI::MailTo object from components, with syntax checking.
pt: URI::MailTo
mt: class
fn: headers=
fs: headers=(v)
fd: 
pt: URI::MailTo
mt: instance
fn: new
fs: new(*arg)
fd: Creates a new URI::MailTo object from generic URL components with no syntax checking.
pt: URI::MailTo
mt: class
fn: to=
fs: to=(v)
fd: 
pt: URI::MailTo
mt: instance
fn: to_mailtext
fs: to_mailtext()
fd: Returns the RFC822 e-mail text equivalent of the URL, as a String.
pt: URI::MailTo
mt: instance
fn: to_rfc822text
fs: to_rfc822text()
fd: "Alias for #to_mailtext"
pt: URI::MailTo
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: URI::MailTo
mt: instance
fn: parse
fs: parse(uri)
fd: "  URI::parse(uri_str)\n"
pt: URI
mt: class
fn: regexp
fs: regexp(schemes = nil)
fd: "  URI::regexp([match_schemes])\n"
pt: URI
mt: class
fn: split
fs: split(uri)
fd: "  URI::split(uri)\n"
pt: URI
mt: class
fn: clone
fs: clone()
fd: Return a copy of the vector.
pt: Vector
mt: instance
fn: coerce
fs: coerce(other)
fd: "FIXME: describe Vector#coerce."
pt: Vector
mt: instance
fn: collect
fs: collect( {|e| ...}
fd: Like Array#collect.
pt: Vector
mt: instance
fn: collect2
fs: collect2(v)
fd: Collects (as in Enumerable#collect) over the elements of this vector and v in conjunction.
pt: Vector
mt: instance
fn: compare_by
fs: compare_by(elements)
fd: For internal use.
pt: Vector
mt: instance
fn: covector
fs: covector()
fd: Creates a single-row matrix from this vector.
pt: Vector
mt: instance
fn: each2
fs: each2(v)
fd: Iterate over the elements of this vector and v in conjunction.
pt: Vector
mt: instance
fn: elements
fs: elements(array, copy = true)
fd: Creates a vector from an Array. The optional second argument specifies whether the array itself or a copy is used internally.
pt: Vector
mt: class
fn: eqn?
fs: eqn?(other)
fd: "Alias for #=="
pt: Vector
mt: instance
fn: hash
fs: hash()
fd: Return a hash-code for the vector.
pt: Vector
mt: instance
fn: init_elements
fs: init_elements(array, copy)
fd: For internal use.
pt: Vector
mt: instance
fn: inner_product
fs: inner_product(v)
fd: Returns the inner product of this vector with the other.
pt: Vector
mt: instance
fn: inspect
fs: inspect()
fd: Overrides Object#inspect
pt: Vector
mt: instance
fn: map
fs: map(
fd: "Alias for #collect"
pt: Vector
mt: instance
fn: map2
fs: map2(v)
fd: Like Vector#collect2, but returns a Vector instead of an Array.
pt: Vector
mt: instance
fn: new
fs: new(method, array, copy)
fd: For internal use.
pt: Vector
mt: class
fn: r
fs: r()
fd: Returns the modulus (Pythagorean distance) of the vector.
pt: Vector
mt: instance
fn: size
fs: size()
fd: Returns the number of elements in the vector.
pt: Vector
mt: instance
fn: to_a
fs: to_a()
fd: Returns the elements of the vector in an array.
pt: Vector
mt: instance
fn: to_s
fs: to_s()
fd: Overrides Object#to_s
pt: Vector
mt: instance
fn: new
fs: new(orig)
fd: Create a new WeakRef from orig.
pt: WeakRef
mt: class
fn: weakref_alive?
fs: weakref_alive?()
fd: Returns true if the referenced object still exists, and false if it has been garbage collected.
pt: WeakRef
mt: instance
fn: format
fs: format(format_string, params)
fd: 
pt: WEBrick::AccessLog
mt: instance
fn: setup_params
fs: setup_params(config, req, res)
fd: This format specification is a subset of mod_log_config of Apache.
pt: WEBrick::AccessLog
mt: instance
fn: close
fs: close()
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: debug?
fs: debug?()
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: debug
fs: debug(msg)
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: error?
fs: error?()
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: error
fs: error(msg)
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: fatal?
fs: fatal?()
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: fatal
fs: fatal(msg)
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: info?
fs: info?()
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: info
fs: info(msg)
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: log
fs: log(level, data)
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: new
fs: new(log_file=nil, level=nil)
fd: 
pt: WEBrick::BasicLog
mt: class
fn: warn?
fs: warn?()
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: warn
fs: warn(msg)
fd: 
pt: WEBrick::BasicLog
mt: instance
fn: new
fs: new(*args)
fd: 
pt: WEBrick::CGI
mt: class
fn: service
fs: service(req, res)
fd: 
pt: WEBrick::CGI
mt: instance
fn: addr
fs: addr()
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: cert
fs: cert()
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: cipher
fs: cipher()
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: each
fs: each()
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: gets
fs: gets(eol=LF)
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: new
fs: new(config, env, stdin, stdout)
fd: 
pt: WEBrick::CGI::Socket
mt: class
fn: peer_cert
fs: peer_cert()
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: peer_cert_chain
fs: peer_cert_chain()
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: peeraddr
fs: peeraddr()
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: read
fs: read(size=nil)
fd: 
pt: WEBrick::CGI::Socket
mt: instance
fn: start
fs: start(env=ENV, stdin=$stdin, stdout=$stdout)
fd: 
pt: WEBrick::CGI
mt: instance
fn: expires=
fs: expires=(t)
fd: 
pt: WEBrick::Cookie
mt: instance
fn: expires
fs: expires()
fd: 
pt: WEBrick::Cookie
mt: instance
fn: new
fs: new(name, value)
fd: attr_accessor :comment_url, :discard, :port
pt: WEBrick::Cookie
mt: class
fn: parse
fs: parse(str)
fd: Cookie::parse()
pt: WEBrick::Cookie
mt: class
fn: parse_set_cookie
fs: parse_set_cookie(str)
fd: 
pt: WEBrick::Cookie
mt: class
fn: parse_set_cookies
fs: parse_set_cookies(str)
fd: 
pt: WEBrick::Cookie
mt: class
fn: to_s
fs: to_s()
fd: 
pt: WEBrick::Cookie
mt: instance
fn: start
fs: start()
fd: 
pt: WEBrick::Daemon
mt: class
fn: listen
fs: listen(address, port)
fd: 
pt: WEBrick::GenericServer
mt: instance
fn: new
fs: new(config={}, default=Config::General)
fd: 
pt: WEBrick::GenericServer
mt: class
fn: run
fs: run(sock)
fd: 
pt: WEBrick::GenericServer
mt: instance
fn: setup_ssl_context
fs: setup_ssl_context(config)
fd: 
pt: WEBrick::GenericServer
mt: instance
fn: shutdown
fs: shutdown()
fd: 
pt: WEBrick::GenericServer
mt: instance
fn: ssl_context
fs: ssl_context()
fd: 
pt: WEBrick::GenericServer
mt: instance
fn: start
fs: start(&block)
fd: 
pt: WEBrick::GenericServer
mt: instance
fn: stop
fs: stop()
fd: 
pt: WEBrick::GenericServer
mt: instance
fn: escape
fs: escape(string)
fd: 
pt: WEBrick::HTMLUtils
mt: instance
fn: basic_auth
fs: basic_auth(req, res, realm, &block)
fd: 
pt: WEBrick::HTTPAuth
mt: instance
fn: authenticate
fs: authenticate(req, res)
fd: 
pt: WEBrick::HTTPAuth::BasicAuth
mt: instance
fn: challenge
fs: challenge(req, res)
fd: 
pt: WEBrick::HTTPAuth::BasicAuth
mt: instance
fn: make_passwd
fs: make_passwd(realm, user, pass)
fd: 
pt: WEBrick::HTTPAuth::BasicAuth
mt: class
fn: new
fs: new(config, default=Config::BasicAuth)
fd: 
pt: WEBrick::HTTPAuth::BasicAuth
mt: class
fn: authenticate
fs: authenticate(req, res)
fd: 
pt: WEBrick::HTTPAuth::DigestAuth
mt: instance
fn: challenge
fs: challenge(req, res, stale=false)
fd: 
pt: WEBrick::HTTPAuth::DigestAuth
mt: instance
fn: make_passwd
fs: make_passwd(realm, user, pass)
fd: 
pt: WEBrick::HTTPAuth::DigestAuth
mt: class
fn: new
fs: new(config, default=Config::DigestAuth)
fd: 
pt: WEBrick::HTTPAuth::DigestAuth
mt: class
fn: delete_passwd
fs: delete_passwd(realm, user)
fd: 
pt: WEBrick::HTTPAuth::Htdigest
mt: instance
fn: each
fs: each()
fd: 
pt: WEBrick::HTTPAuth::Htdigest
mt: instance
fn: flush
fs: flush(output=nil)
fd: 
pt: WEBrick::HTTPAuth::Htdigest
mt: instance
fn: get_passwd
fs: get_passwd(realm, user, reload_db)
fd: 
pt: WEBrick::HTTPAuth::Htdigest
mt: instance
fn: new
fs: new(path)
fd: 
pt: WEBrick::HTTPAuth::Htdigest
mt: class
fn: reload
fs: reload()
fd: 
pt: WEBrick::HTTPAuth::Htdigest
mt: instance
fn: set_passwd
fs: set_passwd(realm, user, pass)
fd: 
pt: WEBrick::HTTPAuth::Htdigest
mt: instance
fn: add
fs: add(group, members)
fd: 
pt: WEBrick::HTTPAuth::Htgroup
mt: instance
fn: flush
fs: flush(output=nil)
fd: 
pt: WEBrick::HTTPAuth::Htgroup
mt: instance
fn: members
fs: members(group)
fd: 
pt: WEBrick::HTTPAuth::Htgroup
mt: instance
fn: new
fs: new(path)
fd: 
pt: WEBrick::HTTPAuth::Htgroup
mt: class
fn: reload
fs: reload()
fd: 
pt: WEBrick::HTTPAuth::Htgroup
mt: instance
fn: delete_passwd
fs: delete_passwd(realm, user)
fd: 
pt: WEBrick::HTTPAuth::Htpasswd
mt: instance
fn: each
fs: each()
fd: 
pt: WEBrick::HTTPAuth::Htpasswd
mt: instance
fn: flush
fs: flush(output=nil)
fd: 
pt: WEBrick::HTTPAuth::Htpasswd
mt: instance
fn: get_passwd
fs: get_passwd(realm, user, reload_db)
fd: 
pt: WEBrick::HTTPAuth::Htpasswd
mt: instance
fn: new
fs: new(path)
fd: 
pt: WEBrick::HTTPAuth::Htpasswd
mt: class
fn: reload
fs: reload()
fd: 
pt: WEBrick::HTTPAuth::Htpasswd
mt: instance
fn: set_passwd
fs: set_passwd(realm, user, pass)
fd: 
pt: WEBrick::HTTPAuth::Htpasswd
mt: instance
fn: proxy_basic_auth
fs: proxy_basic_auth(req, res, realm, &block)
fd: 
pt: WEBrick::HTTPAuth
mt: instance
fn: check_uri
fs: check_uri(req, auth_req)
fd: 
pt: WEBrick::HTTPAuth::ProxyDigestAuth
mt: instance
fn: get_passwd
fs: get_passwd(realm, user, reload_db=false)
fd: 
pt: WEBrick::HTTPAuth::UserDB
mt: instance
fn: make_passwd
fs: make_passwd(realm, user, pass)
fd: 
pt: WEBrick::HTTPAuth::UserDB
mt: instance
fn: set_passwd
fs: set_passwd(realm, user, pass)
fd: 
pt: WEBrick::HTTPAuth::UserDB
mt: instance
fn: choose_header
fs: choose_header(src, dst)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: do_OPTIONS
fs: do_OPTIONS(req, res)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: new
fs: new(config)
fd: 
pt: WEBrick::HTTPProxyServer
mt: class
fn: proxy_auth
fs: proxy_auth(req, res)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: proxy_connect
fs: proxy_connect(req, res)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: proxy_service
fs: proxy_service(req, res)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: proxy_uri
fs: proxy_uri(req, res)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: service
fs: service(req, res)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: set_cookie
fs: set_cookie(src, dst)
fd: "Net::HTTP is stupid about the multiple header fields. Here is workaround:"
pt: WEBrick::HTTPProxyServer
mt: instance
fn: set_via
fs: set_via(h)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: split_field
fs: split_field(f)
fd: 
pt: WEBrick::HTTPProxyServer
mt: instance
fn: body
fs: body(&block)
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: content_length
fs: content_length()
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: content_type
fs: content_type()
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: each
fs: each"()
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: fixup
fs: fixup()
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: keep_alive?
fs: keep_alive?()
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: meta_vars
fs: meta_vars()
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: new
fs: new(config)
fd: 
pt: WEBrick::HTTPRequest
mt: class
fn: orig_meta_vars
fs: orig_meta_vars()
fd: "Alias for #meta_vars"
pt: WEBrick::HTTPRequest
mt: instance
fn: orig_parse
fs: orig_parse(socket=nil)
fd: "Alias for #parse"
pt: WEBrick::HTTPRequest
mt: instance
fn: orig_parse_uri
fs: orig_parse_uri(str, scheme="http")
fd: "Alias for #parse_uri"
pt: WEBrick::HTTPRequest
mt: instance
fn: parse
fs: parse(socket=nil)
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: query
fs: query()
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: WEBrick::HTTPRequest
mt: instance
fn: chunked=
fs: chunked=(val)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: chunked?
fs: chunked?()
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: content_length=
fs: content_length=(len)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: content_length
fs: content_length()
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: content_type=
fs: content_type=(type)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: content_type
fs: content_type()
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: each
fs: each()
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: keep_alive?
fs: keep_alive?()
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: new
fs: new(config)
fd: 
pt: WEBrick::HTTPResponse
mt: class
fn: send_body
fs: send_body(socket)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: send_header
fs: send_header(socket)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: send_response
fs: send_response(socket)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: set_error
fs: set_error(ex, backtrace=false)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: set_redirect
fs: set_redirect(status, url)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: setup_header
fs: setup_header()
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: status=
fs: status=(status)
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: status_line
fs: status_line()
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: WEBrick::HTTPResponse
mt: instance
fn: access_log
fs: access_log(config, req, res)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: do_OPTIONS
fs: do_OPTIONS(req, res)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: lookup_server
fs: lookup_server(req)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: mount
fs: mount(dir, servlet, *options)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: mount_proc
fs: mount_proc(dir, proc=nil, &block)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: delete
fs: delete(dir)
fd: 
pt: WEBrick::HTTPServer::MountTable
mt: instance
fn: new
fs: new()
fd: 
pt: WEBrick::HTTPServer::MountTable
mt: class
fn: scan
fs: scan(path)
fd: 
pt: WEBrick::HTTPServer::MountTable
mt: instance
fn: new
fs: new(config={}, default=Config::HTTP)
fd: 
pt: WEBrick::HTTPServer
mt: class
fn: run
fs: run(sock)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: search_servlet
fs: search_servlet(path)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: service
fs: service(req, res)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: umount
fs: umount(dir)
fd: "Alias for #unmount"
pt: WEBrick::HTTPServer
mt: instance
fn: unmount
fs: unmount(dir)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: virtual_host
fs: virtual_host(server)
fd: 
pt: WEBrick::HTTPServer
mt: instance
fn: do_GET
fs: do_GET(req, res)
fd: 
pt: WEBrick::HTTPServlet::AbstractServlet
mt: instance
fn: do_HEAD
fs: do_HEAD(req, res)
fd: 
pt: WEBrick::HTTPServlet::AbstractServlet
mt: instance
fn: do_OPTIONS
fs: do_OPTIONS(req, res)
fd: 
pt: WEBrick::HTTPServlet::AbstractServlet
mt: instance
fn: get_instance
fs: get_instance(config, *options)
fd: 
pt: WEBrick::HTTPServlet::AbstractServlet
mt: class
fn: new
fs: new(server, *options)
fd: 
pt: WEBrick::HTTPServlet::AbstractServlet
mt: class
fn: service
fs: service(req, res)
fd: 
pt: WEBrick::HTTPServlet::AbstractServlet
mt: instance
fn: do_GET
fs: do_GET(req, res)
fd: 
pt: WEBrick::HTTPServlet::CGIHandler
mt: instance
fn: do_POST
fs: do_POST(req, res)
fd: "Alias for #do_GET"
pt: WEBrick::HTTPServlet::CGIHandler
mt: instance
fn: new
fs: new(server, name)
fd: 
pt: WEBrick::HTTPServlet::CGIHandler
mt: class
fn: do_GET
fs: do_GET(req, res)
fd: 
pt: WEBrick::HTTPServlet::DefaultFileHandler
mt: instance
fn: make_partial_content
fs: make_partial_content(req, res, filename, filesize)
fd: 
pt: WEBrick::HTTPServlet::DefaultFileHandler
mt: instance
fn: new
fs: new(server, local_path)
fd: 
pt: WEBrick::HTTPServlet::DefaultFileHandler
mt: class
fn: not_modified?
fs: not_modified?(req, res, mtime, etag)
fd: 
pt: WEBrick::HTTPServlet::DefaultFileHandler
mt: instance
fn: prepare_range
fs: prepare_range(range, filesize)
fd: 
pt: WEBrick::HTTPServlet::DefaultFileHandler
mt: instance
fn: do_GET
fs: do_GET(req, res)
fd: 
pt: WEBrick::HTTPServlet::ERBHandler
mt: instance
fn: do_POST
fs: do_POST(req, res)
fd: "Alias for #do_GET"
pt: WEBrick::HTTPServlet::ERBHandler
mt: instance
fn: new
fs: new(server, name)
fd: 
pt: WEBrick::HTTPServlet::ERBHandler
mt: class
fn: add_handler
fs: add_handler(suffix, handler)
fd: 
pt: WEBrick::HTTPServlet::FileHandler
mt: class
fn: do_GET
fs: do_GET(req, res)
fd: 
pt: WEBrick::HTTPServlet::FileHandler
mt: instance
fn: do_OPTIONS
fs: do_OPTIONS(req, res)
fd: 
pt: WEBrick::HTTPServlet::FileHandler
mt: instance
fn: do_POST
fs: do_POST(req, res)
fd: 
pt: WEBrick::HTTPServlet::FileHandler
mt: instance
fn: new
fs: new(server, root, options={}, default=Config::FileHandler)
fd: 
pt: WEBrick::HTTPServlet::FileHandler
mt: class
fn: remove_handler
fs: remove_handler(suffix)
fd: 
pt: WEBrick::HTTPServlet::FileHandler
mt: class
fn: service
fs: service(req, res)
fd: 
pt: WEBrick::HTTPServlet::FileHandler
mt: instance
fn: do_GET
fs: do_GET(request, response)
fd: 
pt: WEBrick::HTTPServlet::ProcHandler
mt: instance
fn: do_POST
fs: do_POST(request, response)
fd: "Alias for #do_GET"
pt: WEBrick::HTTPServlet::ProcHandler
mt: instance
fn: get_instance
fs: get_instance(server, *options)
fd: 
pt: WEBrick::HTTPServlet::ProcHandler
mt: instance
fn: new
fs: new(proc)
fd: 
pt: WEBrick::HTTPServlet::ProcHandler
mt: class
fn: client_error?
fs: client_error?(code)
fd: 
pt: WEBrick::HTTPStatus
mt: instance
fn: error?
fs: error?(code)
fd: 
pt: WEBrick::HTTPStatus
mt: instance
fn: info?
fs: info?(code)
fd: 
pt: WEBrick::HTTPStatus
mt: instance
fn: reason_phrase
fs: reason_phrase(code)
fd: 
pt: WEBrick::HTTPStatus
mt: instance
fn: redirect?
fs: redirect?(code)
fd: 
pt: WEBrick::HTTPStatus
mt: instance
fn: server_error?
fs: server_error?(code)
fd: 
pt: WEBrick::HTTPStatus
mt: instance
fn: success?
fs: success?(code)
fd: 
pt: WEBrick::HTTPStatus
mt: instance
fn: dequote
fs: dequote(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: escape
fs: escape(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: escape8bit
fs: escape8bit(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: escape_form
fs: escape_form(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: escape_path
fs: escape_path(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: append_data
fs: append_data(data)
fd: 
pt: WEBrick::HTTPUtils::FormData
mt: instance
fn: each_data
fs: each_data()
fd: 
pt: WEBrick::HTTPUtils::FormData
mt: instance
fn: list
fs: list()
fd: 
pt: WEBrick::HTTPUtils::FormData
mt: instance
fn: new
fs: new(*args)
fd: 
pt: WEBrick::HTTPUtils::FormData
mt: class
fn: to_ary
fs: to_ary()
fd: "Alias for #list"
pt: WEBrick::HTTPUtils::FormData
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: WEBrick::HTTPUtils::FormData
mt: instance
fn: load_mime_types
fs: load_mime_types(file)
fd: Load Apache compatible mime.types file.
pt: WEBrick::HTTPUtils
mt: instance
fn: mime_type
fs: mime_type(filename, mime_tab)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: normalize_path
fs: normalize_path(path)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: parse_form_data
fs: parse_form_data(io, boundary)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: parse_header
fs: parse_header(raw)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: parse_query
fs: parse_query(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: parse_qvalues
fs: parse_qvalues(value)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: parse_range_header
fs: parse_range_header(ranges_specifier)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: quote
fs: quote(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: split_header_value
fs: split_header_value(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: unescape
fs: unescape(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: unescape_form
fs: unescape_form(str)
fd: 
pt: WEBrick::HTTPUtils
mt: instance
fn: convert
fs: convert(version)
fd: 
pt: WEBrick::HTTPVersion
mt: class
fn: new
fs: new(version)
fd: 
pt: WEBrick::HTTPVersion
mt: class
fn: to_s
fs: to_s()
fd: 
pt: WEBrick::HTTPVersion
mt: instance
fn: debug
fs: debug(msg = nil)
fd: 
pt: WEBrick::Log
mt: instance
fn: log
fs: log(level, data)
fd: 
pt: WEBrick::Log
mt: instance
fn: new
fs: new(log_file=nil, level=nil)
fd: 
pt: WEBrick::Log
mt: class
fn: start
fs: start()
fd: 
pt: WEBrick::SimpleServer
mt: class
fn: create_listeners
fs: create_listeners(address, port, logger=nil)
fd: 
pt: WEBrick::Utils
mt: instance
fn: create_self_signed_cert
fs: create_self_signed_cert(bits, cn, comment)
fd: 
pt: WEBrick::Utils
mt: instance
fn: getservername
fs: getservername()
fd: 
pt: WEBrick::Utils
mt: instance
fn: random_string
fs: random_string(len)
fd: 
pt: WEBrick::Utils
mt: instance
fn: set_close_on_exec
fs: set_close_on_exec(io)
fd: 
pt: WEBrick::Utils
mt: instance
fn: set_non_blocking
fs: set_non_blocking(io)
fd: 
pt: WEBrick::Utils
mt: instance
fn: su
fs: su(user)
fd: 
pt: WEBrick::Utils
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Binding
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Binding
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Binding
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::Binding
mt: instance
fn: add_type
fs: add_type(complextype)
fd: "ToDo: simpletype must be accepted..."
pt: WSDL::Definitions
mt: instance
fn: array_complextype
fs: array_complextype()
fd: 
pt: WSDL::Definitions
mt: class
fn: binding
fs: binding(name)
fd: 
pt: WSDL::Definitions
mt: instance
fn: bindings
fs: bindings()
fd: 
pt: WSDL::Definitions
mt: instance
fn: collect_attributes
fs: collect_attributes()
fd: 
pt: WSDL::Definitions
mt: instance
fn: collect_complextypes
fs: collect_complextypes()
fd: 
pt: WSDL::Definitions
mt: instance
fn: collect_elements
fs: collect_elements()
fd: 
pt: WSDL::Definitions
mt: instance
fn: collect_faulttypes
fs: collect_faulttypes()
fd: 
pt: WSDL::Definitions
mt: instance
fn: collect_simpletypes
fs: collect_simpletypes()
fd: 
pt: WSDL::Definitions
mt: instance
fn: exception_complextype
fs: exception_complextype()
fd: 
pt: WSDL::Definitions
mt: class
fn: fault_complextype
fs: fault_complextype()
fd: 
pt: WSDL::Definitions
mt: class
fn: inspect
fs: inspect()
fd: 
pt: WSDL::Definitions
mt: instance
fn: message
fs: message(name)
fd: 
pt: WSDL::Definitions
mt: instance
fn: messages
fs: messages()
fd: 
pt: WSDL::Definitions
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Definitions
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Definitions
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Definitions
mt: class
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Definitions
mt: instance
fn: porttype
fs: porttype(name)
fd: 
pt: WSDL::Definitions
mt: instance
fn: porttype_binding
fs: porttype_binding(name)
fd: 
pt: WSDL::Definitions
mt: instance
fn: porttypes
fs: porttypes()
fd: 
pt: WSDL::Definitions
mt: instance
fn: service
fs: service(name)
fd: 
pt: WSDL::Definitions
mt: instance
fn: services
fs: services()
fd: 
pt: WSDL::Definitions
mt: instance
fn: soap_rpc_complextypes
fs: soap_rpc_complextypes()
fd: 
pt: WSDL::Definitions
mt: class
fn: soap_rpc_complextypes
fs: soap_rpc_complextypes(binding)
fd: 
pt: WSDL::Definitions
mt: instance
fn: targetnamespace=
fs: targetnamespace=(targetnamespace)
fd: 
pt: WSDL::Definitions
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Documentation
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Documentation
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Documentation
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Import
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Import
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Import
mt: instance
fn: import
fs: import(location, originalroot = nil)
fd: 
pt: WSDL::Importer
mt: class
fn: inspect
fs: inspect()
fd: 
pt: WSDL::Info
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Info
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Info
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Info
mt: instance
fn: parse_epilogue
fs: parse_epilogue()
fd: 
pt: WSDL::Info
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Message
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Message
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Message
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::Message
mt: instance
fn: input_info
fs: input_info()
fd: 
pt: WSDL::Operation
mt: instance
fn: inputname
fs: inputname()
fd: 
pt: WSDL::Operation
mt: instance
fn: inputparts
fs: inputparts()
fd: 
pt: WSDL::Operation
mt: instance
fn: new
fs: new(op_name, optype_name, parts)
fd: 
pt: WSDL::Operation::NameInfo
mt: class
fn: new
fs: new()
fd: 
pt: WSDL::Operation
mt: class
fn: output_info
fs: output_info()
fd: 
pt: WSDL::Operation
mt: instance
fn: outputname
fs: outputname()
fd: 
pt: WSDL::Operation
mt: instance
fn: outputparts
fs: outputparts()
fd: 
pt: WSDL::Operation
mt: instance
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Operation
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Operation
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::Operation
mt: instance
fn: find_operation
fs: find_operation()
fd: 
pt: WSDL::OperationBinding
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::OperationBinding
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::OperationBinding
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::OperationBinding
mt: instance
fn: porttype
fs: porttype()
fd: 
pt: WSDL::OperationBinding
mt: instance
fn: soapaction
fs: soapaction()
fd: 
pt: WSDL::OperationBinding
mt: instance
fn: soapoperation_name
fs: soapoperation_name()
fd: 
pt: WSDL::OperationBinding
mt: instance
fn: soapoperation_style
fs: soapoperation_style()
fd: 
pt: WSDL::OperationBinding
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::OperationBinding
mt: instance
fn: find_message
fs: find_message()
fd: 
pt: WSDL::Param
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Param
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Param
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Param
mt: instance
fn: soapbody_use
fs: soapbody_use()
fd: 
pt: WSDL::Param
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::Param
mt: instance
fn: characters
fs: characters(text)
fd: 
pt: WSDL::Parser
mt: instance
fn: charset
fs: charset()
fd: 
pt: WSDL::Parser
mt: instance
fn: end_element
fs: end_element(name)
fd: 
pt: WSDL::Parser
mt: instance
fn: new
fs: new(opt = {})
fd: 
pt: WSDL::Parser
mt: class
fn: parse
fs: parse(string_or_readable)
fd: 
pt: WSDL::Parser
mt: instance
fn: new
fs: new(ns, name, node)
fd: 
pt: WSDL::Parser::ParseFrame
mt: class
fn: start_element
fs: start_element(name, attrs)
fd: 
pt: WSDL::Parser
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Part
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Part
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Part
mt: instance
fn: find_binding
fs: find_binding()
fd: 
pt: WSDL::Port
mt: instance
fn: inputoperation_map
fs: inputoperation_map()
fd: 
pt: WSDL::Port
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Port
mt: class
fn: outputoperation_map
fs: outputoperation_map()
fd: 
pt: WSDL::Port
mt: instance
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Port
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Port
mt: instance
fn: porttype
fs: porttype()
fd: 
pt: WSDL::Port
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::Port
mt: instance
fn: find_binding
fs: find_binding()
fd: 
pt: WSDL::PortType
mt: instance
fn: locations
fs: locations()
fd: 
pt: WSDL::PortType
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::PortType
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::PortType
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::PortType
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::PortType
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Service
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Service
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Service
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::Service
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::SOAP::Address
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::SOAP::Address
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::SOAP::Address
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::SOAP::Binding
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::SOAP::Binding
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::SOAP::Binding
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::SOAP::Body
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::SOAP::Body
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::SOAP::Body
mt: instance
fn: dump
fs: dump(service_name)
fd: 
pt: WSDL::SOAP::CGIStubCreator
mt: instance
fn: new
fs: new(definitions)
fd: 
pt: WSDL::SOAP::CGIStubCreator
mt: class
fn: dump
fs: dump(type = nil)
fd: 
pt: WSDL::SOAP::ClassDefCreator
mt: instance
fn: new
fs: new(definitions)
fd: 
pt: WSDL::SOAP::ClassDefCreator
mt: class
fn: basetype_mapped_class
fs: basetype_mapped_class(name)
fd: 
pt: WSDL::SOAP::ClassDefCreatorSupport
mt: instance
fn: create_class_name
fs: create_class_name(qname)
fd: 
pt: WSDL::SOAP::ClassDefCreatorSupport
mt: instance
fn: dq
fs: dq(ele)
fd: 
pt: WSDL::SOAP::ClassDefCreatorSupport
mt: instance
fn: dqname
fs: dqname(qname)
fd: 
pt: WSDL::SOAP::ClassDefCreatorSupport
mt: instance
fn: dump_method_signature
fs: dump_method_signature(operation)
fd: 
pt: WSDL::SOAP::ClassDefCreatorSupport
mt: instance
fn: ndq
fs: ndq(ele)
fd: 
pt: WSDL::SOAP::ClassDefCreatorSupport
mt: instance
fn: sym
fs: sym(ele)
fd: 
pt: WSDL::SOAP::ClassDefCreatorSupport
mt: instance
fn: dump
fs: dump(service_name)
fd: 
pt: WSDL::SOAP::ClientSkeltonCreator
mt: instance
fn: new
fs: new(definitions)
fd: 
pt: WSDL::SOAP::ClientSkeltonCreator
mt: class
fn: dump
fs: dump(porttype = nil)
fd: 
pt: WSDL::SOAP::DriverCreator
mt: instance
fn: new
fs: new(definitions)
fd: 
pt: WSDL::SOAP::DriverCreator
mt: class
fn: new
fs: new()
fd: 
pt: WSDL::SOAP::Fault
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::SOAP::Fault
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::SOAP::Fault
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::SOAP::Fault
mt: instance
fn: find_message
fs: find_message()
fd: 
pt: WSDL::SOAP::Header
mt: instance
fn: find_part
fs: find_part()
fd: 
pt: WSDL::SOAP::Header
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::SOAP::Header
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::SOAP::Header
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::SOAP::Header
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::SOAP::Header
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::SOAP::HeaderFault
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::SOAP::HeaderFault
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::SOAP::HeaderFault
mt: instance
fn: dump
fs: dump(types)
fd: 
pt: WSDL::SOAP::MappingRegistryCreator
mt: instance
fn: new
fs: new(definitions)
fd: 
pt: WSDL::SOAP::MappingRegistryCreator
mt: class
fn: collect_documentparameter
fs: collect_documentparameter(operation)
fd: 
pt: WSDL::SOAP::MethodDefCreator
mt: instance
fn: collect_rpcparameter
fs: collect_rpcparameter(operation)
fd: 
pt: WSDL::SOAP::MethodDefCreator
mt: instance
fn: dump
fs: dump(porttype)
fd: 
pt: WSDL::SOAP::MethodDefCreator
mt: instance
fn: new
fs: new(definitions)
fd: 
pt: WSDL::SOAP::MethodDefCreator
mt: class
fn: input_info
fs: input_info()
fd: 
pt: WSDL::SOAP::Operation
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::SOAP::Operation
mt: class
fn: operation_style
fs: operation_style()
fd: 
pt: WSDL::SOAP::Operation
mt: instance
fn: new
fs: new(style, op_name, optype_name, headerparts, bodyparts, faultpart, soapaction)
fd: 
pt: WSDL::SOAP::Operation::OperationInfo
mt: class
fn: output_info
fs: output_info()
fd: 
pt: WSDL::SOAP::Operation
mt: instance
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::SOAP::Operation
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::SOAP::Operation
mt: instance
fn: dump
fs: dump(porttype = nil)
fd: 
pt: WSDL::SOAP::ServantSkeltonCreator
mt: instance
fn: new
fs: new(definitions)
fd: 
pt: WSDL::SOAP::ServantSkeltonCreator
mt: class
fn: dump
fs: dump(service_name)
fd: 
pt: WSDL::SOAP::StandaloneServerStubCreator
mt: instance
fn: new
fs: new(definitions)
fd: 
pt: WSDL::SOAP::StandaloneServerStubCreator
mt: class
fn: new
fs: new()
fd: 
pt: WSDL::SOAP::WSDL2Ruby
mt: class
fn: run
fs: run()
fd: 
pt: WSDL::SOAP::WSDL2Ruby
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::Types
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::Types
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::Types
mt: instance
fn: elementformdefault
fs: elementformdefault()
fd: 
pt: WSDL::XMLSchema::All
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::All
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::All
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::All
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::All
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Annotation
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Annotation
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Annotation
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Any
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Any
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Any
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::Any
mt: instance
fn: attr_reader_ref
fs: attr_reader_ref(symbol)
fd: 
pt: WSDL::XMLSchema::Attribute
mt: class
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Attribute
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Attribute
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Attribute
mt: instance
fn: refelement
fs: refelement()
fd: 
pt: WSDL::XMLSchema::Attribute
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::Attribute
mt: instance
fn: elementformdefault
fs: elementformdefault()
fd: 
pt: WSDL::XMLSchema::Choice
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Choice
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Choice
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Choice
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::Choice
mt: instance
fn: basetype
fs: basetype()
fd: 
pt: WSDL::XMLSchema::ComplexContent
mt: instance
fn: elementformdefault
fs: elementformdefault()
fd: 
pt: WSDL::XMLSchema::ComplexContent
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::ComplexContent
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::ComplexContent
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::ComplexContent
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::ComplexContent
mt: instance
fn: all_elements=
fs: all_elements=(elements)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: check_type
fs: check_type()
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: child_defined_complextype
fs: child_defined_complextype(name)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: child_type
fs: child_type(name = nil)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: compoundtype
fs: compoundtype()
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: each_element
fs: each_element()
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: elementformdefault
fs: elementformdefault()
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: find_aryelement
fs: find_aryelement()
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: find_arytype
fs: find_arytype()
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: find_element
fs: find_element(name)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: find_element_by_name
fs: find_element_by_name(name)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: new
fs: new(name = nil)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: sequence_elements=
fs: sequence_elements=(elements)
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::ComplexType
mt: instance
fn: each
fs: each()
fd: 
pt: WSDL::XMLSchema::Content
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Content
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Content
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Content
mt: instance
fn: parse_epilogue
fs: parse_epilogue()
fd: 
pt: WSDL::XMLSchema::Content
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::Content
mt: instance
fn: attr_reader_ref
fs: attr_reader_ref(symbol)
fd: 
pt: WSDL::XMLSchema::Element
mt: class
fn: attributes
fs: attributes()
fd: 
pt: WSDL::XMLSchema::Element
mt: instance
fn: elementform
fs: elementform()
fd: 
pt: WSDL::XMLSchema::Element
mt: instance
fn: elementformdefault
fs: elementformdefault()
fd: 
pt: WSDL::XMLSchema::Element
mt: instance
fn: map_as_array?
fs: map_as_array?()
fd: 
pt: WSDL::XMLSchema::Element
mt: instance
fn: new
fs: new(name = nil, type = nil)
fd: 
pt: WSDL::XMLSchema::Element
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Element
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Element
mt: instance
fn: refelement
fs: refelement()
fd: 
pt: WSDL::XMLSchema::Element
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::Element
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Enumeration
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Enumeration
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Enumeration
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Import
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Import
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Import
mt: instance
fn: import
fs: import(location, originalroot = nil)
fd: 
pt: WSDL::XMLSchema::Importer
mt: class
fn: import
fs: import(location, originalroot = nil)
fd: 
pt: WSDL::XMLSchema::Importer
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Importer
mt: class
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Include
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Include
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Include
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Length
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Length
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Length
mt: instance
fn: characters
fs: characters(text)
fd: 
pt: WSDL::XMLSchema::Parser
mt: instance
fn: charset
fs: charset()
fd: 
pt: WSDL::XMLSchema::Parser
mt: instance
fn: end_element
fs: end_element(name)
fd: 
pt: WSDL::XMLSchema::Parser
mt: instance
fn: new
fs: new(opt = {})
fd: 
pt: WSDL::XMLSchema::Parser
mt: class
fn: parse
fs: parse(string_or_readable)
fd: 
pt: WSDL::XMLSchema::Parser
mt: instance
fn: new
fs: new(ns, name, node)
fd: 
pt: WSDL::XMLSchema::Parser::ParseFrame
mt: class
fn: start_element
fs: start_element(name, attrs)
fd: 
pt: WSDL::XMLSchema::Parser
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Pattern
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Pattern
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Pattern
mt: instance
fn: collect_attributes
fs: collect_attributes()
fd: 
pt: WSDL::XMLSchema::Schema
mt: instance
fn: collect_complextypes
fs: collect_complextypes()
fd: 
pt: WSDL::XMLSchema::Schema
mt: instance
fn: collect_elements
fs: collect_elements()
fd: 
pt: WSDL::XMLSchema::Schema
mt: instance
fn: collect_simpletypes
fs: collect_simpletypes()
fd: 
pt: WSDL::XMLSchema::Schema
mt: instance
fn: location=
fs: location=(location)
fd: 
pt: WSDL::XMLSchema::Schema
mt: instance
fn: location
fs: location()
fd: 
pt: WSDL::XMLSchema::Schema
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Schema
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Schema
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Schema
mt: class
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Schema
mt: instance
fn: elementformdefault
fs: elementformdefault()
fd: 
pt: WSDL::XMLSchema::Sequence
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Sequence
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Sequence
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Sequence
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::Sequence
mt: instance
fn: base
fs: base()
fd: 
pt: WSDL::XMLSchema::SimpleContent
mt: instance
fn: check_lexical_format
fs: check_lexical_format(value)
fd: 
pt: WSDL::XMLSchema::SimpleContent
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::SimpleContent
mt: class
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::SimpleContent
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::SimpleContent
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::SimpleExtension
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::SimpleExtension
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::SimpleExtension
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::SimpleExtension
mt: instance
fn: valid?
fs: valid?(value)
fd: 
pt: WSDL::XMLSchema::SimpleExtension
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::SimpleRestriction
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::SimpleRestriction
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::SimpleRestriction
mt: instance
fn: valid?
fs: valid?(value)
fd: 
pt: WSDL::XMLSchema::SimpleRestriction
mt: instance
fn: base
fs: base()
fd: 
pt: WSDL::XMLSchema::SimpleType
mt: instance
fn: check_lexical_format
fs: check_lexical_format(value)
fd: 
pt: WSDL::XMLSchema::SimpleType
mt: instance
fn: new
fs: new(name = nil)
fd: 
pt: WSDL::XMLSchema::SimpleType
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::SimpleType
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::SimpleType
mt: instance
fn: targetnamespace
fs: targetnamespace()
fd: 
pt: WSDL::XMLSchema::SimpleType
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::Unique
mt: class
fn: parse_attr
fs: parse_attr(attr, value)
fd: 
pt: WSDL::XMLSchema::Unique
mt: instance
fn: parse_element
fs: parse_element(element)
fd: 
pt: WSDL::XMLSchema::Unique
mt: instance
fn: new
fs: new()
fd: 
pt: WSDL::XMLSchema::XSD2Ruby
mt: class
fn: run
fs: run()
fd: 
pt: WSDL::XMLSchema::XSD2Ruby
mt: instance
fn: new
fs: new(bind = nil)
fd: 
pt: XMP
mt: class
fn: puts
fs: puts(exps)
fd: 
pt: XMP
mt: instance
fn: eof?
fs: eof?()
fd: 
pt: XMP::StringInputMethod
mt: instance
fn: gets
fs: gets()
fd: 
pt: XMP::StringInputMethod
mt: instance
fn: new
fs: new()
fd: 
pt: XMP::StringInputMethod
mt: class
fn: puts
fs: puts(exps)
fd: 
pt: XMP::StringInputMethod
mt: instance
fn: charset_label
fs: charset_label(encoding)
fd: 
pt: XSD::Charset
mt: class
fn: charset_str
fs: charset_str(label)
fd: 
pt: XSD::Charset
mt: class
fn: encoding=
fs: encoding=(encoding)
fd: 
pt: XSD::Charset
mt: class
fn: encoding
fs: encoding()
fd: handlers
pt: XSD::Charset
mt: class
fn: encoding_conv
fs: encoding_conv(str, enc_from, enc_to)
fd: 
pt: XSD::Charset
mt: class
fn: encoding_from_xml
fs: encoding_from_xml(str, charset)
fd: 
pt: XSD::Charset
mt: class
fn: encoding_to_xml
fs: encoding_to_xml(str, charset)
fd: 
pt: XSD::Charset
mt: class
fn: init
fs: init()
fd: 
pt: XSD::Charset
mt: class
fn: is_ces
fs: is_ces(str, code = $KCODE)
fd: 
pt: XSD::Charset
mt: class
fn: is_euc
fs: is_euc(str)
fd: 
pt: XSD::Charset
mt: class
fn: is_sjis
fs: is_sjis(str)
fd: 
pt: XSD::Charset
mt: class
fn: is_us_ascii
fs: is_us_ascii(str)
fd: 
pt: XSD::Charset
mt: class
fn: is_utf8
fs: is_utf8(str)
fd: 
pt: XSD::Charset
mt: class
fn: xml_encoding_label
fs: xml_encoding_label()
fd: 
pt: XSD::Charset
mt: class
fn: def_attr
fs: def_attr(attrname, writable = true, varname = nil)
fd: 
pt: XSD::CodeGen::ClassDef
mt: instance
fn: def_classvar
fs: def_classvar(var, value)
fd: 
pt: XSD::CodeGen::ClassDef
mt: instance
fn: dump
fs: dump()
fd: 
pt: XSD::CodeGen::ClassDef
mt: instance
fn: new
fs: new(name, baseclass = nil)
fd: 
pt: XSD::CodeGen::ClassDef
mt: class
fn: capitalize
fs: capitalize(target)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: format
fs: format(str, indent = nil)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: keyword?
fs: keyword?(word)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: safeconstname?
fs: safeconstname?(name)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: safeconstname
fs: safeconstname(name)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: safemethodname?
fs: safemethodname?(name)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: safemethodname
fs: safemethodname(name)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: safevarname?
fs: safevarname?(name)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: safevarname
fs: safevarname(name)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: uncapitalize
fs: uncapitalize(target)
fd: 
pt: XSD::CodeGen::GenSupport
mt: instance
fn: dump
fs: dump()
fd: 
pt: XSD::CodeGen::MethodDef
mt: instance
fn: new
fs: new(name, *params)
fd: 
pt: XSD::CodeGen::MethodDef
mt: class
fn: add_method
fs: add_method(m, visibility = :public)
fd: 
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: def_code
fs: def_code(code)
fd: 
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: def_const
fs: def_const(const, value)
fd: 
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: def_method
fs: def_method(name, *params)
fd: 
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: def_privatemethod
fs: def_privatemethod(name, *params)
fd: 
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: def_protectedmethod
fs: def_protectedmethod(name, *params)
fd: 
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: def_publicmethod
fs: def_publicmethod(name, *params)
fd: "Alias for #def_method"
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: def_require
fs: def_require(path)
fd: 
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: dump
fs: dump()
fd: 
pt: XSD::CodeGen::ModuleDef
mt: instance
fn: new
fs: new(name)
fd: 
pt: XSD::CodeGen::ModuleDef
mt: class
fn: safe_iconv
fs: safe_iconv(to, from, str)
fd: 
pt: XSD::IconvCharset
mt: class
fn: obj2xml
fs: obj2xml(obj, elename = nil, io = nil)
fd: 
pt: XSD::Mapping
mt: class
fn: xml2obj
fs: xml2obj(stream)
fd: 
pt: XSD::Mapping
mt: class
fn: concat
fs: concat(rhs)
fd: 
pt: XSD::NamedElements
mt: instance
fn: delete
fs: delete(rhs)
fd: 
pt: XSD::NamedElements
mt: instance
fn: dup
fs: dup()
fd: 
pt: XSD::NamedElements
mt: instance
fn: each
fs: each()
fd: 
pt: XSD::NamedElements
mt: instance
fn: empty?
fs: empty?()
fd: 
pt: XSD::NamedElements
mt: instance
fn: find_name
fs: find_name(name)
fd: 
pt: XSD::NamedElements
mt: instance
fn: freeze
fs: freeze()
fd: 
pt: XSD::NamedElements
mt: instance
fn: keys
fs: keys()
fd: 
pt: XSD::NamedElements
mt: instance
fn: new
fs: new()
fd: 
pt: XSD::NamedElements
mt: class
fn: size
fs: size()
fd: 
pt: XSD::NamedElements
mt: instance
fn: assign
fs: assign(ns, tag = nil)
fd: 
pt: XSD::NS
mt: instance
fn: assigned?
fs: assigned?(ns)
fd: 
pt: XSD::NS
mt: instance
fn: assigned_tag?
fs: assigned_tag?(tag)
fd: 
pt: XSD::NS
mt: instance
fn: assign
fs: assign(ns)
fd: 
pt: XSD::NS::Assigner
mt: instance
fn: new
fs: new()
fd: 
pt: XSD::NS::Assigner
mt: class
fn: clone_ns
fs: clone_ns()
fd: 
pt: XSD::NS
mt: instance
fn: compare
fs: compare(ns, name, rhs)
fd: 
pt: XSD::NS
mt: instance
fn: each_ns
fs: each_ns()
fd: 
pt: XSD::NS
mt: instance
fn: name
fs: name(name)
fd: 
pt: XSD::NS
mt: instance
fn: new
fs: new(tag2ns = {})
fd: 
pt: XSD::NS
mt: class
fn: parse
fs: parse(str, local = false)
fd: 
pt: XSD::NS
mt: instance
fn: parse_local
fs: parse_local(elem)
fd: For local attribute key parsing
pt: XSD::NS
mt: instance
fn: inherited
fs: inherited(klass)
fd: 
pt: XSD::NSDBase
mt: class
fn: init
fs: init(type)
fd: 
pt: XSD::NSDBase
mt: instance
fn: new
fs: new()
fd: 
pt: XSD::NSDBase
mt: class
fn: types
fs: types()
fd: 
pt: XSD::NSDBase
mt: class
fn: dump
fs: dump()
fd: 
pt: XSD::QName
mt: instance
fn: dup_name
fs: dup_name(name)
fd: 
pt: XSD::QName
mt: instance
fn: eql?
fs: eql?(rhs)
fd: 
pt: XSD::QName
mt: instance
fn: hash
fs: hash()
fd: 
pt: XSD::QName
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: XSD::QName
mt: instance
fn: match
fs: match(rhs)
fd: 
pt: XSD::QName
mt: instance
fn: new
fs: new(namespace = nil, name = nil)
fd: 
pt: XSD::QName
mt: class
fn: parse
fs: parse(str)
fd: 
pt: XSD::QName
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: XSD::QName
mt: instance
fn: create_parser
fs: create_parser(host, opt)
fd: 
pt: XSD::XMLParser
mt: instance
fn: filter_ns
fs: filter_ns(ns, attrs)
fd: 
pt: XSD::XMLParser
mt: instance
fn: add_factory
fs: add_factory(factory)
fd: 
pt: XSD::XMLParser::Parser
mt: class
fn: create_parser
fs: create_parser(host, opt = {})
fd: 
pt: XSD::XMLParser::Parser
mt: class
fn: factory
fs: factory()
fd: 
pt: XSD::XMLParser::Parser
mt: class
fn: new
fs: new(host, opt = {})
fd: 
pt: XSD::XMLParser::Parser
mt: class
fn: parse
fs: parse(string_or_readable)
fd: 
pt: XSD::XMLParser::Parser
mt: instance
fn: do_parse
fs: do_parse(string_or_readable)
fd: 
pt: XSD::XMLParser::REXMLParser
mt: instance
fn: epilogue
fs: epilogue()
fd: 
pt: XSD::XMLParser::REXMLParser
mt: instance
fn: tag_end
fs: tag_end(name)
fd: 
pt: XSD::XMLParser::REXMLParser
mt: instance
fn: tag_start
fs: tag_start(name, attrs)
fd: 
pt: XSD::XMLParser::REXMLParser
mt: instance
fn: text
fs: text(text)
fd: 
pt: XSD::XMLParser::REXMLParser
mt: instance
fn: xmldecl
fs: xmldecl(version, encoding, standalone)
fd: 
pt: XSD::XMLParser::REXMLParser
mt: instance
fn: do_parse
fs: do_parse(string_or_readable)
fd: 
pt: XSD::XMLParser::XMLParser
mt: instance
fn: do_parse
fs: do_parse(string_or_readable)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_attr_charref
fs: on_attr_charref(code)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_attr_charref_hex
fs: on_attr_charref_hex(code)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_attr_entityref
fs: on_attr_entityref(ref)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_attr_value
fs: on_attr_value(str)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_attribute
fs: on_attribute(name)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_chardata
fs: on_chardata(str)
fd: def on_pi(target, pi); end
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_charref
fs: on_charref(code)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_charref_hex
fs: on_charref_hex(code)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_entityref
fs: on_entityref(ref)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_etag
fs: on_etag(name)
fd: def on_cdata(str); end
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_stag
fs: on_stag(name)
fd: def on_end_document; end
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_stag_end
fs: on_stag_end(name)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_stag_end_empty
fs: on_stag_end_empty(name)
fd: def on_attribute_end(name); end
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_xmldecl_encoding
fs: on_xmldecl_encoding(str)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: on_xmldecl_version
fs: on_xmldecl_version(str)
fd: def on_xmldecl; end
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: parse_error
fs: parse_error(msg)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: scanner_kcode=
fs: scanner_kcode=(charset)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: valid_error
fs: valid_error(msg)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: warning
fs: warning(msg)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: wellformed_error
fs: wellformed_error(msg)
fd: 
pt: XSD::XMLParser::XMLScanner
mt: instance
fn: check_lexical_format
fs: check_lexical_format(value)
fd: true or raise
pt: XSD::XSDAnySimpleType
mt: instance
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDAnySimpleType
mt: class
fn: set
fs: set(value)
fd: "set accepts a string which follows lexical space (ex. String: &quot;+123&quot;), or an object which follows canonical space (ex. Integer: 123)."
pt: XSD::XSDAnySimpleType
mt: instance
fn: to_s
fs: to_s()
fd: "to_s creates a string which follows lexical space (ex. String: &quot;123&quot;)."
pt: XSD::XSDAnySimpleType
mt: instance
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDAnyURI
mt: class
fn: new
fs: new(value = nil)
fd: String in Ruby could be a binary.
pt: XSD::XSDBase64Binary
mt: class
fn: set_encoded
fs: set_encoded(value)
fd: 
pt: XSD::XSDBase64Binary
mt: instance
fn: string
fs: string()
fd: 
pt: XSD::XSDBase64Binary
mt: instance
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDBoolean
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDByte
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDDate
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDDateTime
mt: class
fn: add_tz
fs: add_tz(s)
fd: 
pt: XSD::XSDDateTimeImpl
mt: instance
fn: of2tz
fs: of2tz(offset)
fd: 
pt: XSD::XSDDateTimeImpl
mt: instance
fn: screen_data
fs: screen_data(t)
fd: 
pt: XSD::XSDDateTimeImpl
mt: instance
fn: to_date
fs: to_date()
fd: 
pt: XSD::XSDDateTimeImpl
mt: instance
fn: to_datetime
fs: to_datetime()
fd: 
pt: XSD::XSDDateTimeImpl
mt: instance
fn: to_obj
fs: to_obj(klass)
fd: 
pt: XSD::XSDDateTimeImpl
mt: instance
fn: to_time
fs: to_time()
fd: 
pt: XSD::XSDDateTimeImpl
mt: instance
fn: tz2of
fs: tz2of(str)
fd: 
pt: XSD::XSDDateTimeImpl
mt: instance
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDDecimal
mt: class
fn: nonzero?
fs: nonzero?()
fd: 
pt: XSD::XSDDecimal
mt: instance
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDDouble
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDDuration
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDFloat
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDGDay
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDGMonth
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDGMonthDay
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDGYear
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDGYearMonth
mt: class
fn: new
fs: new(value = nil)
fd: String in Ruby could be a binary.
pt: XSD::XSDHexBinary
mt: class
fn: set_encoded
fs: set_encoded(value)
fd: 
pt: XSD::XSDHexBinary
mt: instance
fn: string
fs: string()
fd: 
pt: XSD::XSDHexBinary
mt: instance
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDInt
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDInteger
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDLong
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDNegativeInteger
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDNil
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDNonNegativeInteger
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDNonPositiveInteger
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDNormalizedString
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDPositiveInteger
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDQName
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDShort
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDString
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDTime
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDUnsignedByte
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDUnsignedInt
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDUnsignedLong
mt: class
fn: new
fs: new(value = nil)
fd: 
pt: XSD::XSDUnsignedShort
mt: class
fn: add_builtin_type
fs: add_builtin_type( type_tag, &transfer_proc )
fd: Add a transfer method for a builtin type
pt: YAML
mt: class
fn: add_domain_type
fs: add_domain_type( domain, type_tag, &transfer_proc )
fd: Add a global handler for a YAML domain type.
pt: YAML
mt: class
fn: add_private_type
fs: add_private_type( type_re, &transfer_proc )
fd: Add a private document type
pt: YAML
mt: class
fn: add_ruby_type
fs: add_ruby_type( type_tag, &transfer_proc )
fd: Add a transfer method for a builtin type
pt: YAML
mt: class
fn: binary_base64
fs: binary_base64( value )
fd: Emit binary data
pt: YAML::BaseEmitter
mt: instance
fn: double
fs: double( value )
fd: Emit double-quoted string
pt: YAML::BaseEmitter
mt: instance
fn: fold
fs: fold( value )
fd: Folding paragraphs within a column
pt: YAML::BaseEmitter
mt: instance
fn: indent!
fs: indent!()
fd: Add indent to the buffer
pt: YAML::BaseEmitter
mt: instance
fn: indent
fs: indent( mod = nil )
fd: Write a current indent
pt: YAML::BaseEmitter
mt: instance
fn: indent_text
fs: indent_text( text, mod, first_line = true )
fd: Write a text block with the current indent
pt: YAML::BaseEmitter
mt: instance
fn: map
fs: map( type, &e )
fd: Quick mapping
pt: YAML::BaseEmitter
mt: instance
fn: node_text
fs: node_text( value, block = nil )
fd: Emit plain, normal flowing text
pt: YAML::BaseEmitter
mt: instance
fn: options=
fs: options=( opt )
fd: 
pt: YAML::BaseEmitter
mt: instance
fn: options
fs: options( opt = nil )
fd: 
pt: YAML::BaseEmitter
mt: instance
fn: seq
fs: seq( type, &e )
fd: Quick sequence
pt: YAML::BaseEmitter
mt: instance
fn: seq_map_shortcut
fs: seq_map_shortcut()
fd: 
pt: YAML::BaseEmitter
mt: instance
fn: simple
fs: simple( value )
fd: Emit a simple, unqouted string
pt: YAML::BaseEmitter
mt: instance
fn: single
fs: single( value )
fd: Emit single-quoted string
pt: YAML::BaseEmitter
mt: instance
fn: at
fs: at( seg )
fd: 
pt: YAML::BaseNode
mt: instance
fn: children
fs: children()
fd: 
pt: YAML::BaseNode
mt: instance
fn: children_with_index
fs: children_with_index()
fd: 
pt: YAML::BaseNode
mt: instance
fn: emit
fs: emit()
fd: 
pt: YAML::BaseNode
mt: instance
fn: match_path
fs: match_path( ypath_str )
fd: YPath search returning a complete depth array
pt: YAML::BaseNode
mt: instance
fn: match_segment
fs: match_segment( ypath, depth )
fd: Search a node for a single YPath segment
pt: YAML::BaseNode
mt: instance
fn: search
fs: search( ypath_str )
fd: Search for YPath entry and return a list of qualified paths.
pt: YAML::BaseNode
mt: instance
fn: select!
fs: select!( ypath_str )
fd: Search for YPath entry and return transformed nodes.
pt: YAML::BaseNode
mt: instance
fn: select
fs: select( ypath_str )
fd: Search for YPath entry and return qualified nodes.
pt: YAML::BaseNode
mt: instance
fn: delete
fs: delete( key )
fd: 
pt: YAML::DBM
mt: instance
fn: delete_if
fs: delete_if()
fd: 
pt: YAML::DBM
mt: instance
fn: each
fs: each()
fd: "Alias for #each_pair"
pt: YAML::DBM
mt: instance
fn: each_pair
fs: each_pair()
fd: 
pt: YAML::DBM
mt: instance
fn: each_value
fs: each_value()
fd: 
pt: YAML::DBM
mt: instance
fn: fetch
fs: fetch( keystr, ifnone = nil )
fd: 
pt: YAML::DBM
mt: instance
fn: has_value?
fs: has_value?( val )
fd: 
pt: YAML::DBM
mt: instance
fn: index
fs: index( keystr )
fd: 
pt: YAML::DBM
mt: instance
fn: invert
fs: invert()
fd: 
pt: YAML::DBM
mt: instance
fn: reject
fs: reject()
fd: 
pt: YAML::DBM
mt: instance
fn: replace
fs: replace( hsh )
fd: 
pt: YAML::DBM
mt: instance
fn: select
fs: select( *keys )
fd: 
pt: YAML::DBM
mt: instance
fn: shift
fs: shift()
fd: 
pt: YAML::DBM
mt: instance
fn: store
fs: store( key, val )
fd: 
pt: YAML::DBM
mt: instance
fn: to_a
fs: to_a()
fd: 
pt: YAML::DBM
mt: instance
fn: to_hash
fs: to_hash()
fd: 
pt: YAML::DBM
mt: instance
fn: update
fs: update( hsh )
fd: 
pt: YAML::DBM
mt: instance
fn: values
fs: values()
fd: 
pt: YAML::DBM
mt: instance
fn: values_at
fs: values_at( *keys )
fd: 
pt: YAML::DBM
mt: instance
fn: detect_implicit
fs: detect_implicit( val )
fd: Detect typing of a string
pt: YAML
mt: class
fn: new
fs: new( domain, type, val )
fd: 
pt: YAML::DomainType
mt: class
fn: tag_subclasses?
fs: tag_subclasses?()
fd: 
pt: YAML::DomainType
mt: class
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: YAML::DomainType
mt: instance
fn: dump
fs: dump( obj, io = nil )
fd: Converts obj to YAML and writes the YAML result to io.
pt: YAML
mt: class
fn: dump_stream
fs: dump_stream( *objs )
fd: Returns a YAML stream containing each of the items in objs, each having their own document.
pt: YAML
mt: class
fn: each_document
fs: each_document( io, &block )
fd: Calls block with each consecutive document in the YAML stream contained in io.
pt: YAML
mt: class
fn: each_node
fs: each_node( io, &doc_proc )
fd: Calls block with a tree of +YAML::BaseNodes+, one tree for each consecutive document in the YAML stream contained in io.
pt: YAML
mt: class
fn: emitter
fs: emitter()
fd: Returns a new default emitter
pt: YAML
mt: class
fn: escape
fs: escape( value, skip = "" )
fd: Escape the string, condensing common escapes
pt: YAML
mt: class
fn: generic_parser
fs: generic_parser()
fd: Returns a new generic parser
pt: YAML
mt: class
fn: load
fs: load( io )
fd: Load a document from the current io stream.
pt: YAML
mt: class
fn: load_documents
fs: load_documents( io, &doc_proc )
fd: Calls block with each consecutive document in the YAML stream contained in io.
pt: YAML
mt: class
fn: load_file
fs: load_file( filepath )
fd: Load a document from the file located at filepath.
pt: YAML
mt: class
fn: load_stream
fs: load_stream( io )
fd: Loads all documents from the current io stream, returning a +YAML::Stream+ object containing all loaded documents.
pt: YAML
mt: class
fn: make_stream
fs: make_stream( io )
fd: Class method for creating streams
pt: YAML
mt: class
fn: add
fs: add( k, v )
fd: 
pt: YAML::Mapping
mt: instance
fn: tag_subclasses?
fs: tag_subclasses?()
fd: 
pt: YAML::Object
mt: class
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: YAML::Object
mt: instance
fn: object_maker
fs: object_maker( obj_class, val )
fd: Allocate blank object
pt: YAML
mt: class
fn: has_key?
fs: has_key?( k )
fd: 
pt: YAML::Omap
mt: instance
fn: is_complex_yaml?
fs: is_complex_yaml?()
fd: 
pt: YAML::Omap
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: YAML::Omap
mt: instance
fn: yaml_initialize
fs: yaml_initialize( tag, val )
fd: 
pt: YAML::Omap
mt: instance
fn: has_key?
fs: has_key?( k )
fd: 
pt: YAML::Pairs
mt: instance
fn: is_complex_yaml?
fs: is_complex_yaml?()
fd: 
pt: YAML::Pairs
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: YAML::Pairs
mt: instance
fn: yaml_initialize
fs: yaml_initialize( tag, val )
fd: 
pt: YAML::Pairs
mt: instance
fn: parse
fs: parse( io )
fd: Parse the first document from the current io stream
pt: YAML
mt: class
fn: parse_documents
fs: parse_documents( io, &doc_proc )
fd: Calls block with a tree of +YAML::BaseNodes+, one tree for each consecutive document in the YAML stream contained in io.
pt: YAML
mt: class
fn: parse_file
fs: parse_file( filepath )
fd: Parse a document from the file located at filepath.
pt: YAML
mt: class
fn: parser
fs: parser()
fd: Returns a new default parser
pt: YAML
mt: class
fn: new
fs: new( type, val )
fd: 
pt: YAML::PrivateType
mt: class
fn: tag_subclasses?
fs: tag_subclasses?()
fd: 
pt: YAML::PrivateType
mt: class
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: YAML::PrivateType
mt: instance
fn: quick_emit
fs: quick_emit( oid, opts = {}, &e )
fd: Allocate an Emitter if needed
pt: YAML
mt: class
fn: read_type_class
fs: read_type_class( type, obj_class )
fd: Method to extract colon-seperated type and class, returning the type and the constant of the class
pt: YAML
mt: class
fn: resolver
fs: resolver()
fd: Returns the default resolver
pt: YAML
mt: class
fn: add
fs: add( v )
fd: 
pt: YAML::Sequence
mt: instance
fn: inspect
fs: inspect()
fd: 
pt: YAML::SpecialHash
mt: instance
fn: to_s
fs: to_s()
fd: 
pt: YAML::SpecialHash
mt: instance
fn: to_yaml
fs: to_yaml( opts = {} )
fd: 
pt: YAML::SpecialHash
mt: instance
fn: update
fs: update( h )
fd: 
pt: YAML::SpecialHash
mt: instance
fn: dump
fs: dump(table)
fd: 
pt: YAML::Store
mt: instance
fn: load
fs: load(content)
fd: 
pt: YAML::Store
mt: instance
fn: load_file
fs: load_file(file)
fd: 
pt: YAML::Store
mt: instance
fn: new
fs: new( *o )
fd: 
pt: YAML::Store
mt: class
fn: add
fs: add( doc )
fd: 
pt: YAML::Stream
mt: instance
fn: edit
fs: edit( doc_num, doc )
fd: 
pt: YAML::Stream
mt: instance
fn: emit
fs: emit( io = nil )
fd: 
pt: YAML::Stream
mt: instance
fn: new
fs: new( opts = {} )
fd: 
pt: YAML::Stream
mt: class
fn: tag_class
fs: tag_class( tag, cls )
fd: "Associates a taguri tag with a Ruby class cls. The taguri is used to give types to classes when loading YAML. Taguris are of the form:"
pt: YAML
mt: class
fn: tagged_classes
fs: tagged_classes()
fd: Returns the complete dictionary of taguris, paired with classes. The key for the dictionary is the full taguri. The value for each key is the class constant associated to that taguri.
pt: YAML
mt: class
fn: tagurize
fs: tagurize( val )
fd: Convert a type_id to a taguri
pt: YAML
mt: class
fn: transfer
fs: transfer( type_id, obj )
fd: Apply a transfer method to a Ruby object
pt: YAML
mt: class
fn: try_implicit
fs: try_implicit( obj )
fd: Apply any implicit a node may qualify for
pt: YAML
mt: class
fn: unescape
fs: unescape( value )
fd: Unescape the condenses escapes
pt: YAML
mt: class
fn: new
fs: new( t, v )
fd: 
pt: YAML::YamlNode
mt: class
fn: transform
fs: transform()
fd: Transform this node fully into a native type
pt: YAML::YamlNode
mt: instance
fn: each_path
fs: each_path( str )
fd: 
pt: YAML::YPath
mt: class
fn: new
fs: new( str )
fd: 
pt: YAML::YPath
mt: class
fn: adler32
fs: adler32" Zlib.adler32(string, adler)
fd: Calculates Alder-32 checksum for string, and returns updated value of adler. If string is omitted, it returns the Adler-32 initial value. If adler is omitted, it assumes that the initial value is given to adler.
pt: Zlib
mt: class
fn: crc32
fs: crc32" Zlib.crc32(string, adler)
fd: Calculates CRC checksum for string, and returns updated value of crc. If string is omitted, it returns the CRC initial value. If crc is omitted, it assumes that the initial value is given to crc.
pt: Zlib
mt: class
fn: crc_table
fs: crc_table()
fd: Returns the table for calculating CRC checksum as an array.
pt: Zlib
mt: class
fn: deflate
fs: deflate" Zlib::Deflate.deflate(string[, level])
fd: Compresses the given string. Valid values of level are Zlib::NO_COMPRESSION, Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION, and an integer from 0 to 9.
pt: Zlib::Deflate
mt: class
fn: deflate
fs: deflate" deflate(string[, flush])
fd: Inputs string into the deflate stream and returns the output from the stream. On calling this method, both the input and the output buffers of the stream are flushed. If string is nil, this method finishes the stream, just like Zlib::ZStream#finish.
pt: Zlib::Deflate
mt: instance
fn: flush
fs: flush" flush(flush)
fd: This method is equivalent to deflate('', flush). If flush is omitted, Zlib::SYNC_FLUSH is used as flush. This method is just provided to improve the readability of your Ruby program.
pt: Zlib::Deflate
mt: instance
fn: initialize_copy
fs: initialize_copy()
fd: Duplicates the deflate stream.
pt: Zlib::Deflate
mt: instance
fn: new
fs: new" Zlib::Deflate.new(level=nil, windowBits=nil, memlevel=nil, strategy=nil)
fd: Creates a new deflate stream for compression. See zlib.h for details of each argument. If an argument is nil, the default value of that argument is used.
pt: Zlib::Deflate
mt: class
fn: params
fs: params" params(level, strategy)
fd: Changes the parameters of the deflate stream. See zlib.h for details. The output from the stream by changing the params is preserved in output buffer.
pt: Zlib::Deflate
mt: instance
fn: set_dictionary
fs: set_dictionary" set_dictionary(string)
fd: Sets the preset dictionary and returns string. This method is available just only after Zlib::Deflate.new or Zlib::ZStream#reset method was called. See zlib.h for details.
pt: Zlib::Deflate
mt: instance
fn: close
fs: close()
fd: Closes the GzipFile object. This method calls close method of the associated IO object. Returns the associated IO object.
pt: Zlib::GzipFile
mt: instance
fn: closed?
fs: closed?()
fd: Same as IO.
pt: Zlib::GzipFile
mt: instance
fn: comment
fs: comment()
fd: Returns comments recorded in the gzip file header, or nil if the comments is not present.
pt: Zlib::GzipFile
mt: instance
fn: crc
fs: crc()
fd: Returns CRC value of the uncompressed data.
pt: Zlib::GzipFile
mt: instance
fn: finish
fs: finish()
fd: Closes the GzipFile object. Unlike Zlib::GzipFile#close, this method never calls the close method of the associated IO object. Returns the associated IO object.
pt: Zlib::GzipFile
mt: instance
fn: level
fs: level()
fd: Returns compression level.
pt: Zlib::GzipFile
mt: instance
fn: mtime
fs: mtime()
fd: Returns last modification time recorded in the gzip file header.
pt: Zlib::GzipFile
mt: instance
fn: orig_name
fs: orig_name()
fd: Returns original filename recorded in the gzip file header, or nil if original filename is not present.
pt: Zlib::GzipFile
mt: instance
fn: os_code
fs: os_code()
fd: Returns OS code number recorded in the gzip file header.
pt: Zlib::GzipFile
mt: instance
fn: sync=
fs: sync=
fd: Same as IO. If flag is true, the associated IO object must respond to the flush method. While sync mode is true, the compression ratio decreases sharply.
pt: Zlib::GzipFile
mt: instance
fn: sync
fs: sync()
fd: Same as IO.
pt: Zlib::GzipFile
mt: instance
fn: to_io
fs: to_io()
fd: Same as IO.
pt: Zlib::GzipFile
mt: instance
fn: wrap
fs: wrap(...)
fd: See Zlib::GzipReader#wrap and Zlib::GzipWriter#wrap.
pt: Zlib::GzipFile
mt: class
fn: each
fs: each(...)
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: each_byte
fs: each_byte()
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: each_line
fs: each_line(...)
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: eof?
fs: eof?()
fd: ???
pt: Zlib::GzipReader
mt: instance
fn: eof
fs: eof()
fd: ???
pt: Zlib::GzipReader
mt: instance
fn: getc
fs: getc()
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: gets
fs: gets(...)
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: lineno=
fs: lineno=(p1)
fd: ???
pt: Zlib::GzipReader
mt: instance
fn: lineno
fs: lineno()
fd: ???
pt: Zlib::GzipReader
mt: instance
fn: new
fs: new" Zlib::GzipReader.new(io)
fd: Creates a GzipReader object associated with io. The GzipReader object reads gzipped data from io, and parses/decompresses them. At least, io must have a read method that behaves same as the read method in IO class.
pt: Zlib::GzipReader
mt: class
fn: open
fs: open" Zlib::GzipReader.open(filename)
fd: Opens a file specified by filename as a gzipped file, and returns a GzipReader object associated with that file. Further details of this method are in Zlib::GzipReader.new and ZLib::GzipReader.wrap.
pt: Zlib::GzipReader
mt: class
fn: pos
fs: pos()
fd: ???
pt: Zlib::GzipReader
mt: instance
fn: read
fs: read(...)
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: readchar
fs: readchar()
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: readline
fs: readline(...)
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: readlines
fs: readlines(...)
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: rewind
fs: rewind()
fd: Resets the position of the file pointer to the point created the GzipReader object. The associated IO object needs to respond to the seek method.
pt: Zlib::GzipReader
mt: instance
fn: tell
fs: tell()
fd: ???
pt: Zlib::GzipReader
mt: instance
fn: ungetc
fs: ungetc(p1)
fd: See Zlib::GzipReader documentation for a description.
pt: Zlib::GzipReader
mt: instance
fn: unused
fs: unused()
fd: Returns the rest of the data which had read for parsing gzip format, or nil if the whole gzip file is not parsed yet.
pt: Zlib::GzipReader
mt: instance
fn: comment=
fs: comment=(p1)
fd: ???
pt: Zlib::GzipWriter
mt: instance
fn: flush
fs: flush" flush(flush=nil)
fd: Flushes all the internal buffers of the GzipWriter object. The meaning of flush is same as in Zlib::Deflate#deflate. Zlib::SYNC_FLUSH is used if flush is omitted. It is no use giving flush Zlib::NO_FLUSH.
pt: Zlib::GzipWriter
mt: instance
fn: mtime=
fs: mtime=(p1)
fd: ???
pt: Zlib::GzipWriter
mt: instance
fn: new
fs: new" Zlib::GzipWriter.new(io, level, strategy)
fd: Creates a GzipWriter object associated with io. level and strategy should be the same as the arguments of Zlib::Deflate.new. The GzipWriter object writes gzipped data to io. At least, io must respond to the write method that behaves same as write method in IO class.
pt: Zlib::GzipWriter
mt: class
fn: open
fs: open" Zlib::GzipWriter.open(filename, level=nil, strategy=nil)
fd: Opens a file specified by filename for writing gzip compressed data, and returns a GzipWriter object associated with that file. Further details of this method are found in Zlib::GzipWriter.new and Zlib::GzipWriter#wrap.
pt: Zlib::GzipWriter
mt: class
fn: orig_name=
fs: orig_name=(p1)
fd: ???
pt: Zlib::GzipWriter
mt: instance
fn: pos
fs: pos()
fd: ???
pt: Zlib::GzipWriter
mt: instance
fn: print
fs: print(...)
fd: "Document-method: print Same as IO."
pt: Zlib::GzipWriter
mt: instance
fn: printf
fs: printf(...)
fd: "Document-method: printf Same as IO."
pt: Zlib::GzipWriter
mt: instance
fn: putc
fs: putc(p1)
fd: Same as IO.
pt: Zlib::GzipWriter
mt: instance
fn: puts
fs: puts(...)
fd: "Document-method: puts Same as IO."
pt: Zlib::GzipWriter
mt: instance
fn: tell
fs: tell()
fd: ???
pt: Zlib::GzipWriter
mt: instance
fn: write
fs: write(p1)
fd: Same as IO.
pt: Zlib::GzipWriter
mt: instance
fn: inflate
fs: inflate" Zlib::Inflate.inflate(string)
fd: Decompresses string. Raises a Zlib::NeedDict exception if a preset dictionary is needed for decompression.
pt: Zlib::Inflate
mt: class
fn: inflate
fs: inflate" inflate(string)
fd: Inputs string into the inflate stream and returns the output from the stream. Calling this method, both the input and the output buffer of the stream are flushed. If string is nil, this method finishes the stream, just like Zlib::ZStream#finish.
pt: Zlib::Inflate
mt: instance
fn: new
fs: new" Zlib::Inflate.new(window_bits)
fd: Creates a new inflate stream for decompression. See zlib.h for details of the argument. If window_bits is nil, the default value is used.
pt: Zlib::Inflate
mt: class
fn: set_dictionary
fs: set_dictionary(p1)
fd: Sets the preset dictionary and returns string. This method is available just only after a Zlib::NeedDict exception was raised. See zlib.h for details.
pt: Zlib::Inflate
mt: instance
fn: sync
fs: sync" sync(string)
fd: Inputs string into the end of input buffer and skips data until a full flush point can be found. If the point is found in the buffer, this method flushes the buffer and returns false. Otherwise it returns true and the following data of full flush point is preserved in the buffer.
pt: Zlib::Inflate
mt: instance
fn: sync_point?
fs: sync_point?()
fd: "Quoted verbatim from original documentation:"
pt: Zlib::Inflate
mt: instance
fn: zlib_version
fs: zlib_version()
fd: Returns the string which represents the version of zlib library.
pt: Zlib
mt: class
fn: adler
fs: adler()
fd: Returns the adler-32 checksum.
pt: Zlib::ZStream
mt: instance
fn: avail_in
fs: avail_in()
fd: Returns bytes of data in the input buffer. Normally, returns 0.
pt: Zlib::ZStream
mt: instance
fn: avail_out=
fs: avail_out=(p1)
fd: Allocates size bytes of free space in the output buffer. If there are more than size bytes already in the buffer, the buffer is truncated. Because free space is allocated automatically, you usually don't need to use this method.
pt: Zlib::ZStream
mt: instance
fn: avail_out
fs: avail_out()
fd: Returns number of bytes of free spaces in output buffer. Because the free space is allocated automatically, this method returns 0 normally.
pt: Zlib::ZStream
mt: instance
fn: close
fs: close()
fd: Closes the stream. All operations on the closed stream will raise an exception.
pt: Zlib::ZStream
mt: instance
fn: closed?
fs: closed?()
fd: Returns true if the stream is closed.
pt: Zlib::ZStream
mt: instance
fn: data_type
fs: data_type()
fd: Guesses the type of the data which have been inputed into the stream. The returned value is either Zlib::BINARY, Zlib::ASCII, or Zlib::UNKNOWN.
pt: Zlib::ZStream
mt: instance
fn: end
fs: end()
fd: Closes the stream. All operations on the closed stream will raise an exception.
pt: Zlib::ZStream
mt: instance
fn: ended?
fs: ended?()
fd: Returns true if the stream is closed.
pt: Zlib::ZStream
mt: instance
fn: finish
fs: finish()
fd: Finishes the stream and flushes output buffer. See Zlib::Deflate#finish and Zlib::Inflate#finish for details of this behavior.
pt: Zlib::ZStream
mt: instance
fn: finished?
fs: finished?()
fd: Returns true if the stream is finished.
pt: Zlib::ZStream
mt: instance
fn: flush_next_in
fs: flush_next_in()
fd: Flushes input buffer and returns all data in that buffer.
pt: Zlib::ZStream
mt: instance
fn: flush_next_out
fs: flush_next_out()
fd: Flushes output buffer and returns all data in that buffer.
pt: Zlib::ZStream
mt: instance
fn: reset
fs: reset()
fd: Resets and initializes the stream. All data in both input and output buffer are discarded.
pt: Zlib::ZStream
mt: instance
fn: stream_end?
fs: stream_end?()
fd: Returns true if the stream is finished.
pt: Zlib::ZStream
mt: instance
fn: total_in
fs: total_in()
fd: Returns the total bytes of the input data to the stream. FIXME
pt: Zlib::ZStream
mt: instance
fn: total_out
fs: total_out()
fd: Returns the total bytes of the output data from the stream. FIXME
pt: Zlib::ZStream
mt: instance